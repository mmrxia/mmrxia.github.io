<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="前端博客 | hexo | github">
<meta property="og:type" content="website">
<meta property="og:title" content="芥子园 | xiaqingsong's blog">
<meta property="og:url" content="http://mmrxia.github.io/page/2/index.html">
<meta property="og:site_name" content="芥子园 | xiaqingsong's blog">
<meta property="og:description" content="前端博客 | hexo | github">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="芥子园 | xiaqingsong's blog">
<meta name="twitter:description" content="前端博客 | hexo | github">
    
    <title>
        芥子园 | xiaqingsong&#39;s blog
    </title>
    <link rel="alternative" href="/atom.xml" title="芥子园 | xiaqingsong&#39;s blog" type="application/atom+xml"> 
    <link rel="icon" href="http://7xth8v.com2.z0.glb.clouddn.com/icon/favicon.ico"> 
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/prism.css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xth8v.com2.z0.glb.qiniucdn.com/image/avatar_150x150.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">芥子园</a></h1>
		</hgroup>

		
		<p class="header-subtitle">须弥藏芥子，芥子纳须弥</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/随笔">随笔</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/mmrxia" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/u/1984883035" title="weibo">weibo</a>
					        
								<a class="twitter" target="_blank" href="https://twitter.com/xiaqingsong" title="twitter">twitter</a>
					        
								<a class="linkedin" target="_blank" href="http://www.linkedin.com/in/mrxia" title="linkedin">linkedin</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Linux/" style="font-size: 13.33px;">Linux</a> <a href="/tags/base64/" style="font-size: 10px;">base64</a> <a href="/tags/bash/" style="font-size: 10px;">bash</a> <a href="/tags/bigPipe/" style="font-size: 10px;">bigPipe</a> <a href="/tags/cnpm/" style="font-size: 10px;">cnpm</a> <a href="/tags/express/" style="font-size: 10px;">express</a> <a href="/tags/git/" style="font-size: 16.67px;">git</a> <a href="/tags/javascript/" style="font-size: 13.33px;">javascript</a> <a href="/tags/js/" style="font-size: 16.67px;">js</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/mongodb/" style="font-size: 13.33px;">mongodb</a> <a href="/tags/nodejs/" style="font-size: 20px;">nodejs</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/sku/" style="font-size: 10px;">sku</a> <a href="/tags/uuid/" style="font-size: 10px;">uuid</a> <a href="/tags/前端/" style="font-size: 10px;">前端</a> <a href="/tags/数组/" style="font-size: 10px;">数组</a> <a href="/tags/移动端开发/" style="font-size: 10px;">移动端开发</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/西游记/" style="font-size: 13.33px;">西游记</a> <a href="/tags/跨域/" style="font-size: 10px;">跨域</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.xiaqingsong.com">XQS</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.morg.cn">MORG</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.iamaddy.net/">Addy的网络日志</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">夏青松，2013年毕业于江西农大软件学院软件工程专业。<br/> <b>2012.10-2015.2</b> [北京] 锐捷网络<br/> <b>2015.2-至今</b> [杭州] 妈妈好网络<br/><br/> Mail：this.xqs@gmail.com </div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">芥子园</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xth8v.com2.z0.glb.qiniucdn.com/image/avatar_150x150.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">芥子园</h1>
			</hgroup>
			
			<p class="header-subtitle">须弥藏芥子，芥子纳须弥</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/mmrxia" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/1984883035" title="weibo">weibo</a>
			        
						<a class="twitter" target="_blank" href="https://twitter.com/xiaqingsong" title="twitter">twitter</a>
			        
						<a class="linkedin" target="_blank" href="http://www.linkedin.com/in/mrxia" title="linkedin">linkedin</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-16年后web开发趋势思考" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/27/16年后web开发趋势思考/" class="article-date">
  	<time datetime="2016-06-27T07:21:44.000Z" itemprop="datePublished">2016-06-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/27/16年后web开发趋势思考/">16年后web开发趋势思考</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Rewriting your Frontend Framework every six week !!!</p>
</blockquote>
<h3 id="近二年的进展"><a href="#近二年的进展" class="headerlink" title="近二年的进展"></a>近二年的进展</h3><p>前端发展日新月异, 甚至有一句戏言: “每六星期重写一个前端框架”, 行业是像火箭一样, 但我们前端工程师该何去何从呢?<br>我们来谈谈这个问题.<br>先来看看最流行的几项技术栈:  </p>
<ul>
<li><p>AngularJS<br>首创的双向数据绑定, 以及内置的模块注入, 以及组件化的支持, 种种优势, 使得它迅速发展起来. 在 2014-2015 年, 有调查显示, 在使用了前端框架的项目, 有 50% 以上采用了 AngularJS. 但到底值不值我们继续学习, 我们再接下来看.<br>项目地址: <a href="https://angularjs.org/" target="_blank" rel="external"></a></p>
</li>
<li><p>EmberJS<br>受 Rails 全栈框架的启发, EmberJS 逐步发展成前端领域的另一个 “Rails”, 成为另一个独特的选择, 理论上, 你选择了 EmberJS, 就选择了一个完整稳定的生态, 不用再折腾的轮子. EmberJS 不仅全面支持模块化, MVC, 也实现了类似 AngularJS 的双向绑定( 当然原理不同 ), 甚至还做到了内置的打包和发布应用功能. 总而言之, 它是一个十分全面的前端框架. 事实上, 如果说 AngularJS 是当前短暂的前端史的一个高峰, 它就是另一个高峰. 但最近, 人气有一定的下降, 原因何在, 我们再分解.<br>项目地址: <a href="http://emberjs.com/" target="_blank" rel="external"></a></p>
</li>
<li><p>ReactJS<br>ReactJS 自发布之始, 就人气很高, 它是第一个采用虚拟节点( virtual dom )技术的框架, 通过这个技术点, 它独创性地整合了函数性编程的理念, 采用单向数据流来设计 dom 渲染与比对, 使得它轻量和灵活, 事实上, 它本身只专注于如何渲染 UI, 也不与 AngularJS 和 EmberJS 有冲突. 换言之, 你可以将它整合到其他框架中.<br>随着 ReactNative 和 Redux 方案的出现, ReactJS 重新回到前端的浪尖, 因为其简洁优雅的实现和对 Native APP 的冲击, 又一次成为新的弄潮儿.<br>但以后会怎么样, 谁也不知道, 但我也会再给一些解读.<br>项目地址: <a href="https://facebook.github.io/react/" target="_blank" rel="external"></a></p>
</li>
</ul>
<p>流行不一定是发展最快, 我们再来看看近二年发展最快的几项前端技术栈:  </p>
<ul>
<li><p>ReactJS<br>上文已经提到, React 由于本身的简洁性和对组件化专注的实现, 一直没有被新的 ES6 标准和前端思潮落下, 它几乎不受 ES6 的影响, 以及前沿性的支持 native app 开发( 通过 ReactNative ), 所以一直发展趋势良好.<br>而 AngularJS 则不一样, 由于 ES6 的发布, 使得它的依赖注入特性成为鸡肋, 以及 AngularJS 第一版对组件化支持的蹩脚实现( 能支持是一回事, 好用是另一回事 ), 而组件化则学习成本过高, 过于复杂, 所以 AngularJS 决定推翻设计重新开发第二版, 而第二版过于激进的采用 Typescript, 完全不兼容的第一版的设计, 以及各种魔法的应用, 使得它离前端越走越远.   </p>
</li>
<li><p>VueJS<br>VueJS 是近二年的新秀, 它起步之初, 只是一个简化版的类似于 AngularJS 双向绑定的实现的研究( 当然原理并不同 ). 但其理念与 ReactJS 相近, 只是专注于实现数据绑定, 模块化与组件化, 所以足够的简单灵活.<br>随着生态的快速发展, VueJS 正好接了 AngularJS 第一版的班, 又改良了 AngularJS 的错误设计( 事后来看, 依赖注入与组件化两部分是比较失败的设计 ), 整体发展迅速, 逐步成为后起之秀.<br>项目地址: <a href="http://vuejs.org/" target="_blank" rel="external"></a></p>
</li>
<li><p>MeteorJS<br>MeteorJS 本不适合与上述几个前端框架比较, 因为它实际是一个全栈框架, 更像 Rails 这种角色, 但由于它是纯 Javascript 的方案, 所以还是放在这里.<br>如果说上述前端框架都是解决前端工程化的产物, 那 MeteorJS 是一个颠覆思维的 web 开发框架, 它将Javascript 同构技术应用到极端, 再整合 websocket 进行实时数据通知与热代码更新, 不同于前后端分离的理念, 它在开发者角度完全没有前后端的概念, API 既在前端又在后端, 再加它全生态的支持( 移动 app 支持, 应用发布), 也是一个全新的视角, 由于它发展速度极快, 所以列在这里.<br>项目地址: <a href="https://www.meteor.com/" target="_blank" rel="external"></a></p>
</li>
</ul>
<p>各大框架都在迅速发展中, 它们有几个共性的发展方向:  </p>
<ul>
<li><p>ES6 支持<br>每一次 Javascript 的新标准发布, 都是各大框架更新的好机会, 所以 ES6 是肯定得到各大框架的良好支持, 建议大家一定要学好.</p>
</li>
<li><p>web 组件化<br>毋庸置疑, 组件化是现代前端工程化中极为重要的特性, 甚至 google 还专门出了 Polymer 这个只做组件化实现的框架. 所以每一个够格的前端框架都非常重度支持它. 同时, 组件化也将作为 w3c 标准予于定义, 所以前端框架仍将不留余力地改进与标准的兼容.</p>
</li>
<li><p>Server-side Render<br>服务端渲染技术是 2016 年才开始火的概念, 它与传统的后端渲染不同, 为了解决前端框架第一次加载慢的问题, 以及 SEO 问题, 而提出的解决方案. 之前有 prerender, 现在各大框架都在尝试在内部集成并支持它. 但我个人觉得, 带来的问题远比解决的问题更多, 比如要求我们开发的时候有更多的限制.</p>
</li>
<li><p>App Render<br>现在有一种大前端的概念, 可以理解为 web 前端对 App 开发的支持, 包括 Ionic ( 基于 AngularJS ), React Native( 基于 React 理念 ), Meteor 都是针对 App 开发的痛点而生.</p>
</li>
</ul>
<p>分析了众多目前最流行的前端框架, 大家可能越来越胡涂了:<br>到底谁才是最值得我们去投入的技术呢?<br>接下来, 我们去掉一堆术语, 来从前端的定义本质来看它的发展. </p>
<h3 id="近二年本质的演进是什么"><a href="#近二年本质的演进是什么" class="headerlink" title="近二年本质的演进是什么"></a>近二年本质的演进是什么</h3><p>前端就是面向用户这一端的技术, 然而, 随着时代的发展:</p>
<ul>
<li>用户体验要求越来越高( 加载速度快, 响应快, 无闪烁 )</li>
<li>前端需求越来越多</li>
<li>前端代码越来越庞大</li>
<li>移动端快速发展对 h5 前端的需求</li>
</ul>
<p>而 jQuery, ProtoypeJS 等只解决了 Javascript 工具库的问题, 但工程化需求无好的解决方案.<br>前端工程化迫在眉捷. 而且有以下要求:   </p>
<ul>
<li>最好是纯 Javascript 方案</li>
<li>支持模块化</li>
<li>业务代码与框架代码分离</li>
<li>可测性</li>
</ul>
<p>于是, 产生了几种不同的演进方案.<br>后端渲染技术:<br>ajax -&gt; pjax -&gt; sjr ( 需要服务端提供支持 )<br>后端渲染技术很快就发展到顶了. 但技术理解还是足够简单的. 我们还是回到前端框架上.<br>NodeJS, AMD(CMD), ES6 的出现, 使得组织起一个前端框架成为现实. 于是乎, 百团大战, 出现了上面众多框架混战的画面.<br>无论是 AngularJS, EmberJS, ReactJS, VueJS 都是围绕着这几点进行的不同的尝试.<br>但结果如何, 我们站在一个更高的高度重新思考 web 开发.      </p>
<h3 id="真正的用户市场需要什么"><a href="#真正的用户市场需要什么" class="headerlink" title="真正的用户市场需要什么"></a>真正的用户市场需要什么</h3><p>对用户   </p>
<ul>
<li>更快的响应速度</li>
<li>更好的体验<br>对开发者</li>
<li>更快的开发速度</li>
<li>更好的可维护性</li>
</ul>
<p>再次思考, 我们要不要前后端分离? 哪些前端框架更满足我们以上的条件?<br>作为 Rails 工程师, 我也一直在思考一个问题: Rails 是否在前端上走上了绝路?<br>对于不熟悉 Rails 的朋友, 我还是简单回顾下 Rails 的前端是什么:</p>
<ul>
<li>jQuery</li>
<li>UJS</li>
<li>Assets pipeline</li>
<li>SJR( 服务端 JS 生成技术 )</li>
<li>Turoblinks( 一种极小成本实现的单页效果的技术 )</li>
</ul>
<p>相比 php, java, python 等语言下的传统 web 框架来说, Rails 的前端技术还是非常丰富的.<br>关于各个框架我列了一个分数比较, 10 分为满分, 每个列会加在一起算成一个总分.<br> <img src="http://7xth8v.com2.z0.glb.qiniucdn.com/image/n-web-score-2016.jpeg" alt=""></p>
<p>从上表可以看出:<br>Rails 这类的全栈框架特点有</p>
<p>优势:</p>
<ul>
<li>开发效率极高</li>
<li>通过 Turoblinks 技术, 体验也不错.</li>
<li>也能支持混合应用开发</li>
</ul>
<p>缺点:</p>
<ul>
<li>前端代码可维护差</li>
</ul>
<p>ReactJS 学习成本较低, 通过 webpack 与 npm 的配合, 能够达到不错的可维护性, 但开发成本偏高, 这也是组件化的缺点之一.<br>而 EmberJS 学习门槛过高, 而且 EmberJS 发展也比较迅速, 不利于学习掌握, 相对而言, 总分也不会太高.<br>MeteorJS 也被我列在这里, 总分最低, 所以仍然不推荐学习, 除非你的应用属于实时应用.<br>我们再重新思考组件化, 组件化优势在于接口清晰, 可维护性高, 但开发成本是比较高的, 前端属于工程而不是科学, 所以, 我觉得组件化是对的, 但不要过于极端把所有的 dom 都组件化.<br>而且, 组件化也对现有的基础技术栈进行了破坏.<br>通过以上的分析, 我们基本上了解了现有技术栈的情况. 那我们该继续学什么? 这才是本文的重点.<br>所有的一切, 都是围绕着组件化, 可维护, 高效开发, 移动支持而生, 而它们的核心都是还是最基础的东西:     </p>
<ul>
<li>Javascript ( ES6, NodeJS )</li>
<li>HTML</li>
<li>CSS</li>
<li>API<br>一句话, 还是应该先把基础打好.</li>
</ul>
<h3 id="基础技术栈"><a href="#基础技术栈" class="headerlink" title="基础技术栈"></a>基础技术栈</h3><p>应当好好掌握的内容:</p>
<ul>
<li>Javascript 语言( 直接看 ES6 相关的 )</li>
<li>NodeJS 生态( npm 与相关的包 )</li>
<li>webpack ( 了解如何打包, 发布 )</li>
<li>HTML ( 尤其是 form 标签, 以及 HTML5 的内容 )</li>
<li>CSS ( 学习盒模型, 最新的 flex 布局, 以及 CSS3 )</li>
<li>API ( 掌握如何开发 API )</li>
</ul>
<p>你必须是前端工程师, 同时又是后端工程师, 才能真正摸清晰当下时代的发展, 成为弄潮儿!</p>
<h3 id="预测未来"><a href="#预测未来" class="headerlink" title="预测未来"></a>预测未来</h3><p>首先, 我在 2014 年分析 web 开发的文中提到的 gulp, grunt 都已经成为过去式了. Bower 也已经有点不合事宜了.<br>目前前端构建建议使用 webpack 和 npm 足够, 不需要更多的工具链, 应该越简单, 越顺手!<br>列几个关心的问题尝试预测一下.</p>
<ul>
<li><p>NodeJS 做后台开发怎么样 ?<br>NodeJS 已经是前端框架的一部分, 是极为成功的, 但对于 NodeJS 做后台开发说实在的, 它能够占一定的市场, 但将会非常少( 低于 5% ). 所以做 php 或 java 开发的朋友倒不用担心, 但如果只是搬砖写简单 API 的话, 就有危险了.</p>
</li>
<li><p>Rails 还行不行 ?<br>Rails 已经到了一定的顶点, 不可能再突破性增长, 但仍然是目前最为顺手的 web 开发框架, 它的前端解决方案目前仍有不错的体验与开发效率, 但可维护性比较差, 如果是我的话, 我会带领团队采用混合式的开发, 但现在不会是引入 AngularJS 而会是 VueJS.<br>但 Rails 已经到达它的极限点了, 而众多前端框架才刚刚开始.( 虽然拿 Rails 与前端框架比较不够合适 )    </p>
</li>
<li><p>AngularJS 还是 ReactJS ?<br>很简单, 建议直接上手 VueJS.<br>AnguarJS 第一版是个好的框架, 但 Angular2 并不是, 所以还不如直接学习 VueJS.<br>ReactJS 是个不错的框架, 但绝不是终点. VueJS 与 ReactJS 在实现上各有利弊. 两者可以择其一学之.</p>
</li>
<li><p>MeteorJS 值不值得学习 ?<br>我的建议是不值得, 因为它一开始就走在错误的道路上, 注定后面无路可走.</p>
</li>
<li><p>前端会取代 Native APP 开发么?<br>一定会的, 未来 3 年后, 至少有 70% 左右的 APP 会用前端开发方案, 比如使用类似于 Ionic 或 Meteor 这样的框架.</p>
</li>
</ul>
<h3 id="重新思考-web-开发"><a href="#重新思考-web-开发" class="headerlink" title="重新思考 web 开发"></a>重新思考 web 开发</h3><p>真正能长远的前端技术一定是简单的, 专注的, 比如 jQuery. 但目前几个框架都或多或少存在着问题.<br>ReactJS 不是表面那么简单, 而 AngularJS 更加复杂.<br>是否有更简单有效的解决它们的问题, 则能够成为下一代 web 前端框架.    </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-git-常用命令汇总" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/03/git-常用命令汇总/" class="article-date">
  	<time datetime="2016-06-03T06:26:42.000Z" itemprop="datePublished">2016-06-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/03/git-常用命令汇总/">git 常用命令汇总</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>创建账户：</p>
<pre><code class="language-git">git config -global user.name &quot;Your name&quot;
git config -global user.email &quot;you@example.com&quot;
</code></pre>
<p>从仓库克隆到提交文件通用流程：</p>
<pre><code class="language-git"> git clone git@github.com:mmrxia/project-name.git
 git add .
 git commit -m &#39;update file&#39;
 git push -u origin master
</code></pre>
<p>查看当前git仓库文件状态：</p>
<pre><code class="language-git">git status
</code></pre>
<h3 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h3><ul>
<li>新建.gitignore文件</li>
</ul>
<pre><code class="language-git">touch .gitignore
</code></pre>
<ul>
<li>查看文件</li>
</ul>
<pre><code class="language-git">vim README.md
</code></pre>
<ul>
<li>查看提交历史记录</li>
</ul>
<pre><code class="language-git">git log
</code></pre>
<p>我们常用 <code>-p</code> 选项展开显示每次提交的内容差异，用 <code>-2</code> 则仅显示最近的两次更新。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/bash/">bash</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/">git</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-nodejs实践知识点汇总" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/03/nodejs实践知识点汇总/" class="article-date">
  	<time datetime="2016-06-03T02:21:03.000Z" itemprop="datePublished">2016-06-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/03/nodejs实践知识点汇总/">nodejs实践知识点汇总</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>1 . <strong>npm -v、node -v</strong>： 查看npm或nodejs版本。示例：</p>
<pre><code class="language-git">npm -v
</code></pre>
<p>2 . <strong>npm init</strong>： 会在当前目录引导创建一个package.json文件，包括名称、版本、作者这些信息等。示例：</p>
<pre><code class="language-git">npm init
</code></pre>
<p>3 . <strong>npm install</strong>： 根据package.json文件自动安装需要的模块。示例：</p>
<pre><code class="language-git">npm install
</code></pre>
<p>–save 命令，安装模块时，写入到package.json的依赖字段（dependencies）中。<br>使用<code>--save-dev</code>命令，可写入到开发依赖字段（devDependencies）中。<br>示例：</p>
<pre><code class="language-git">npm install express --save
</code></pre>
<p>-g 将包安装到全局环境中，如：</p>
<pre><code class="language-git">npm install express -g
</code></pre>
<p>4 . <strong>npm uninstall <name></name></strong>： 卸载node模块</p>
<p>5 . <strong>npm update <name></name></strong>： 更新node模块</p>
<p>6 . 其他</p>
<ul>
<li>npm root：查看当前包的安装路径</li>
<li>npm root -g：查看全局的包的安装路径</li>
<li>npm outdated：检查包是否已经过时，此命令会列出所有已经过时的包，可以及时进行包的更新</li>
<li>npm list：查看当前目录下已安装的node包</li>
<li>npm help：查看帮助命令</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nodejs/">nodejs</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-图片等比压缩居中显示" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/02/图片等比压缩居中显示/" class="article-date">
  	<time datetime="2016-06-02T08:16:21.000Z" itemprop="datePublished">2016-06-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/02/图片等比压缩居中显示/">图片等比压缩居中显示</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>html中的img标签元素，在元素容器中保证等比压缩居中显示。不能拉伸变形，尽量做成jQuery插件的调用方式。</p>
<h3 id="调用方式："><a href="#调用方式：" class="headerlink" title="调用方式："></a>调用方式：</h3><p>HTML:</p>
<pre><code class="language-html">&lt;div class=&quot;img-wrapper&quot;&gt;
    &lt;img class=&quot;img&quot; src=&quot;image/tmp_01.jpg&quot; alt=&quot;demo1&quot;/&gt;
&lt;/div&gt;
&lt;div class=&quot;img-wrapper&quot;&gt;
    &lt;img class=&quot;img&quot; src=&quot;image/tmp_02.jpg&quot; alt=&quot;demo2&quot;/&gt;
&lt;/div&gt;
&lt;div class=&quot;img-wrapper&quot;&gt;
    &lt;img class=&quot;img&quot; src=&quot;image/tmp_03.png&quot; alt=&quot;demo3&quot;/&gt;
&lt;/div&gt;
&lt;div class=&quot;img-wrapper&quot;&gt;
    &lt;img class=&quot;img&quot; src=&quot;image/tmp_04.png&quot; alt=&quot;demo4&quot;/&gt;
&lt;/div&gt;
</code></pre>
<p>CSS:</p>
<pre><code class="language-css">.img-wrapper{border: 1px dashed #2F9DC2;height: 100px;overflow: hidden;}
</code></pre>
<p>JS:</p>
<pre><code class="language-javascript">&lt;script src=&quot;../../static/js/lib/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;img-ratio-compress.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    $(&#39;.img&#39;).ratioCompress({resize:true});
&lt;/script&gt;
</code></pre>
<h3 id="效果如下："><a href="#效果如下：" class="headerlink" title="效果如下："></a>效果如下：</h3><p><img src="http://7xth8v.com2.z0.glb.qiniucdn.com/image/n_img_radio_commpress.png" alt=""></p>
<h3 id="示例演示："><a href="#示例演示：" class="headerlink" title="示例演示："></a>示例演示：</h3><p>大家可以点开页面查看图片源文件，查看图片尺寸。<br>demo中设置了随窗口变化图片位置自适应，可以缩放浏览器尺寸或者F12调整为移动端模式查看。</p>
<p><a href="https://rawgit.com/mmrxia/lab/master/examples/img-radio-compress/index.html" target="_blank" rel="external">点我查看示例</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-js-数组复制操作" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/22/js-数组复制操作/" class="article-date">
  	<time datetime="2016-05-22T03:31:55.000Z" itemprop="datePublished">2016-05-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/22/js-数组复制操作/">js 数组复制操作</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>js中数组和对象，使用“=”号赋值的时候，由于是引用类型，只是改变了引用对象的指针指向，改变值时会引起连锁反应。<br>简单效果如下：<br><img src="http://7xth8v.com2.z0.glb.qiniucdn.com/image/arr1.png" alt=""></p>
<p>避免指针指向的方法主要有一下几种：<br>（1）使用slice()方法。slice() 函数可从已有的数组中返回选定的元素；语法为：arr.slice(start,end);<br>slice()函数将会返回一个新的数组对象，所以使用slice(0)或slice()就可以实现数组的复制。如下：<br><img src="http://7xth8v.com2.z0.glb.qiniucdn.com/image/arr2.png" alt=""></p>
<p>（2）使用concat()方法。语法为：arr.concat(arr1,arr2,arr3,…,arrn);<br>concat()用于多个数组的合并，但是返回的结果是一个新的数组，而不再引用用于合并的任何一个数组。如下：<br><img src="http://7xth8v.com2.z0.glb.qiniucdn.com/image/arr3.png" alt=""></p>
<p>（3）笨方法：使用for循环；原理就不说了，直接上代码：<br><img src="http://7xth8v.com2.z0.glb.qiniucdn.com/image/arr4.png" alt=""></p>
<p>（4）使用jQuery的extend或merge方法：<br>$.extend 功能很强大，可以合并数组，对象！具体可参见jQuery api。<br><img src="http://7xth8v.com2.z0.glb.qiniucdn.com/image/arr5.png" alt=""></p>
<p>$.merge 只能合并一维数组，且一次只能合并2个，个人觉得没有concat方法强大。<br><img src="http://7xth8v.com2.z0.glb.qiniucdn.com/image/arr6.png" alt=""></p>
<p>其他参考：</p>
<ol>
<li><a href="http://www.html-js.com/article/1589" target="_blank" rel="external">javascript 原始类型和引用类型</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数组/">数组</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-真假美猴王死的到底是谁" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/17/真假美猴王死的到底是谁/" class="article-date">
  	<time datetime="2016-05-17T07:18:14.000Z" itemprop="datePublished">2016-05-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/17/真假美猴王死的到底是谁/">真假美猴王死的到底是谁</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>看《西游记》第五十七回，说是“六耳猕猴”化作孙悟空的摸样，伤了唐僧，后又和孙悟空大打出手。。。这位假孙悟空，实力不用多说了吧，和真孙悟空一般无二，大战孙悟空，闹到上天入地下海。在唐僧那：念紧箍咒，两个都喊疼，自然看不出哪个真假；到天宫：拖塔天王拿照妖镜照，也看不出；又到观音那：观音也看不出。最后到幽冥处阎罗那，经“谛听”听过之后，“谛听”却说：“我看出来了，却不敢说”。。。最后还是如来老佛爷道出六耳真身并用金钵盂罩住，才被孙悟空一棍子打死。</p>
<p>这是整个故事，看似很简单，很完整，不过，却有一个天大的伏笔。<br>咱现在先假设一下，被打死的那个是悟空，活的那个是六耳猕猴。我这不是胡说的，是有道理的，一下是我的一些理论：</p>
<p>一、六耳猕猴和孙悟空一模一样，谁也看不出来，就算如来骗大家说六耳猕猴就是真的悟空，而这个谎言，也只有如来知道真相，真正的孙悟空，他只是个哑巴吃黄连。</p>
<p>二、六耳猕猴很有可能是如来安排的一个托儿，大家都知道，孙悟空是个叛逆者，而如来是西天的最高统治者，哪个统治者会允许一个叛逆者生活在这个世界上？再加上，大家都知道的，孙悟空一向不敬重如来。所以如来会想方设法消灭孙悟空。当然不能明白着把孙悟空直接杀了，所以才出现一个一模一样的悟空，杀孙悟空于无形。而这个也是有证据的。</p>
<p>1：比如在地府里面，经“谛听”听过之后，“谛听”明知道真假，却不敢说，其想法肯定不是怕两个悟空大闹地府，而是这个六耳猕猴有很强大的后台，那就是如来。所以，“谛听”自然不敢说出真相。<br>2：其次，可以证明“谛听”不是真正的怕二猴大闹地府的原因还有一个，大家都知道，当时在场的还有一个法力很强的人，当然，不是阎罗，阎罗和这人比，是天壤之别，这人就是“地藏王菩萨”，“地藏王菩萨”何许人啊，是佛教四大菩萨之首，与观音、文殊、普贤齐名，可见此人厉害。既然有这么厉害的佛门中人在此，难道“谛听”还担心这两泼猴会闹了地府不成？</p>
<p>三、大家都知道，孙悟空的师傅是“菩提祖师”，“菩提祖师”何许人？《封神榜》上有个线索，就是“混鲲祖师”的徒弟，而恰巧，“混鲲祖师”弟子无数，而让他最得意的两大弟子，便是如来(又名“接引道人“）和菩提祖师(又名“准提道人“）。。。<br>一个大胆的想法，既然两位圣人是同门师兄，且《封神榜》中曾经略提到过，说二弟子准提道人（也就是说菩提祖师），其间不知与接引道人（如来）间发生了什么变故，却神秘消失，从此再不闻踪迹。这是一个很有力度的线索，证明二人之间有矛盾。<br>然后再回到孙悟空，而孙悟空又恰巧是菩提祖师的徒弟，如来见到昔日仇人的徒弟，又有翻天覆地之本领，不想方设法除之更待何时？</p>
<p>四、西游记上讲述了孙悟空在菩提祖师处学了一身法术之后神通广大。而恰巧，和冒充孙悟空的六耳猕猴却也拥有和孙悟空一模一样的法术，甚至连长相声音装的都完全一样？这是巧合吗？大家都知道孙悟空只学个72变和筋斗云都学了几年，六耳猕猴不可能不学就天生就有这本领吧？肯定有和孙悟空同门出处的高人指点，自然菩提祖师不会在此之列，因为老人家既然有了孙悟空这样有情有义的徒弟，难道还要在造出一个六耳猕猴来和孙悟空对着干吗？所以，指点六耳猕猴来和孙悟空对着干的只有一个人，那就是菩提祖师的同门师兄，如来。</p>
<p>五、再回到《西游记》第五十八回，话说，二猴打闹到如来这里要如来辩个真假。。。如来却对众佛说：“我观假悟空乃六耳猕猴也。此猴若立一处，能知千里外之事，凡人说话，亦能知之，故此善聆音，能察理，知前后，万物皆明。与真悟空同象同音者，六耳猕猴也”。<br>经如来这么一说，众佛知道了，原来天下众生中还有这么一个叫“六耳猕猴”，而西游记的读者们却忽略了如来的这一句话里的一个线索：如来说的意思是，此猴和孙悟空不同，孙悟空是“灵明石猴”，同变化，识天时，知地利，移星换斗。而六耳猕猴是“知前后，万物皆明”。很厉害吧，竟然知道过去和未来发生的一切事。这是一个很大的破绽！！！既然六耳猕猴知道他的未来将要被如来制服，被孙悟空一棒打死，他为什么还要和孙悟空到如来处辩真假，那不是自讨苦吃吗？所以只有一个可能，如来早都把事情安排的妥当，在他的说明下，让众佛都以为六耳猕猴就是“真悟空”，而真正的悟空，却被当成了“六耳猕猴”被如来制服，然后被一棒打死。<br>而当“六耳猕猴”被打死之后，一向慈悲为怀的如来却没一点怪罪之意，只是合并双手，道了句：“善哉，善哉！”。。。大家都知道，以如来的本领，当“孙悟空”想要一棒子打死“六耳猕猴”的话，如来想要出手相救，是何等的容易，可见，如来本意就是想让他死。而“六耳猕猴”本无太大的罪过，也就是和孙悟空大闹了下，一向慈悲的如来何必要让他死呢，想当年孙悟空闹了龙宫，闹了地府，闹了天宫，如来都还没让他死呢，怎么“六耳猕猴”这么一个小小的错误就要必须死呢？这里面肯定有隐情。所以那个隐情就是，如来是真正想处死的是孙悟空，而被一棒子打死的，却恰好是真正的孙悟空。</p>
<p>六、大家会以为，孙悟空不是已经被生死薄删除了名字，又吃了那么多蟠桃和仙丹，早都可以长生不老，也有了金刚不坏之躯，怎么能这么容易就给打死了呢。这个也许就只有如来自己知道了，大家可以想象，如来既然当年有能力把孙悟空压打五行山，现在虽然杀不了孙悟空，当然也肯定有办法让孙悟空永远消失的活着。</p>
<p>七、又回到孙悟空的师傅“菩提祖师”这。西游记里曾经记载，孙悟空在大闹天宫之后，惹了一大堆麻烦只好跟着唐僧西天取经，遇到困难又回去找他师傅“菩提祖师”的时候，“菩提祖师”早已不见踪影，只是和孙悟空隔空说话，并不见面。这是为什么呢？想必孙悟空用“菩提祖师”所教的本领大闹天宫之后，如来必有察觉，肯定会发现此七十二变和筋斗云正是同门法术。刚才我也说过了，菩提祖师和如来曾经因为一些矛盾，后来菩提祖师隐居了。如果如来看到孙悟空的本领后，肯定便知此本领肯定是菩提祖师所受，自然要追寻这个消失已久的仇人。所以，菩提祖师得知孙悟空大闹天宫之后，为防止不必要的麻烦，也已经消失的无影无踪。。。<br>而话又说回来了，菩提祖师本领并不亚于如来，这个可以从《西游记》第八回看出。。。其中有一段，如来说：“我西牛贺洲者，不贪不杀，养气潜灵，虽无上真，人人固寿”。大家注意了，如来说，“西牛贺州，虽无上真”，这恰恰说明，菩提在西牛贺洲传道能逃过如来法眼，说明菩提不比如来差。 </p>
<p>八、大家发现没，在真假美猴王事出之前，孙悟空并不完全都听唐僧的话，甚至有时候，还闹个小矛盾，导致唐僧只好念紧箍咒，典型的一个叛逆者形象。可自从真假美猴王事出之后，孙悟空从此保护唐僧安安分分。而以此事可以看出，孙悟空前后可判若两人。不排除，孙悟空已被如来利用六耳猕猴一战中，安安静静、无人知晓的已被安排下台了。</p>
<hr>
<p>其实还有另外一个版本，且待我慢慢道来：</p>
<p>六耳猕猴是西游记中最奇特的一个妖怪，怎么奇特呢？我们来看一看：</p>
<h3 id="一、人物奇特"><a href="#一、人物奇特" class="headerlink" title="一、人物奇特"></a>一、人物奇特</h3><p>西游记主要是看孙悟空的戏，六耳猕猴这个妖怪居然敢冒充主角孙悟空，上演了一出《真假美猴王》的好戏。<br>按妖怪的胆量、能力与勇气大致可以分为三种：<br>1.怕孙悟空的妖怪根本不敢冒充孙悟空。<br>2.不把孙悟空放在眼里的妖怪根本不屑于冒充孙悟空。<br>3.和孙悟空势均力敌的妖怪，手段也颇高了，完全没有必要冒充孙悟空。<br>六耳猕猴这个妖怪的本事和孙悟空是一样的，他完全有能力独霸一方，干吗还要冒充孙悟空呢？因此，六耳猕猴冒充孙悟空，就显得格外的奇特。</p>
<h3 id="二、地点奇特"><a href="#二、地点奇特" class="headerlink" title="二、地点奇特"></a>二、地点奇特</h3><p>唐僧遇到六耳猕猴的地方，是强盗出没的山林，这里至少有三十几个以上的强盗在此地谋生活，这就说明这个山头是属于强盗的，按说不会有妖怪，若有妖怪，则强盗们根本无法生存，更不可能结成团伙，形成气候，早被妖怪吃了。<br>可见，六耳猕猴这个妖怪并不是本地妖怪，那他是从哪儿来的？<br>西游记中的妖怪无论法力大小，都有一块属于自己的地盘，厉害的妖怪管的宽一些，不厉害的妖怪地盘小点，怎么说，得有一片生存的土壤，否则，他是成不了妖的。<br>六耳猕猴呢？他有没有自己的地盘呢？有，在花果山，乘孙悟空不在的时候，他跑到花果山占山为王了，并且没有被其他的猴子们发觉。<br>可见，六耳猕猴对孙悟空的行踪及过去的经历了如指掌。</p>
<h3 id="三、行为奇特"><a href="#三、行为奇特" class="headerlink" title="三、行为奇特"></a>三、行为奇特</h3><p>妖怪们都有很强烈的领地感，只在自己控制的势力范围内吃人，基本上吃的都是你自己瞎了眼睛送上门来的，或是采用手段把你诱骗去的，一般不会越界行凶。许多妖怪都说过“若过了此地就不归我管”这类的话。<br>妖怪与妖怪之间是和谐的，没有争斗，偶尔还有聚会，我抓到一个人请你吃，你抓到一个人请我吃，大家都遵守江湖道义。不到别处去撒野，不到别人的门面上去抢生意。<br>而六耳猕猴，则不管这一套，他是从花果山不远万里赶来作案的！这个行为实在是太奇特了，这是其他妖怪所没有的。</p>
<h3 id="四、手段奇特"><a href="#四、手段奇特" class="headerlink" title="四、手段奇特"></a>四、手段奇特</h3><p>六耳猕猴作案的手段更是怪异，他不像别的妖怪那样躲在半空中，瞅准机会一阵风把唐僧掳走。<br>而是跪在路旁，双手捧着一杯水给唐僧喝，唐僧不喝，骂了他一顿，六耳猕猴就轮铁棒望长老脊背上砑了一下，那长老昏晕在地，不能言语，被他把两个青毡包袱，提在手中，驾筋斗云，不知去向。<br>六耳猕猴并没有抓唐僧，而是把唐僧打了一顿，然后抢了包裹行李，扬长而去的。没有一个妖怪是像他这样搞的。</p>
<h3 id="五、动机奇特"><a href="#五、动机奇特" class="headerlink" title="五、动机奇特"></a>五、动机奇特</h3><p>六耳猕猴作案的动机，也和其他妖怪不同，妖怪抓唐僧，无非是要吃唐僧肉，或是要交配，而六耳猕猴则是要自己拉一班人马去西天取经！<br>六耳猕猴高坐在石台之上，双手扯着通关文牒，念了从头又念，反复学习。他说：“我今熟读了牒文，我自己上西方拜佛求经，送上东土，我独成功，教那南赡部洲人立我为祖，万代传名也。”<br>六耳猕猴不仅冒充了孙悟空，还找了几个猴精冒充了唐三藏、猪八戒、沙僧和一匹白马，企图上西天，成佛做祖！这个妖怪简直太有创意了！</p>
<h3 id="六、过程奇特"><a href="#六、过程奇特" class="headerlink" title="六、过程奇特"></a>六、过程奇特</h3><p>六耳猕猴和孙悟空不仅外型一模一样，本事也是一模一样，走到哪儿，都无法分辨谁是真的谁是假的！<br>1.观音菩萨暗念《紧箍儿咒》，两个一齐喊疼，菩萨无计奈何。<br>2.李天王取照妖镜照住，镜中乃是两个孙悟空，毫发不差。玉帝亦辨不出。<br>3.唐僧念《紧箍儿咒》，二人一齐叫苦，唐僧也不认得真假。<br>4.阎罗殿的谛听可以分辨的出真假，却不敢说出来。<br>5.最后被如来佛辨出真假，是所有神仙都没有听说过的新物种：六耳猕猴。<br>6.六耳猕猴被孙悟空当场处决，打死了。</p>
<p>以上种种疑点，实在太多，这里面就存在无法解释的问题：<br>1.既然阎罗殿的谛听可以分辨的出真假，却为什么不敢说出来？六耳猕猴与孙悟空的本事是一样大的，只要谛听说出哪个是假的，随便加几个人就可以帮孙悟空抓住六耳猕猴，谛听为什么不说？他怕什么？<br>2.既然六耳猕猴熟悉孙悟空的一切，当然就应该十分清楚如来佛祖是非常厉害的，他为什么不跑呢？还要到雷音寺去送死？这不是脑子进了水么？！<br>3.六耳猕猴只不过打了唐僧，既没有打死，也没有要吃唐僧肉，最多论个行凶抢劫罪，怎么说，罪不致死，为什么就把他打死了？！量刑是否过重？<br>4.六耳猕猴的目的是要取经，又是主动的，目标一致，如来佛应该高兴才对，这样的人才哪里找啊？把他也安排进取经的队伍，岂不是更好？<br>5.为什么只有如来佛一个人知道世上还存在“六耳猕猴”这一类物种？而所有的神仙包括菩萨都是闻所未闻的？难道就没一个人知道吗？<br>6.如果所有人都不知道有“六耳猕猴”这一类物种，那么，如来佛祖与六耳猕猴之间，究竟存在着怎样的渊源呢？</p>
<p>六耳猕猴的下场太惨了，这个和孙悟空一样的上进青年，就这么突然之间死于非命了，可怜，可惜。<br>但是，这件事情的真相，真的就是这样简单么？其中究竟隐藏着怎样的内幕？<br>真假美猴王这一回，不知道欺骗了多少观众，死的到底是谁，先来分析分析。<br>其实呢，这一回中根本就没有妖怪，那个所谓的六耳猕猴并不存在。从头到尾都是孙悟空一个人捣的鬼！大家看西游记把大脑都看的僵化了，总以为孙悟空是捉妖怪的，却怎么都想不到：孙悟空也会冒充妖怪，把唐僧这个泼秃领导暴打一顿以泻私愤吧！</p>
<p>孙悟空在这件事的起先，他是个受害者，而结果，却变成了最大的受益者，因此，孙悟空是第一嫌疑人。我们再来重新看这一幕：</p>
<h3 id="一、起因"><a href="#一、起因" class="headerlink" title="一、起因"></a>一、起因</h3><p>孙悟空打死了两个强盗，唐僧念经超度强盗的亡灵：拜惟好汉，我以好话，尔等不听，却遭行者，棍下伤身。你到森罗殿下兴词，他姓孙，我姓陈，各居异姓。冤有头，债有主，切莫告我取经僧人。<br>八戒笑道：“师父推了干净，他打时却也没有我们两个。”三藏又祷告道：“好汉告状，只告行者，也不干八戒、沙僧之事。”<br>孙悟空道：“师父，你老人家忒没情义。虽是我动手打，却也只是为你。你不往西天取经，我不与你做徒弟，怎么会来这里打杀人！”然后骂道：“触恼了我的性子，将你打死了，尽你到那里去告，我老孙是不怕，玉帝认得我，天王随得我；二十八宿惧我，九曜星官怕我；十代阎君曾与我为仆从，五路猖神曾与我当后生；三界五司，十方诸宰，都与我情深面熟，随你那里去告！”<br>这绝对是在恐吓唐僧，把老子惹火了，连你也打死，你去告吧！<br>三藏见他说出这般恶话，心惊肉跳道：“徒弟呀，你怎么就认真起来？”<br>晚上，在老杨家借宿，老杨的儿子是强盗一伙，孙悟空又打死了二三十个强盗，还把老杨儿子的头割下来，拧给唐僧看。<br>唐僧大惊，念起《紧箍儿咒》，把个行者勒得耳红面赤，眼胀头昏，在地下打滚，翻筋斗，竖蜻蜓，疼痛难禁。把大圣咒倒在地，箍儿陷在肉里有一寸来深浅。并威胁道：“快走！迟了些儿，我又念真言，这番决不住口，把你脑浆都勒出来哩！”<br>这是唐僧第三次赶孙悟空滚蛋。西天路走了一大半了，眼看就要出成果了，他要他滚蛋！<br>大圣疼痛难忍，忽然省悟道：“这和尚负了我心。”<br>于是，孙悟空发怒了，终于撕破脸皮反了目：你这泼秃！没了俺老孙，连口水都没得喝，还这般刁难俺，不给点颜色看看，你就不知道俺老孙的狠气！我管你是哪个！一棒子将唐僧打晕在地，扬长而去。丢下了这样一句话：“你这个狠心的泼秃，十分贱我！”</p>
<h3 id="二、经过"><a href="#二、经过" class="headerlink" title="二、经过"></a>二、经过</h3><p>沙僧来找他算帐，他说没有，绝对没有的事，俺老孙怎会干这样的缺德事呢，你若不信，菩萨可以作证嘛，我这几天一直都在这儿。<br>沙僧当然不信，因为你会架筋斗云，又会分身法。于是，菩萨叫沙僧与悟空同去见个真假。结果，沙僧看到了两个一模一样的孙悟空，长相、声音、本领都是一样的。这些条件是妖怪有可能具备的，可是，最重要的证据金箍棒、紧箍咒也是一样的，而这两个条件是妖怪不可能具备的。这就说明根本没有假的，这明摆着是孙悟空使的分身法嘛！<br>孙悟空上天庭借照妖镜，鉴定结果：两个都是真的。玉帝当然辨不出哪个假。“这大圣呵呵冷笑，那行者也哈哈欢喜”，就说明他正在暗自得意：嘿嘿！你们谁都想不到吧！<br>到阎罗殿去查，谛听是知道真相的，却不敢当面说破，否则，孙悟空不打死他才怪，发起恶来，把阎罗殿都拆了！<br>孙悟空走到哪儿都问的理直气壮：“你们看我两个谁是假的！”都辨不出，因为根本没有假的。他的目的就是要闹得让天、地、神、人、鬼尽知，不是俺老孙打的你这泼秃，而是你这泼秃缺了俺老孙就会碰到妖怪。</p>
<h3 id="三、结果"><a href="#三、结果" class="headerlink" title="三、结果"></a>三、结果</h3><p>最后闹到雷音寺，孙悟空与如来佛说的话，和在前面别处说的是有区别的，他先说这一路上我这般辛苦，不知费了多少精神，师父却把我赶出来。现在，请佛祖与<em>**</em>辨明邪正，我才好保唐僧过来把佛经取回东土，帮你永传大教。<br>注意：他说的是辨明邪正，不是辨明真假，而在前面别处他都是说的辨个真假。这个区别是相当大的，真假，是指两个人谁真谁假，邪正，是问我的行为对不对，请如来公断。<br>孙悟空这点分身术的小把戏，又岂能瞒得过如来佛？！在他还没来之前，如来佛就已经对大众说了：“汝等俱是一心，且看他二心斗来。”你们这些人呀，一心要看他谁真谁假，又岂能识破他的二心呢？根本就不是两个人，是二心也，孙猴子生了二心，把老师都打了！你们却以为是妖怪。<br>但是，这能说吗？一说破，就无法收场了，这个经就彻底的取不成了！如来的计划就破产了！所以，大局为重，如来佛也不能说破，不但不能说，反而还要很默契地配合他假戏真做！所以如来才杜撰出一个谁也没听说、没见过、根本就不存在的六耳猕猴来。<br>原著中这样写道：如来正欲道破，忽见…，如来笑道：我观假悟空乃六耳猕猴也。<br>孙悟空没想到如来佛会瞎扯，很是震惊，不知道如来要干什么，如来也没有辨真假，而是直接吓唬猴子：“悟空休动，待我与你擒住他。”悟空生怕被抓住把柄，急变蜂儿飞跑。大众不知，以为走了。如来笑云：“汝等休要再言，妖精未走，在我钵盂之下。”将钵盂揭起，果见一六耳猕猴。<br>孙大圣忍不住，将其打死。“忍不住”这三字用的好啊，悟空的心理素质到底比不上如来佛祖。佛法无边的如来总算帮神通广大的悟空把这个弥天大谎撒团圆了，皆大欢喜。<br>大圣叩头谢道：“上告如来：那师父若不要我，却不又枉劳一番神思！还是放我还俗去罢。”如来道：“你休乱想，切莫放刁，我教观音送你，不怕他不收。好生保护他去，那时功成归极乐，汝亦坐莲台。”<br>经过这一场闹剧，孙悟空明确的被如来内定为预备佛员，这是对他敢打师父的一种肯定，一种奖励！唐僧呢，这个刁酸无能的泼秃领导吃了哑巴亏，白挨了一顿揍。这种人欠揍，揍他一顿，他自然就老实了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/西游记/">西游记</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-西天取经路上只有一个妖怪" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/14/西天取经路上只有一个妖怪/" class="article-date">
  	<time datetime="2016-05-14T01:26:48.000Z" itemprop="datePublished">2016-05-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/14/西天取经路上只有一个妖怪/">西天取经路上只有一个妖怪</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="白骨精是谁？"><a href="#白骨精是谁？" class="headerlink" title="白骨精是谁？"></a><strong>白骨精是谁？</strong></h3><p>白骨精是白虎岭上一具女尸的骨架，受天地精华后，变成的妖精。西游记里并没有记载这具女尸到底是什么来历。在明末清初的一些民间小说和故事书中零星有些记载，大致是，白骨精原本是白虎岭上一户普通人家的女儿。长到十七八岁的时候，被当地富户强行掠走。遭到淫虐后，被遗弃荒山，冻饿而死。</p>
<p>她死的时候恰好是农历七月十五，是天地阴阳相合的日子，所以冤魂没能上天入地，而是在人间游荡。虽是游荡，但一直不肯离开自己的尸体，直至尸体化为白骨。姑娘的游魂吸取天地精华，围绕白骨，化为人形，从此对人恨之入骨，以吸人血为生。由于修炼的年岁太少，她只有一般的变化法力，属于妖界微不足道的小角色。</p>
<p>妖是什么？其实是天上神仙的奴隶。所有修炼到一定果位的神仙，都会到妖界选一个坐骑，能成为神仙坐骑，是所有妖精最快的上升通道。修炼很苦，只有成为神仙才能上升到贵族阶层，从此不再遭受妖界的痛苦与磨砺。白骨精之所以会选择唐僧下手，是因为她无论如何修炼，都没有机会做神仙。</p>
<p>你想，哪位神仙会选一堆白骨作坐骑啊？每次神仙来妖界选坐骑，她都会去应聘，但每次都失败。她已经放弃了通过当坐骑上升的门道，而是选择走捷径。当听说吃了唐僧肉便可长生不老，成为神仙时，她毫不犹豫地盯上了唐僧师徒。尽管她知道自己不是孙悟空的对手，但还是选择下手。因为，她已经无路可走。</p>
<h3 id="唐僧是谁？"><a href="#唐僧是谁？" class="headerlink" title="唐僧是谁？"></a><strong>唐僧是谁？</strong></h3><p>为什么白骨精遇到唐僧师徒会有那么强烈的戏剧性？我们先来看下这帮取经人是什么身份。先看唐僧，其实他是如来二弟子金蝉长老转世。他去人间转世投胎的理由很简单——轻慢佛法，被如来打入凡尘。如来真的对他很失望吗？其实没有。他刚被打入凡尘后，如来就后悔了。但是，作为佛界的一把手，他也不能出尔反尔啊。</p>
<p>如来心里的小九九早被观音菩萨看到了。喜欢察言观色的观音菩萨以宣传佛法为理由，启动了取经工程。这么大的机会，无论给谁都能成佛，获得果位。观音菩萨去人间辛苦选角回来，告诉如来，除了如来朝思暮想的金蝉长老转世的陈玄奘外，没有人能完成这项工程。如来一听很高兴，就让观音菩萨操办去了。</p>
<p>作为取经形象工程的总策划，观音菩萨办事非常周密。她先找来各路菩萨和神仙，希望大家都能为这项工程出点力。尤其是应该让自家的坐骑妖怪都出来捣捣乱，也显示下取经的难度，同时也在关键时刻露露脸，让如来知道，大家都一心向着中央，一直在帮助金蝉长老过关。各路菩萨走后，观音菩萨找到陈玄奘，告诉他，妖怪都是自家人放出来的，为了显示取经的难度，让如来重用他，也算是好有个台阶下。</p>
<p>唐僧很聪明，一心想回灵山，所以当然愿意了。不过，所有的事情都没那么简单。天上也有人事关系，天上也有潜规则。观音菩萨张罗了一个这么好的取经工程，谁参与谁都会功成名就，那肯定一帮人惦记着。同时，观音菩萨自己也不会放过这次机会啊。所以他选择的第一个参与项目的人就是孙悟空。</p>
<h3 id="孙悟空那些事"><a href="#孙悟空那些事" class="headerlink" title="孙悟空那些事"></a><strong>孙悟空那些事</strong></h3><p>不要以为观音菩萨选孙悟空是因为他能打能杀，可以保唐僧去取经。其实与这些一点毛关系都没有。孙悟空是谁？其实他是菩提老祖的私生子。小时候，他只可以看到菩提老祖，却看不到妈妈，就很好奇问老祖，他是哪儿来的。菩提老祖告诉他，他是石头缝里变出来的。一向傻乐呵的孙悟空快1千岁的时候才知道自己的真实身世。</p>
<p>菩提老祖的这个秘密只有观音菩萨知道。观音菩萨为什么会帮菩提老祖保守秘密呢？是因为菩提老祖太牛逼了。他是谁？他是成佛比如来还早的佛陀。由于如来的佛法更高深，年龄与佛龄都高于如来的菩提老祖，甘愿成为如来的追随者。如来让菩提老祖三分，一直另眼相看。菩提老祖在佛教中是须菩提，他与佛祖的对话便是《金刚经》。</p>
<p>实际上，菩提老祖是儒释道精通的神仙，法力高于如来，但又遵从如来。菩提老祖就孙悟空一个儿子，所以一直很娇惯他。他私下教会了孙悟空很多法力，并禁止孙悟空叫他师傅，也不允许他在任何场合提到自己。孙悟空与菩提老祖闹翻，跑了出去。菩提老祖怕他惹事，便把孙悟空托付给观音菩萨管教。</p>
<p>观音菩萨哪管得了他，他兴风作浪，干了很多坏事。尤其是把玉皇大帝都给揍了。如来本来要灭了他，结果观音菩萨暗示他不要这样做，如来领会，就把孙悟空压到五行山下五百年。菩提老祖与如来都是大牛，观音菩萨谁都不敢得罪，所以她一直等待机会救出孙悟空，给菩提老祖一个交代。</p>
<p>这不，唐僧取经的工程资金都批下来了，没什么比随唐僧取经更合适的项目了。一来让如来有台阶下，二来也是给菩提老祖一个面子，算是完成了托付的重任。一开始，唐僧非常讨厌孙悟空，绝对不想和他合作。唐僧心里清楚，所有的妖怪都是观音菩萨阿姨找来的托儿，一旦孙猴子胡乱打，岂不是全给得罪了。</p>
<h3 id="其他的关系户"><a href="#其他的关系户" class="headerlink" title="其他的关系户"></a><strong>其他的关系户</strong></h3><p>不要以为唐僧、悟空外的几个人就清白了。猪八戒是天蓬元帅，掌管天河，所谓天河不过是银河罢了。也就是说，猪八戒是银河系的一把手。实际上他是紫薇大帝手上最亮的一颗星——北斗七星中最亮的一颗。紫薇大帝的坐骑是北斗七星，而猪八戒是最亮的一颗。他被贬下界是因为他把嫦娥给睡了。很多人不知道，玉帝把嫦娥带到天庭原本想娶他为妃，无奈王母娘娘很不高兴，发动自家亲戚的力量，差点毁了玉帝的统治。</p>
<p>让嫦娥当舞女是玉帝与王母相互妥协的结果。玉帝每天看嫦娥跳舞，却睡不得，这让他很扫兴。嫦娥在广寒宫整天思春，郁闷不乐。猪八戒跑过去陪她聊天，并成功把嫦娥给睡了。这件事让玉帝火冒三丈，于是把猪八戒贬入凡尘。自己最喜欢的坐骑没了，紫薇大帝很不高兴，猪八戒是他最喜欢的坐骑。然而，如来扫平魔界，建立佛国世界时，紫薇大帝一直是所有光明的提供者，照亮如来的路，如来一直无以为报。观音菩萨于是找到凡间流浪的猪八戒，将他编入了取经队伍，算是对紫薇大帝一个交代。</p>
<p>沙和尚是谁？他是卷帘大将，但真实的身份是玉皇大帝四女儿四仙女的相好。玉帝知道他与女儿相好后，便以打碎了某某东东为由，将他打入凡尘。王母支持四女儿，反抗玉帝，让玉帝很后悔自己的决定。当观音菩萨刚宣布要组织取经工程时，王母娘娘就知道了这件事。为了自己女儿的幸福，她拿一箩筐蟠桃，让观音菩萨把沙悟净也编入了取经队伍。</p>
<p>小白龙更不用说了。他是西海龙王的三太子，因为纵火烧了玉帝赏赐的明珠而被判斩首。结果观音菩萨求情，免于一死，被压在了山涧里。你可能会奇怪，观音菩萨为什么会为小白龙说情。其实是这样的，观音菩萨又叫南海观音，她常驻的地方在南海。南海是南海龙王的地盘，也就是小白龙叔叔的地盘。</p>
<p>三太子很小时的时候经常去观音菩萨那里玩，观音菩萨很喜欢他，视若己出。他犯事后，把他压在山涧里加以保护也是观音菩萨的主意。取经工程刚出来消息，西海龙王、南海龙王、东海龙王、北海龙王全都齐聚南海，求观音帮忙。把小白龙安排进来也是顺理成章的事情。</p>
<h3 id="为什么不能降妖？"><a href="#为什么不能降妖？" class="headerlink" title="为什么不能降妖？"></a><strong>为什么不能降妖？</strong></h3><p>唐僧师徒几个，唯有唐僧心里最清楚，路上根本没有什么妖怪，都是自己人当托的。所以吗，见到妖怪不要随便打，一不小心就打到自己的亲戚了。再说，观音菩萨一直背后跟着，真实遇到了妖怪猛兽，观音会保证安全的。</p>
<p>孙悟空等四个却不知道妖怪的真实身份，再加上他们本来就很暴烈，一上路就烧杀抢掠。为了限制孙悟空，唐僧再三要求观音菩萨要驯服他。菩萨选了折衷的办法，给他戴上了紧箍。尽管如此，孙悟空依然野性不改。打白骨精是唐僧与孙悟空矛盾的最高点。</p>
<p>白骨精是唐僧取经路上唯一一个真妖怪，她目标明确，就是要吃唐僧肉，成为神仙，逃离魔界的痛苦。白骨精被打死后，唐僧吓死了。如果这个白骨精是某个菩萨手上的人或坐骑，那他的取经工程就有可能被叫停。所以他第一时间念了紧箍咒，把孙猴子赶走了。</p>
<p>观音菩萨去请孙猴子回来，没跟他说实话，但点拨了他，告诉他，只要发现妖怪，去菩萨们那里问问就好了。孙悟空得到点拨后学精了，一旦遇到妖怪，并不好好打，而是先跑到天上打听一番，是谁家的，谁来管管。结果，一路上很顺利，几乎没遇到任何真正的危险便到了灵山，取了真经。</p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a><strong>结尾</strong></h3><p>看了上面的分析你是否有种无奈的感觉？<br>白骨精的故事是中国流传数百年的悲剧——屌丝向上爬的道路永远是不通的；没有背景和身份是没法做大事的；一切形象工程都有同样的逻辑。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/西游记/">西游记</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-js浮点数计算精度丢失问题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/11/js浮点数计算精度丢失问题/" class="article-date">
  	<time datetime="2016-05-11T09:22:45.000Z" itemprop="datePublished">2016-05-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/11/js浮点数计算精度丢失问题/">js浮点数计算精度丢失问题及解决方案</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 本文主要从以下3个方面来说明：</p>
<p> 1 . js浮点数计算精度丢失常见现象<br> 2 . js浮点数计算精度丢失原因<br> 3 . js浮点数计算精度丢失解决办法</p>
<h3 id="一、常见现象"><a href="#一、常见现象" class="headerlink" title="一、常见现象"></a>一、常见现象</h3><p> 1 . 两个简单的浮点数相加或相乘</p>
<pre><code> 0.1 + 0.2 != 0.3 // true  0.30000000000000004
</code></pre><p> 又如：</p>
<pre><code> 0.29 * 100  // 28.999999999999996
</code></pre><p> 2 . 大整数运算</p>
<pre><code> 9999999999999999 == 10000000000000001 // true  16位和17位数竟然相等...
</code></pre><p> 又如：</p>
<pre><code> var x = 9007199254740992
 x + 1 == x // true
</code></pre><h3 id="二、原因"><a href="#二、原因" class="headerlink" title="二、原因"></a>二、原因</h3><p> <strong>计算机的二进制实现和位数限制有些数无法有限表示。</strong><br> 就像一些无理数不能有限表示，如 圆周率 3.1415926…，1.3333… 等。JS 遵循 <a href="https://en.wikipedia.org/wiki/IEEE_floating_point" target="_blank" rel="external">IEEE 754</a> 规范，采用双精度存储（double precision），占用 64 bit。如图：<br> <img src="http://7xth8v.com2.z0.glb.clouddn.com/image/n_64bit.png?imageView2/2/w/800" alt=""></p>
<p> 图中的意义：</p>
<ul>
<li>1位用来表示符号位</li>
<li>11位用来表示指数</li>
<li>52位表示尾数</li>
</ul>
<p> 浮点数，比如</p>
<pre><code> 0.1 &gt;&gt; 0.0001 1001 1001 1001…（1001无限循环）
 0.2 &gt;&gt; 0.0011 0011 0011 0011…（0011无限循环）
</code></pre><p> 此时只能模仿十进制进行四舍五入了，但是二进制只有 0 和 1 两个，于是变为 0 舍 1 入。这即是计算机中部分浮点数运算时出现误差，丢失精度的根本原因。<br> 大整数的精度丢失和浮点数本质上是一样的，尾数位最大是 52 位，因此 JS 中能精准表示的最大整数是 <code>Math.pow(2, 53)</code>，十进制即 <code>9007199254740992</code>。<br> 大于 <code>9007199254740992</code> 的可能会丢失精度。</p>
<pre><code> 9007199254740992     &gt;&gt; 10000000000000...000 // 共计 53 个 0
 9007199254740992 + 1 &gt;&gt; 10000000000000...001 // 中间 52 个 0
 9007199254740992 + 2 &gt;&gt; 10000000000000...010 // 中间 51 个 0
</code></pre><p> 实际上</p>
<pre><code> 9007199254740992 + 1 // 丢失
 9007199254740992 + 2 // 未丢失
 9007199254740992 + 3 // 丢失
 9007199254740992 + 4 // 未丢失
</code></pre><p> 以上，可以知道看似有穷的数字, 在计算机的二进制表示里却是无穷的，由于存储位数限制因此存在“舍去”，精度丢失就发生了。</p>
<p> 想了解更深入的分析可以看这篇论文：<a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html" target="_blank" rel="external">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a></p>
<h3 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h3><p> 对于整数，前端出现问题的几率可能比较低，毕竟很少有业务需要需要用到超大整数，只要运算结果不超过 <code>Math.pow(2, 53)</code> 就不会丢失精度。<br> 对于小数，前端出现问题的几率还是很多的，尤其在一些电商网站涉及到金额等数据。解决方式：把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数），如下所示：</p>
<pre><code> // 0.1 + 0.2
 (0.1*10 + 0.2*10) / 10 == 0.3 // true
</code></pre><p> 代码实现如下：</p>
<pre><code class="language-javascript"> var Calc = function () {
     /*
      * 将浮点数去除小数点，返回整数和倍数。如 3.14 &gt;&gt; 314，倍数是 100
      * @param n {number} 浮点数
      * return {object}
      * {num: 314, times: 100}
      * */
     function toInt(n) {
         var n = +n, res = {num: n, times: 1};
         if (n !== (n | 0)) { //判断浮点数，n===parseInt(n)
             var arr = (&#39;&#39; + n).split(&#39;.&#39;);
             var len = arr[1].length; //小数长度
             res.times = Math.pow(10, len); //需要乘的倍数=&gt;10的指数
             res.num = Math.round(n * res.times); //四舍五入取整
         }
         return res;
     }

     function operation(a, b, op) {
         var result; //最终计算的值
         var o1 = toInt(a), o2 = toInt(b);

         var n1 = o1.num, t1 = o1.times;
         var n2 = o2.num, t2 = o2.times;

         var max = Math.max(t1, t2);

         switch (op) {
             case &#39;add&#39;:
                 if (t1 &gt; t2) {
                     result = n1 + n2 * (t1 / t2);
                 } else {
                     result = n2 + n1 * (t2 / t1);
                 }
                 result = result / max;
                 break;
             case &#39;subtract&#39;:
                 if (t1 &gt; t2) {
                     result = n1 - n2 * (t1 / t2);
                 } else {
                     result = n1 * (t2 / t1) - n2;
                 }
                 result = result / max;
                 break;
             case &#39;multiply&#39;:
                 result = (n1 * n2) / (t1 * t2);
                 return result;
                 break;
             case &#39;divide&#39;:
                 result = (n1 / n2) * (t2 / t1);
                 return result;
                 break;

         }
         return result;
     }

     /*加*/
     function add(a, b) {
         return operation(a, b, &#39;add&#39;);
     }

     /*减*/
     function subtract(a, b) {
         return operation(a, b, &#39;subtract&#39;);
     }

     /*乘*/
     function multiply(a, b) {
         return operation(a, b, &#39;multiply&#39;);
     }

     /*除*/
     function divide(a, b) {
         return operation(a, b, &#39;divide&#39;);
     }

     //exports
     return {
         add: add,
         subtract: subtract,
         multiply: multiply,
         divide: divide
     }
 }();
</code></pre>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p> <a href="http://0.30000000000000004.com" target="_blank" rel="external">http://0.30000000000000004.com</a><br> <a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html" target="_blank" rel="external">http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-跨域的几种方式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/09/跨域的几种方式/" class="article-date">
  	<time datetime="2016-05-09T07:37:30.000Z" itemprop="datePublished">2016-05-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/09/跨域的几种方式/">跨域的几种方式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>跨域，怎么处理跨域问题？无论是在面试中，还是在工作当中，总是会经常被问到，所以在这里总结下跨域的几种处理方式好了。</p>
</blockquote>
<h3 id="1-jsonp方式"><a href="#1-jsonp方式" class="headerlink" title="1 . jsonp方式"></a>1 . jsonp方式</h3><p>在js中，我们直接用<code>XMLHttpRequest</code>请求不同域上的数据是不可以的，而在html中，能够实现跨域的就几种：</p>
<ul>
<li>link属性（css）</li>
<li>href属性（a标签）</li>
<li>src（img标签、script标签）</li>
</ul>
<p>为了解决跨域的问题，结合script能够发起跨域请求的原理，产生了jsonp，即：动态的创建script标签，跨域的地址加上需要传送的数据和回调函数为script标签的src地址，执行完之后再动态的删除之前创建的script.</p>
<p>理解了原理之后，就很容易明白jsonp的缺点了：</p>
<ul>
<li>只能用get方式请求，因为是使用src来传送数据</li>
<li>数据中出现中文需要编码。因为通过url传参数，可以在浏览器输入地址并带上中文参数试试</li>
<li>src对请求的地址没有限制，会出现安全性的问题</li>
</ul>
<h3 id="2-document-domain"><a href="#2-document-domain" class="headerlink" title="2 . document.domain"></a>2 . document.domain</h3><p>看到这个跨域方式，可能有些同学会觉得陌生，其实这个也很常用。<br>每次遇到有需要使用登录之类的项目，在开发的时候都需要将地址改成163的域名，为啥？在控制台打印一下<code>document.domain</code>试试,这篇文章的控制台输出的是<code>feg.netease.com</code>，而在有使用到163登录的项目中，输出的都是<code>163.com</code>。登录组件限制在163域名下才能用，但是163的域名有很多，避免不同域名之间出现通信问题，使用<code>document.domain</code>的方式将页面的主域名改成了<code>163.com</code>。这种方式主要用在主域名能设置成相同的页面之间的通信。如<code>http://xyq.163.com/</code>，它的主域名可以是<code>xyq.163.com</code>或<code>163.com</code>；<code>http://xsd.163.com</code>，它的主域名可以是<code>xsd.163.com</code>或<code>163.com</code>，所以这两个站点下的页面能够将主域名设置成163.com。</p>
<h3 id="3-使用iframe"><a href="#3-使用iframe" class="headerlink" title="3 . 使用iframe"></a>3 . 使用iframe</h3><p>这种方式利用了window对象name属性的特征：在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</p>
<h3 id="4-Access-Control-Allow-Origin"><a href="#4-Access-Control-Allow-Origin" class="headerlink" title="4 . Access-Control-Allow-Origin"></a>4 . Access-Control-Allow-Origin</h3><p>正常情况下我们的接口都是jsonp的格式，可是万一遇到其它格式的接口怎么办？比如json格式，这个时候可以通过<code>Access-Control-Allow-Origin</code>来实现跨域。这种方式主要是后台同学配置，接口使用<code>Access-Control-Allow-Origin</code>设置对应项目的域名，前端同学这边像平常调用接口一样，不需要再做其他处理。如下面的例子：</p>
<pre><code class="language-javascript">   $.ajax({
       url: &quot;http://api.ypw.163.com/api/app&quot;,
       type: &quot;POST&quot;,
       data: JSON.stringify(postData),
       dataType: &quot;application/json&quot;,
       headers: {&quot;X-Ypw-Token&quot;: user_token, &quot;Content-Type&quot;: &quot;application/json&quot;},
       success: function(result) {
           renderPage(result);
       }
   });
</code></pre>
<p>data为需要传输的数据，dataType是接口的格式。比平常接口调用多了的headers部分，是这个接口考虑到安全性的问题，接口开发同学需要我添加一个key，并且把user_token用base64加密之后传输给他，并不是跨域需要设置的东西，即这种方式跟平常调用接口一样。<br>好像这种方式挺好用的。确实，可是最大的问题是ie7、8、9都还不支持，所以目前也就能用在移动端了。</p>
<h3 id="5-Chrome-–disable-web-security-快捷方式"><a href="#5-Chrome-–disable-web-security-快捷方式" class="headerlink" title="5 . Chrome –disable-web-security 快捷方式"></a>5 . Chrome –disable-web-security 快捷方式</h3><p>这种方式适用于Chrome浏览器，使浏览器支持跨域请求。在快捷方式的属性中配置<code>--args --disable-web-security --user-data-dir</code>参数，如图：</p>
<p><img src="http://7xth8v.com2.z0.glb.clouddn.com/image/n_chrome_prop.png" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/跨域/">跨域</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-git-常用命令速查表" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/09/git-常用命令速查表/" class="article-date">
  	<time datetime="2016-05-09T07:17:43.000Z" itemprop="datePublished">2016-05-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/09/git-常用命令速查表/">git 常用命令速查表</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>git作为代码管理工具的好处，这里就不多说了，目前也有很多git操作的可视化工具，如：TortoiseGit、SourceTree等。<br>相比可视化工具，笔者还是更喜欢使用原始命令来进行操作，下面附一张git常用命令速查表，以备不时之需。</p>
<p><img src="http://7xth8v.com2.z0.glb.qiniucdn.com/image/git_common_order.jpg" alt="git常用命令"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/">git</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 芥子园
    	</div>
      	<div class="footer-right">
      		Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>



<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-76943829-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
  <script src="http://7xth8v.com2.z0.glb.qiniucdn.com/js/prism.js"></script>
</body>
</html>