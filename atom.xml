<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>芥子园 | xiaqingsong&#39;s blog</title>
  <subtitle>须弥藏芥子，芥子纳须弥</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mmrxia.github.io/"/>
  <updated>2016-12-26T12:21:23.027Z</updated>
  <id>http://mmrxia.github.io/</id>
  
  <author>
    <name>芥子园</name>
    <email>this.xqs@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue学习笔记</title>
    <link href="http://mmrxia.github.io/2016/12/26/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://mmrxia.github.io/2016/12/26/vue学习笔记/</id>
    <published>2016-12-26T11:57:33.000Z</published>
    <updated>2016-12-26T12:21:23.027Z</updated>
    
    <content type="html">&lt;ul&gt;
&lt;li&gt;来自vue官方示例：&lt;a href=&quot;https://github.com/vuejs/vue-loader-example&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/vuejs/vue-loader-example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;使用vuejs和webpack，以及一系列webpack加载器，如vue-loader&lt;/li&gt;
&lt;li&gt;简单记录下具体的做法，供新手参考。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;- demo/
  + package.json //npm配置文件
  + webpack.config.js //webpack配置
  + index.html //页面
  - node_modules //npm加载的模块
  - src //开发资源目录
    - assets //一些资源
      + logo.png  //图片资源
    - components //vue组件
      + a.vue 
      + b.vue
      + counter.vue
    + app.vue //布局文件
    + main.js  //入口文件
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;初始化npm&quot;&gt;&lt;a href=&quot;#初始化npm&quot; class=&quot;headerlink&quot; title=&quot;初始化npm&quot;&gt;&lt;/a&gt;初始化npm&lt;/h2&gt;&lt;p&gt;1.生成npm配置文件 package.json&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm init
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.可以粘贴如下配置内容替换到package.json中，或者根据变动进行修改&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;demo_vue-loader-example&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;0.0.1&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;demo&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;index.js&amp;quot;,
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;dev&amp;quot;: &amp;quot;webpack-dev-server --inline --hot --quiet&amp;quot;, 
    &amp;quot;build&amp;quot;: &amp;quot;export NODE_ENV=production &amp;amp;&amp;amp; webpack --progress --hide-modules&amp;quot;
  },
  &amp;quot;author&amp;quot;: &amp;quot;dingyiming&amp;quot;,
  &amp;quot;license&amp;quot;: &amp;quot;MIT&amp;quot;,
  &amp;quot;devDependencies&amp;quot;: {
    &amp;quot;babel-core&amp;quot;: &amp;quot;^6.2.1&amp;quot;,
    &amp;quot;babel-loader&amp;quot;: &amp;quot;^6.2.0&amp;quot;,
    &amp;quot;babel-plugin-transform-runtime&amp;quot;: &amp;quot;^6.1.18&amp;quot;,
    &amp;quot;babel-preset-es2015&amp;quot;: &amp;quot;^6.1.18&amp;quot;,
    &amp;quot;babel-preset-stage-0&amp;quot;: &amp;quot;^6.1.18&amp;quot;,
    &amp;quot;babel-runtime&amp;quot;: &amp;quot;^6.2.0&amp;quot;,

    &amp;quot;css-loader&amp;quot;: &amp;quot;^0.23.0&amp;quot;,
    &amp;quot;node-sass&amp;quot;: &amp;quot;^3.4.2&amp;quot;,
    &amp;quot;sass-loader&amp;quot;: &amp;quot;^3.1.2&amp;quot;,
    &amp;quot;style-loader&amp;quot;: &amp;quot;^0.13.0&amp;quot;,
    &amp;quot;stylus-loader&amp;quot;: &amp;quot;^1.4.2&amp;quot;,

    &amp;quot;file-loader&amp;quot;: &amp;quot;^0.8.5&amp;quot;,
    &amp;quot;jade&amp;quot;: &amp;quot;^1.11.0&amp;quot;,
    &amp;quot;template-html-loader&amp;quot;: &amp;quot;0.0.3&amp;quot;,

    &amp;quot;vue-hot-reload-api&amp;quot;: &amp;quot;^1.2.1&amp;quot;,
    &amp;quot;vue-html-loader&amp;quot;: &amp;quot;^1.0.0&amp;quot;,
    &amp;quot;vue-loader&amp;quot;: &amp;quot;^7.1.4&amp;quot;,

    &amp;quot;webpack&amp;quot;: &amp;quot;^1.12.9&amp;quot;,
    &amp;quot;webpack-dev-server&amp;quot;: &amp;quot;^1.14.0&amp;quot;
  },
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;vue&amp;quot;: &amp;quot;^1.0.10&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.下载node模块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;也可以手动安装某个包，并写入到&lt;code&gt;package.json&lt;/code&gt;文字的依赖中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;–save-dev 把依赖名和版本要求放在了 “devDependencies”:{}，&lt;/li&gt;
&lt;li&gt;–save 放在了 “dependencies”:{}&lt;br&gt;每敲一个下载完后可以看到 “devDependencies”:{}依赖内容的添加&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;新建index-html用于展示最终页面&quot;&gt;&lt;a href=&quot;#新建index-html用于展示最终页面&quot; class=&quot;headerlink&quot; title=&quot;新建index.html用于展示最终页面&quot;&gt;&lt;/a&gt;新建index.html用于展示最终页面&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Vue Webpack Example&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;app&amp;gt;&amp;lt;/app&amp;gt;
&amp;lt;script src=&amp;quot;dist/build.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;新建webpack-config-js用于配置webpack&quot;&gt;&lt;a href=&quot;#新建webpack-config-js用于配置webpack&quot; class=&quot;headerlink&quot; title=&quot;新建webpack.config.js用于配置webpack&quot;&gt;&lt;/a&gt;新建webpack.config.js用于配置webpack&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var webpack = require(&amp;#39;webpack&amp;#39;)

module.exports = {
  entry: &amp;#39;./src/main.js&amp;#39;,
  output: {
    path: &amp;#39;./dist&amp;#39;,
    publicPath: &amp;#39;dist/&amp;#39;,
    filename: &amp;#39;build.js&amp;#39;
  },
  module: {
    loaders: [
      {
        test: /\.vue$/,
        loader: &amp;#39;vue&amp;#39;
      },
      {
        // edit this for additional asset file types
        test: /\.(png|jpg|gif)$/,
        loader: &amp;#39;file?name=[name].[ext]?[hash]&amp;#39;
      }
    ]
  },
  // example: if you wish to apply custom babel options
  // instead of using vue-loader&amp;#39;s default:
  babel: {
    presets: [&amp;#39;es2015&amp;#39;, &amp;#39;stage-0&amp;#39;],
    plugins: [&amp;#39;transform-runtime&amp;#39;]
  }
}

if (process.env.NODE_ENV === &amp;#39;production&amp;#39;) {
  module.exports.plugins = [
    new webpack.DefinePlugin({
      &amp;#39;process.env&amp;#39;: {
        NODE_ENV: &amp;#39;&amp;quot;production&amp;quot;&amp;#39;
      }
    }),
    new webpack.optimize.UglifyJsPlugin({
      compress: {
        warnings: false
      }
    }),
    new webpack.optimize.OccurenceOrderPlugin()
  ]
} else {
  module.exports.devtool = &amp;#39;#source-map&amp;#39;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;新建src目录用于存放开发文件&quot;&gt;&lt;a href=&quot;#新建src目录用于存放开发文件&quot; class=&quot;headerlink&quot; title=&quot;新建src目录用于存放开发文件&quot;&gt;&lt;/a&gt;新建src目录用于存放开发文件&lt;/h2&gt;&lt;h4 id=&quot;新建入口文件main-js&quot;&gt;&lt;a href=&quot;#新建入口文件main-js&quot; class=&quot;headerlink&quot; title=&quot;新建入口文件main.js&quot;&gt;&lt;/a&gt;新建入口文件main.js&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var Vue = require(&amp;#39;vue&amp;#39;)
var App = require(&amp;#39;./app.vue&amp;#39;)

new Vue({
  el: &amp;#39;body&amp;#39;,
  components: {
    app: App
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;新建组件布局文件app-vue&quot;&gt;&lt;a href=&quot;#新建组件布局文件app-vue&quot; class=&quot;headerlink&quot; title=&quot;新建组件布局文件app.vue&quot;&gt;&lt;/a&gt;新建组件布局文件&lt;code&gt;app.vue&lt;/code&gt;&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;组件布局将在这里设置，.vue文件将由vue-loader进行加载，.vue内同时包含html、css、js源码，使组件的独立，组件之间可以尽可能地解耦，便于开发维护&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template lang=&amp;quot;jade&amp;quot;&amp;gt;
div
  img(class=&amp;quot;logo&amp;quot;, src=&amp;quot;./assets/logo.png&amp;quot;)
  h1 {{msg}}
  comp-a
  comp-b
  counter
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import CompA from &amp;#39;./components/a.vue&amp;#39;
import CompB from &amp;#39;./components/b.vue&amp;#39;
import Counter from &amp;#39;./components/counter.vue&amp;#39;
export default {
  data () {
    return {
      msg: &amp;#39;Hello from vue-loader!&amp;#39;
    }
  },
  components: {
    CompA,
    CompB,
    Counter
  }
}
&amp;lt;/script&amp;gt;

&amp;lt;style lang=&amp;quot;stylus&amp;quot;&amp;gt;
font-stack = Helvetica, sans-serif
primary-color = #999
body
  font 100% font-stack
  color primary-color
.logo
  width 40px
  height 40px
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;新建components文件夹&quot;&gt;&lt;a href=&quot;#新建components文件夹&quot; class=&quot;headerlink&quot; title=&quot;新建components文件夹&quot;&gt;&lt;/a&gt;新建components文件夹&lt;/h4&gt;&lt;p&gt;用于开发具体的子组件，均以.vue的后缀呈现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a.vue&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;style scoped&amp;gt;
.container {
  border: 1px solid #00f;
}
.red {
  color: #f00;
}
&amp;lt;/style&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;h2 class=&amp;quot;red&amp;quot;&amp;gt;{{msg}}&amp;lt;/h2&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
  data () {
    return {
      msg: &amp;#39;Hello from Component A!&amp;#39;
    }
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;b.vue&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;style scoped&amp;gt;
.container {
  border: 1px solid #f00;
}
h2 {
  color: #393;
}
&amp;lt;/style&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;h2&amp;gt;Hello from Component B!&amp;lt;/h2&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;counter.vue&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;h1&amp;gt;I am a Counter Component. Edit me in dev mode.&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;Current count: {{count}}&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
  data () {
    return { count: 0 }
  },
  ready () {
    this.handle = setInterval(() =&amp;gt; {
      this.count++
    }, 1000)
  },
  destroyed () {
    clearInterval(this.handle)
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;新建assets文件夹用于放一些资源&quot;&gt;&lt;a href=&quot;#新建assets文件夹用于放一些资源&quot; class=&quot;headerlink&quot; title=&quot;新建assets文件夹用于放一些资源&quot;&gt;&lt;/a&gt;新建assets文件夹用于放一些资源&lt;/h4&gt;&lt;p&gt;此项目下有一张图 logo.png&lt;/p&gt;
&lt;h4 id=&quot;打包运行查看&quot;&gt;&lt;a href=&quot;#打包运行查看&quot; class=&quot;headerlink&quot; title=&quot;打包运行查看&quot;&gt;&lt;/a&gt;打包运行查看&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;打包运行查看&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;npm run build
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;运行&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;npm run dev
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;查看&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;浏览器中访问 localhost:8080&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;来自vue官方示例：&lt;a href=&quot;https://github.com/vuejs/vue-loader-example&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/vuejs/vue-loader-
    
    </summary>
    
    
      <category term="vue" scheme="http://mmrxia.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>javascript类型判断</title>
    <link href="http://mmrxia.github.io/2016/12/22/javascript%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
    <id>http://mmrxia.github.io/2016/12/22/javascript类型判断/</id>
    <published>2016-12-22T09:50:03.000Z</published>
    <updated>2016-12-22T10:03:06.841Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;JavaScript 中所有变量都是对象，除了两个例外 null 和 undefined。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;理解Javascript的类型是学习Javascript的基础，但是作为新手很容易在判断Javascript上容易混淆。很容易被上面这句话误导，首先解释下上面这句话。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;false.toString(); // &amp;#39;false&amp;#39;
[1, 2, 3].toString(); // &amp;#39;1,2,3&amp;#39;
(2).toString(); // &amp;#39;2&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过上面的代码，可以看出布尔、数组、数字都具有&lt;code&gt;toString()&lt;/code&gt;这一方法，其实除了&lt;code&gt;null&lt;/code&gt;和&lt;code&gt;undefined&lt;/code&gt;外的数据类型都继承自&lt;code&gt;Object&lt;/code&gt;对象都具&lt;code&gt;Object&lt;/code&gt;的方法和属性，这些看似非对象的类型使用起来却很像对象，所以也可以说它们都是对象。&lt;br&gt;可是Javascript依然具有类型，大致可以分成下面几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Number&lt;/li&gt;
&lt;li&gt;String&lt;/li&gt;
&lt;li&gt;Boolean&lt;/li&gt;
&lt;li&gt;Object&lt;/li&gt;
&lt;li&gt;Null&lt;/li&gt;
&lt;li&gt;Undefined&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Number&lt;/code&gt;、&lt;code&gt;String&lt;/code&gt;、&lt;code&gt;Boolean&lt;/code&gt;、&lt;code&gt;Null&lt;/code&gt;、&lt;code&gt;Undefined&lt;/code&gt;都是是基本数据类型，只有&lt;code&gt;Object&lt;/code&gt;属于复杂数据类型。&lt;br&gt;&lt;code&gt;Null&lt;/code&gt;和&lt;code&gt;Undefined&lt;/code&gt;都表示空，它们的区别在于：&lt;code&gt;Null&lt;/code&gt;表示无值，一般是人为的将变量的值设置为&lt;code&gt;null&lt;/code&gt;；&lt;code&gt;Undefined&lt;/code&gt;表示未知值，一般在使用&lt;code&gt;var&lt;/code&gt;声明变量但未对其加以初始化时，这个变量值为&lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Object&lt;/code&gt;又分为以下几种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function&lt;/li&gt;
&lt;li&gt;Array&lt;/li&gt;
&lt;li&gt;Date&lt;/li&gt;
&lt;li&gt;RegExp&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;typeof操作符&quot;&gt;&lt;a href=&quot;#typeof操作符&quot; class=&quot;headerlink&quot; title=&quot;typeof操作符&quot;&gt;&lt;/a&gt;typeof操作符&lt;/h4&gt;&lt;p&gt;&lt;code&gt;typeof&lt;/code&gt;操作符（和&lt;code&gt;instanceof&lt;/code&gt;一起）或许是 JavaScript 中最大的设计缺陷， 因为几乎不可能从它们那里得到想要的结果。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;typeof []; // object
typeof {}; // object
typeof &amp;#39;&amp;#39;; // string
typeof new Date() // object
typeof 1; // number
typeof function () {}; // function
typeof /test/i; // object
typeof true; // boolean
typeof null; // object
typeof undefined; // undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为什么？&lt;code&gt;function&lt;/code&gt;明明是&lt;code&gt;Object&lt;/code&gt;类型，却显示&lt;code&gt;function&lt;/code&gt;；&lt;code&gt;null&lt;/code&gt;明明是&lt;code&gt;Null&lt;/code&gt;类型，却显示&lt;code&gt;object&lt;/code&gt;。所以&lt;code&gt;typeof&lt;/code&gt;操作符对类型的判断是不靠谱的，除非类型在给定的范围且&lt;code&gt;typeof&lt;/code&gt;确实能够区分这些类型。&lt;/p&gt;
&lt;h4 id=&quot;类型的区分&quot;&gt;&lt;a href=&quot;#类型的区分&quot; class=&quot;headerlink&quot; title=&quot;类型的区分&quot;&gt;&lt;/a&gt;类型的区分&lt;/h4&gt;&lt;p&gt;Javascript标准标准文档给出了区分类型的办法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;Object.prototype.toString.call();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们来看看上面的方法输出结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;Object.prototype.toString.call([]); // [object Array]
Object.prototype.toString.call({}); // [object Object]
Object.prototype.toString.call(&amp;#39;&amp;#39;); // [object String]
Object.prototype.toString.call(new Date()); // [object Date]
Object.prototype.toString.call(1); // [object Number]
Object.prototype.toString.call(function () {}); // [object Function]
Object.prototype.toString.call(/test/i); // [object RegExp]
Object.prototype.toString.call(true); // [object Boolean]
Object.prototype.toString.call(null); // [object Null]
Object.prototype.toString.call(); // [object Undefined]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用上面判断类型的方法可以写个类库，此类库来自&lt;a href=&quot;//github.com/toddmotto/axis&quot;&gt;Axis.js&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;(function (root, factory) {
  // 判断是否使用了模块
  if (typeof define === &amp;#39;function&amp;#39; &amp;amp;&amp;amp; define.amd) {
    // 使用AMD模块
    define(factory);
  } else if (typeof exports === &amp;#39;object&amp;#39;) {
    // 使用CMD模块
    module.exports = factory;
  } else {
    // 没有使用模块，放在全局下
    root.axis = factory();
  }
})(this, function () {
  // 严格模式
  &amp;#39;use strict&amp;#39;;
  var exports = {};
  // 将字符串转为数组
  var types = &amp;#39;Array Object String Date RegExp Function Boolean Number Null Undefined&amp;#39;.split(&amp;#39; &amp;#39;);
  // 判断类型
  var type = function () {
    return Object.prototype.toString.call(this).slice(8, -1);
  };
  // 遍历types，为exports对象添加isArray、isObject...等方法
  for (var i = types.length; i--;) {
    exports[&amp;#39;is&amp;#39; + types[i]] = (function (self) {
      return function (elem) {
        // type.call(elem)将type方法里的this指针指向elem
        return type.call(elem) === self;
      };
    })(types[i]);
  }
  return exports;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用方法也很简单：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;axis.isArray([]); // true
axis.isObject({}); // true
axis.isString(&amp;#39;&amp;#39;); // true
axis.isDate(new Date()); // true
axis.isRegExp(/test/i); // true
axis.isFunction(function () {}); // true
axis.isBoolean(true); // true
axis.isNumber(1); // true
axis.isNull(null); // true
axis.isUndefined(); // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://toddmotto.com/understanding-javascript-types-and-reliable-type-checking/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://toddmotto.com/understanding-javascript-types-and-reliable-type-checking/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bonsaiden.github.io/JavaScript-Garden/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://bonsaiden.github.io/JavaScript-Garden/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;JavaScript 中所有变量都是对象，除了两个例外 null 和 undefined。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;理解Javascript的类型是学习Javascript的基础，但是作为新手很容易在判断Javascript上容易
    
    </summary>
    
    
      <category term="javascript" scheme="http://mmrxia.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>只用20行写一个javascript模板引擎</title>
    <link href="http://mmrxia.github.io/2016/12/22/%E5%8F%AA%E7%94%A820%E8%A1%8C%E5%86%99%E4%B8%80%E4%B8%AAjavascript%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    <id>http://mmrxia.github.io/2016/12/22/只用20行写一个javascript模板引擎/</id>
    <published>2016-12-22T07:18:12.000Z</published>
    <updated>2016-12-22T07:41:18.727Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;译文链接：&lt;a href=&quot;原文链接：JavaScript template engine in just 20 lines&quot;&gt;JavaScript template engine in just 20 lines&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最初我的想法是这样子的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var TemplateEngine = function(tpl, data) {
    // magic here ...
}
var template = &amp;#39;&amp;lt;p&amp;gt;Hello, my name is &amp;lt;%name%&amp;gt;. I\&amp;#39;m &amp;lt;%age%&amp;gt; years old.&amp;lt;/p&amp;gt;&amp;#39;;
console.log(TemplateEngine(template, {
    name: &amp;quot;Krasimir&amp;quot;,
    age: 29
}));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个简单的函数，输入是我们的模板以及数据对象，输出么估计你也很容易想到，像下面这样子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;lt;p&amp;gt;Hello, my name is Krasimir. I&amp;#39;m 29 years old.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中第一步要做的是寻找里面的模板参数，然后替换成传给引擎的具体数据。我决定使用正则表达式来完成这一步。不过正则不是我的强项，所以大家将就一下，如果有更好的正则也欢迎向我提出。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var re = /&amp;lt;%([^%&amp;gt;]+)?%&amp;gt;/g;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这句正则表达式会捕获所有以&lt;code&gt;&amp;lt;%&lt;/code&gt;开头，以&lt;code&gt;%&amp;gt;&lt;/code&gt;结尾的片段。末尾的参数&lt;code&gt;g&lt;/code&gt;（global）表示不只匹配一个，而是匹配所有符合的片段。&lt;br&gt;Javascript里面有很多种使用正则表达式的方法，我们需要的是根据正则表达式输出一个数组，包含所有的字符串，这正是&lt;code&gt;exec&lt;/code&gt;所做的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var re = /&amp;lt;%([^%&amp;gt;]+)?%&amp;gt;/g;
var match = re.exec(tpl);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们用&lt;code&gt;console.log&lt;/code&gt;把变量&lt;code&gt;match&lt;/code&gt;打印出来，我们会看见：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;[
    &amp;quot;&amp;lt;%name%&amp;gt;&amp;quot;,
    &amp;quot; name &amp;quot;, 
    index: 21,
    input: 
    &amp;quot;&amp;lt;p&amp;gt;Hello, my name is &amp;lt;%name%&amp;gt;. I\&amp;#39;m &amp;lt;%age%&amp;gt; years old.&amp;lt;/p&amp;gt;&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不过我们可以看见，返回的数组仅仅包含第一个匹配项。我们需要用&lt;code&gt;while&lt;/code&gt;循环把上述逻辑包起来，这样才能得到所有的匹配项。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var re = /&amp;lt;%([^%&amp;gt;]+)?%&amp;gt;/g;
while(match = re.exec(tpl)) {
    console.log(match);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果把上面的代码跑一遍，你就会看见&lt;code&gt;&amp;lt;%name%&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;%age%&amp;gt;&lt;/code&gt;都被打印出来了。&lt;/p&gt;
&lt;p&gt;下面，有意思的部分来了。识别出模板中的匹配项后，我们要把他们替换成传递给函数的实际数据。最简单的办法就是使用&lt;code&gt;replace&lt;/code&gt;函数。我们可以像这样来写：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var TemplateEngine = function(tpl, data) {
    var re = /&amp;lt;%([^%&amp;gt;]+)?%&amp;gt;/g;
    while(match = re.exec(tpl)) {
        tpl = tpl.replace(match[0], data[match[1]])
    }
    return tpl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;好了，这样就能跑了，但是还不够好。这里我们以&lt;code&gt;data[&amp;quot;property&amp;quot;]&lt;/code&gt;的方式使用了一个简单对象来传递数据，但是实际情况下我们很可能需要更复杂的嵌套对象。所以我们稍微修改了一下&lt;code&gt;data&lt;/code&gt;对象：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;{
    name: &amp;quot;Krasimir Tsonev&amp;quot;,
    profile: { age: 29 }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不过直接这样子写的话还不能跑，因为在模板中使用&lt;code&gt;&amp;lt;%profile.age%&amp;gt;&lt;/code&gt;的话，代码会被替换成&lt;code&gt;data[&amp;#39;profile.age&amp;#39;]&lt;/code&gt;，结果是&lt;code&gt;undefined&lt;/code&gt;。&lt;br&gt;这样我们就不能简单地用&lt;code&gt;replace&lt;/code&gt;函数，而是要用别的方法。如果能够在&lt;code&gt;&amp;lt;%&lt;/code&gt;和&lt;code&gt;%&amp;gt;&lt;/code&gt;之间直接使用Javascript代码就最好了，这样就能对传入的数据直接求值，像下面这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var template = &amp;#39;&amp;lt;p&amp;gt;Hello, my name is &amp;lt;%this.name%&amp;gt;. I\&amp;#39;m &amp;lt;%this.profile.age%&amp;gt; years old.&amp;lt;/p&amp;gt;&amp;#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你可能会好奇，这是怎么实现的？这里&lt;a href=&quot;http://ejohn.org/blog/javascript-micro-templating/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;John&lt;/a&gt;使用了&lt;code&gt;new Function&lt;/code&gt;的语法，根据字符串创建一个函数。我们不妨来看个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var fn = new Function(&amp;quot;arg&amp;quot;, &amp;quot;console.log(arg + 1);&amp;quot;);
fn(2); // outputs 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;fn&lt;/code&gt;可是一个货真价实的函数。它接受一个参数，函数体是&lt;code&gt;console.log(arg + 1)&lt;/code&gt;;。上述代码等价于下面的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var fn = function(arg) {
    console.log(arg + 1);
}
fn(2); // outputs 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过这种方法，我们可以根据字符串构造函数，包括它的参数和函数体。这不正是我们想要的嘛！不过先别急，在构造函数之前，我们先来看看函数体是什么样子的。&lt;br&gt;按照之前的想法，这个模板引擎最终返回的应该是一个编译好的模板。还是用之前的模板字符串作为例子，那么返回的内容应该类似于：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;return 
&amp;quot;&amp;lt;p&amp;gt;Hello, my name is &amp;quot; + 
this.name + 
&amp;quot;. I\&amp;#39;m &amp;quot; + 
this.profile.age + 
&amp;quot; years old.&amp;lt;/p&amp;gt;&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然啦，实际的模板引擎中，我们会把模板切分为小段的文本和有意义的Javascript代码。前面你可能看见我使用简单的字符串拼接来达到想要的效果，不过这并不是100%符合我们要求的做法。&lt;br&gt;由于使用者很可能会传递更加复杂的Javascript代码，所以我们这儿需要再来一个循环，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var template = 
&amp;#39;My skills:&amp;#39; + 
&amp;#39;&amp;lt;%for(var index in this.skills) {%&gt;&#39; + 
&#39;&lt;a href=&quot;&quot;&gt;&lt;%this.skills[index]%&gt;&lt;/%this.skills[index]%&gt;&lt;/a&gt;&#39; +
&#39;&lt;%}%&amp;gt;&amp;#39;; &lt;=&quot;&quot; code=&quot;&quot;&gt;&lt;/%}%&amp;gt;&amp;#39;;&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果使用字符串拼接的话，代码就应该是下面的样子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;return
&amp;#39;My skills:&amp;#39; + 
for(var index in this.skills) { +
&amp;#39;&amp;lt;a href=&amp;quot;&amp;quot;&amp;gt;&amp;#39; + 
this.skills[index] +
&amp;#39;&amp;lt;/a&amp;gt;&amp;#39; +
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，这个代码不能直接跑，跑了会出错。于是我用了&lt;a href=&quot;http://ejohn.org/blog/javascript-micro-templating/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;John的文章&lt;/a&gt;里写的逻辑，把所有的字符串放在一个数组里，在程序的最后把它们拼接起来。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var r = [];
r.push(&amp;#39;My skills:&amp;#39;); 
for(var index in this.skills) {
r.push(&amp;#39;&amp;lt;a href=&amp;quot;&amp;quot;&amp;gt;&amp;#39;);
r.push(this.skills[index]);
r.push(&amp;#39;&amp;lt;/a&amp;gt;&amp;#39;);
}
return r.join(&amp;#39;&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下一步就是收集模板里面不同的代码行，用于生成函数。通过前面介绍的方法，我们可以知道模板中有哪些占位符（译者注：或者说正则表达式的匹配项）以及它们的位置。&lt;br&gt;所以，依靠一个辅助变量（cursor，游标），我们就能得到想要的结果。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var TemplateEngine = function(tpl, data) {
    var re = /&amp;lt;%([^%&amp;gt;]+)?%&amp;gt;/g,
        code = &amp;#39;var r=[];\n&amp;#39;,
        cursor = 0;
    var add = function(line) {
        code += &amp;#39;r.push(&amp;quot;&amp;#39; + line.replace(/&amp;quot;/g, &amp;#39;\\&amp;quot;&amp;#39;) + &amp;#39;&amp;quot;);\n&amp;#39;;
    }
    while(match = re.exec(tpl)) {
        add(tpl.slice(cursor, match.index));
        add(match[1]);
        cursor = match.index + match[0].length;
    }
    add(tpl.substr(cursor, tpl.length - cursor));
    code += &amp;#39;return r.join(&amp;quot;&amp;quot;);&amp;#39;; // &amp;lt;-- return the result
    console.log(code);
    return tpl;
}
var template = &amp;#39;&amp;lt;p&amp;gt;Hello, my name is &amp;lt;%this.name%&amp;gt;. I\&amp;#39;m &amp;lt;%this.profile.age%&amp;gt; years old.&amp;lt;/p&amp;gt;&amp;#39;;
console.log(TemplateEngine(template, {
    name: &amp;quot;Krasimir Tsonev&amp;quot;,
    profile: { age: 29 }
}));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码中的变量code保存了函数体。开头的部分定义了一个数组。游标&lt;code&gt;cursor&lt;/code&gt;告诉我们当前解析到了模板中的哪个位置。我们需要依靠它来遍历整个模板字符串。&lt;br&gt;此外还有个函数&lt;code&gt;add&lt;/code&gt;，它负责把解析出来的代码行添加到变量&lt;code&gt;code&lt;/code&gt;中去。有一个地方需要特别注意，那就是需要把&lt;code&gt;code&lt;/code&gt;包含的双引号字符进行转义（escape）。否则生成的函数代码会出错。&lt;br&gt;如果我们运行上面的代码，我们会在控制台里面看见如下的内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var r=[];
r.push(&amp;quot;&amp;lt;p&amp;gt;Hello, my name is &amp;quot;);
r.push(&amp;quot;this.name&amp;quot;);
r.push(&amp;quot;. I&amp;#39;m &amp;quot;);
r.push(&amp;quot;this.profile.age&amp;quot;);
return r.join(&amp;quot;&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;等等，貌似不太对啊，&lt;code&gt;this.name&lt;/code&gt;和&lt;code&gt;this.profile.age&lt;/code&gt;不应该有引号啊，再来改改。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var add = function(line, js) {
    js? code += &amp;#39;r.push(&amp;#39; + line + &amp;#39;);\n&amp;#39; :
        code += &amp;#39;r.push(&amp;quot;&amp;#39; + line.replace(/&amp;quot;/g, &amp;#39;\\&amp;quot;&amp;#39;) + &amp;#39;&amp;quot;);\n&amp;#39;;
}
while(match = re.exec(tpl)) {
    add(tpl.slice(cursor, match.index));
    add(match[1], true); // &amp;lt;-- say that this is actually valid js
    cursor = match.index + match[0].length;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;占位符的内容和一个布尔值一起作为参数传给&lt;code&gt;add&lt;/code&gt;函数，用作区分。这样就能生成我们想要的函数体了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var r=[];
r.push(&amp;quot;&amp;lt;p&amp;gt;Hello, my name is &amp;quot;);
r.push(this.name);
r.push(&amp;quot;. I&amp;#39;m &amp;quot;);
r.push(this.profile.age);
return r.join(&amp;quot;&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;剩下来要做的就是创建函数并且执行它。因此，在模板引擎的最后，把原本返回模板字符串的语句替换成如下的内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;return new Function(code.replace(/[\r\t\n]/g, &amp;#39;&amp;#39;)).apply(data);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们甚至不需要显式地传参数给这个函数。我们使用&lt;code&gt;apply&lt;/code&gt;方法来调用它。它会自动设定函数执行的上下文。这就是为什么我们能在函数里面使用&lt;code&gt;this.name&lt;/code&gt;。这里&lt;code&gt;this&lt;/code&gt;指向&lt;code&gt;data&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;模板引擎接近完成了，不过还有一点，我们需要支持更多复杂的语句，比如条件判断和循环。我们接着上面的例子继续写。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var template = 
&amp;#39;My skills:&amp;#39; + 
&amp;#39;&amp;lt;%for(var index in this.skills) {%&gt;&#39; + 
&#39;&lt;a href=&quot;#&quot;&gt;&lt;%this.skills[index]%&gt;&lt;/%this.skills[index]%&gt;&lt;/a&gt;&#39; +
&#39;&lt;%}%&amp;gt;&amp;#39;; console.log(templateengine(template,=&quot;&quot; {=&quot;&quot; skills:=&quot;&quot; [&amp;quot;js&amp;quot;,=&quot;&quot; &amp;quot;html&amp;quot;,=&quot;&quot; &amp;quot;css&amp;quot;]=&quot;&quot; }));=&quot;&quot; &lt;=&quot;&quot; code=&quot;&quot;&gt;&lt;/%}%&amp;gt;&amp;#39;;&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里会产生一个异常，&lt;code&gt;Uncaught SyntaxError: Unexpected token for&lt;/code&gt;。如果我们调试一下，把&lt;code&gt;code&lt;/code&gt;变量打印出来，我们就能发现问题所在。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var r=[];
r.push(&amp;quot;My skills:&amp;quot;);
r.push(for(var index in this.skills) {);
r.push(&amp;quot;&amp;lt;a href=\&amp;quot;\&amp;quot;&amp;gt;&amp;quot;);
r.push(this.skills[index]);
r.push(&amp;quot;&amp;lt;/a&amp;gt;&amp;quot;);
r.push(});
r.push(&amp;quot;&amp;quot;);
return r.join(&amp;quot;&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;带有&lt;code&gt;for&lt;/code&gt;循环的那一行不应该被直接放到数组里面，而是应该作为脚本的一部分直接运行。所以我们在把内容添加到&lt;code&gt;code&lt;/code&gt;变量之前还要多做一个判断。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var re = /&amp;lt;%([^%&amp;gt;]+)?%&amp;gt;/g,
    reExp = /(^( )?(if|for|else|switch|case|break|{|}))(.*)?/g,
    code = &amp;#39;var r=[];\n&amp;#39;,
    cursor = 0;
var add = function(line, js) {
    js? code += line.match(reExp) ? line + &amp;#39;\n&amp;#39; : &amp;#39;r.push(&amp;#39; + line + &amp;#39;);\n&amp;#39; :
        code += &amp;#39;r.push(&amp;quot;&amp;#39; + line.replace(/&amp;quot;/g, &amp;#39;\\&amp;quot;&amp;#39;) + &amp;#39;&amp;quot;);\n&amp;#39;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我们新增加了一个正则表达式。它会判断代码中是否包含&lt;code&gt;if&lt;/code&gt;、&lt;code&gt;for&lt;/code&gt;、&lt;code&gt;else&lt;/code&gt;等等关键字。如果有的话就直接添加到脚本代码中去，否则就添加到数组中去。运行结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var r=[];
r.push(&amp;quot;My skills:&amp;quot;);
for(var index in this.skills) {
r.push(&amp;quot;&amp;lt;a href=\&amp;quot;#\&amp;quot;&amp;gt;&amp;quot;);
r.push(this.skills[index]);
r.push(&amp;quot;&amp;lt;/a&amp;gt;&amp;quot;);
}
r.push(&amp;quot;&amp;quot;);
return r.join(&amp;quot;&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，编译出来的结果也是对的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;My skills:&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;js&amp;lt;/a&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;html&amp;lt;/a&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;css&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后一个改进可以使我们的模板引擎更为强大。我们可以直接在模板中使用复杂逻辑，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var template = 
&amp;#39;My skills:&amp;#39; + 
&amp;#39;&amp;lt;%if(this.showSkills) {%&gt;&#39; +
    &#39;&lt;%for(var index=&quot;&quot; in=&quot;&quot; this.skills)=&quot;&quot; {%=&quot;&quot;&gt;&#39; + 
    &#39;&lt;a href=&quot;#&quot;&gt;&lt;%this.skills[index]%&gt;&lt;/%this.skills[index]%&gt;&lt;/a&gt;&#39; +
    &#39;&lt;%}%&amp;gt;&amp;#39; +=&quot;&quot; &amp;#39;&amp;lt;%}=&quot;&quot; else=&quot;&quot; {%=&quot;&quot;&gt;&#39; +
    &#39;&lt;p&gt;none&lt;/p&gt;&#39; +
&#39;&lt;%}%&amp;gt;&amp;#39;; console.log(templateengine(template,=&quot;&quot; {=&quot;&quot; skills:=&quot;&quot; [&amp;quot;js&amp;quot;,=&quot;&quot; &amp;quot;html&amp;quot;,=&quot;&quot; &amp;quot;css&amp;quot;],=&quot;&quot; showskills:=&quot;&quot; true=&quot;&quot; }));=&quot;&quot; &lt;=&quot;&quot; code=&quot;&quot;&gt;&lt;/%}%&amp;gt;&amp;#39;;&gt;&lt;/%}%&amp;gt;&amp;#39;&gt;&lt;/%for(var&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了上面说的改进，我还对代码本身做了些优化，最终版本如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var TemplateEngine = function(html, options) {
    var re = /&amp;lt;%([^%&amp;gt;]+)?%&amp;gt;/g, reExp = /(^( )?(if|for|else|switch|case|break|{|}))(.*)?/g, code = &amp;#39;var r=[];\n&amp;#39;, cursor = 0;
    var add = function(line, js) {
        js? (code += line.match(reExp) ? line + &amp;#39;\n&amp;#39; : &amp;#39;r.push(&amp;#39; + line + &amp;#39;);\n&amp;#39;) :
            (code += line != &amp;#39;&amp;#39; ? &amp;#39;r.push(&amp;quot;&amp;#39; + line.replace(/&amp;quot;/g, &amp;#39;\\&amp;quot;&amp;#39;) + &amp;#39;&amp;quot;);\n&amp;#39; : &amp;#39;&amp;#39;);
        return add;
    }
    while(match = re.exec(html)) {
        add(html.slice(cursor, match.index))(match[1], true);
        cursor = match.index + match[0].length;
    }
    add(html.substr(cursor, html.length - cursor));
    code += &amp;#39;return r.join(&amp;quot;&amp;quot;);&amp;#39;;
    return new Function(code.replace(/[\r\t\n]/g, &amp;#39;&amp;#39;)).apply(options);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码比我预想的还要少，只有区区15行！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;译文链接：&lt;a href=&quot;原文链接：JavaScript template engine in just 20 lines&quot;&gt;JavaScript template engine in just 20 lines&lt;/a&gt;&lt;/p&gt;
&lt;/blockq
    
    </summary>
    
    
      <category term="javascript" scheme="http://mmrxia.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>nodejs中间件connect</title>
    <link href="http://mmrxia.github.io/2016/12/19/nodejs%E4%B8%AD%E9%97%B4%E4%BB%B6connect/"/>
    <id>http://mmrxia.github.io/2016/12/19/nodejs中间件connect/</id>
    <published>2016-12-19T03:19:21.000Z</published>
    <updated>2016-12-19T03:28:04.497Z</updated>
    
    <content type="html">&lt;h4 id=&quot;什么是connect？&quot;&gt;&lt;a href=&quot;#什么是connect？&quot; class=&quot;headerlink&quot; title=&quot;什么是connect？&quot;&gt;&lt;/a&gt;什么是connect？&lt;/h4&gt;&lt;p&gt;Connect 是Node.js中的一个模块，可以用来创建中间件的一个框架，它自身已经包装了Node的HTTP模块的Server以及Server的req和res的对象。&lt;br&gt;它干的活其实就是处理请求，然后响应客户端或是让下一个中间件继续处理，它的原型是这个样子的:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function (req, res, next) {
  // 中间件
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当next回调函数被调用，中间件就完成工作并传递到下一个中间件，如果没其他中间件则进入到应用逻辑继续执行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;logger&lt;/code&gt;: 用户请求日志中间件&lt;br&gt;&lt;code&gt;csrf&lt;/code&gt;: 跨域请求伪造保护中间件&lt;br&gt;&lt;code&gt;compress&lt;/code&gt;: gzip压缩中间件&lt;br&gt;&lt;code&gt;basicAuth&lt;/code&gt;: basic认证中间件&lt;br&gt;&lt;code&gt;bodyParser&lt;/code&gt;: 请求内容解析中间件&lt;br&gt;&lt;code&gt;json&lt;/code&gt;: JSON解析中间件&lt;br&gt;&lt;code&gt;urlencoded&lt;/code&gt;: application/x-www-form-urlencode请求解析中间件&lt;br&gt;&lt;code&gt;multipart&lt;/code&gt;: multipart/form-data请求解析中间件&lt;br&gt;&lt;code&gt;timeout&lt;/code&gt;: 请求超时中间件&lt;br&gt;&lt;code&gt;cookieParser&lt;/code&gt;: cookie解析中间件&lt;br&gt;&lt;code&gt;session&lt;/code&gt;: 会话管理中间件&lt;br&gt;&lt;code&gt;cookieSession&lt;/code&gt;: 基于cookies的会话中间件&lt;br&gt;&lt;code&gt;methodOverride&lt;/code&gt;: HTTP伪造中间件&lt;br&gt;&lt;code&gt;reponseTime&lt;/code&gt;: 计算响应时间中间件&lt;br&gt;&lt;code&gt;staticCache&lt;/code&gt;: 缓存中间件&lt;br&gt;&lt;code&gt;static&lt;/code&gt;: 静态文件处理中间件&lt;br&gt;&lt;code&gt;directory&lt;/code&gt;: 目录列表中间件&lt;br&gt;&lt;code&gt;vhost&lt;/code&gt;: 虚拟二级域名映射中间件&lt;br&gt;&lt;code&gt;favicon&lt;/code&gt;: 网页图标中间件&lt;br&gt;&lt;code&gt;limit&lt;/code&gt;: 请求内容大小限制中间件&lt;br&gt;&lt;code&gt;query&lt;/code&gt;: URL解析中间件&lt;br&gt;&lt;code&gt;errorHadnler&lt;/code&gt;: 错误处理中间件&lt;/p&gt;
&lt;p&gt;参考: &lt;a href=&quot;http://blog.fens.me/nodejs-connect/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.fens.me/nodejs-connect/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是connect？&quot;&gt;&lt;a href=&quot;#什么是connect？&quot; class=&quot;headerlink&quot; title=&quot;什么是connect？&quot;&gt;&lt;/a&gt;什么是connect？&lt;/h4&gt;&lt;p&gt;Connect 是Node.js中的一个模块，可以用来创建中间件的一
    
    </summary>
    
    
      <category term="nodejs" scheme="http://mmrxia.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>mongoose学习笔记</title>
    <link href="http://mmrxia.github.io/2016/12/16/mongoose%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://mmrxia.github.io/2016/12/16/mongoose学习笔记/</id>
    <published>2016-12-16T08:54:48.000Z</published>
    <updated>2016-12-16T09:27:04.173Z</updated>
    
    <content type="html">&lt;h2 id=&quot;一、快速通道&quot;&gt;&lt;a href=&quot;#一、快速通道&quot; class=&quot;headerlink&quot; title=&quot;一、快速通道&quot;&gt;&lt;/a&gt;一、快速通道&lt;/h2&gt;&lt;h3 id=&quot;1-名词解释&quot;&gt;&lt;a href=&quot;#1-名词解释&quot; class=&quot;headerlink&quot; title=&quot;1. 名词解释&quot;&gt;&lt;/a&gt;1. 名词解释&lt;/h3&gt;&lt;p&gt;Schema（模式）: 一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力。&lt;br&gt;Model（模型）: 源于Schema生成的模型，具有抽象属性和行为的数据库操作对。&lt;br&gt;Entity（实体）: 源于Model创建的实体，操作可影响数据库。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;br&gt;  1 . 本学习文档采用严格命名方式来区别不同对象，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  var PersonSchema;   //Person的文本属性
  var PersonModel;    //Person的数据库模型
  var PersonEntity;   //Person实体
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;  2 . Schema –&amp;gt; Model，Model –&amp;gt; Entity。Model和Entity都可对数据库操作造成影响，但Model比Entity更具操作性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;2-准备工作&quot;&gt;&lt;a href=&quot;#2-准备工作&quot; class=&quot;headerlink&quot; title=&quot;2. 准备工作&quot;&gt;&lt;/a&gt;2. 准备工作&lt;/h3&gt;&lt;p&gt;1 . 首先你必须安装MongoDB和NodeJS&lt;br&gt;  mongodb安装可参考： &lt;a href=&quot;http://blog.xiaqingsong.com/2016/12/16/windows%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmongodb/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;windows下安装配置mongodb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2 . 在项目只能够创建一个数据库连接，如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var mongoose = require(&amp;#39;mongoose&amp;#39;);    //引用mongoose模块
var db = mongoose.createConnection(&amp;#39;localhost&amp;#39;,&amp;#39;test&amp;#39;); //创建一个数据库连接
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3 . 打开本机localhost的test数据库时，我们可以监测是否有异常&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;db.on(&amp;#39;error&amp;#39;,console.error.bind(console,&amp;#39;连接错误:&amp;#39;));
db.once(&amp;#39;open&amp;#39;,function(){
  //mongodb connected!
});
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;br&gt;  成功开启数据库后，就可以执行数据库相应操作，假设以下代码都在回调中处理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;4 . 定义一个Schema&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var PersonSchema = new mongoose.Schema({
  name:String   //定义一个属性name，类型为String
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5 . 将该Schema发布为Model&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var PersonModel = db.model(&amp;#39;Person&amp;#39;,PersonSchema);
//如果该Model已经发布，则可以直接通过名字索引到，如下：
//var PersonModel = db.model(&amp;#39;Person&amp;#39;);
//如果没有发布，上一段代码将会异常
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6 . 用Model创建Entity&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var personEntity = new PersonModel({name:&amp;#39;Krouky&amp;#39;});
//打印这个实体的名字看看
console.log(personEntity.name); //Krouky
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7 . 我们甚至可以为此Schema创建方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//为Schema模型追加speak方法
PersonSchema.methos.speak = function(){
  console.log(&amp;#39;我的名字叫&amp;#39;+this.name);
}
var PersonModel = db.model(&amp;#39;Person&amp;#39;,PersonSchema);
var personEntity = new PersonModel({name:&amp;#39;Krouky&amp;#39;});
personEntity.speak();//我的名字叫Krouky
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;8 . Entity是具有具体的数据库操作CRUD的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;personEntity.save();  //执行完成后，数据库就有该数据了
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;9 . 如果要执行查询，需要依赖Model，当然Entity也是可以做到的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;PersonModel.find(function(err,persons){
  //查询到的所有person
});
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;br&gt;  1 . 具体的如何配置Schema、Model以及Model和Entity的相关操作，我们会在后面进行&lt;br&gt;  2 . Model和Entity都有能影响数据库的操作，但仍有区别，后面我们也会做解释&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、快速通道&quot;&gt;&lt;a href=&quot;#一、快速通道&quot; class=&quot;headerlink&quot; title=&quot;一、快速通道&quot;&gt;&lt;/a&gt;一、快速通道&lt;/h2&gt;&lt;h3 id=&quot;1-名词解释&quot;&gt;&lt;a href=&quot;#1-名词解释&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
    
      <category term="mongodb" scheme="http://mmrxia.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>windows下安装配置mongodb</title>
    <link href="http://mmrxia.github.io/2016/12/16/windows%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmongodb/"/>
    <id>http://mmrxia.github.io/2016/12/16/windows下安装配置mongodb/</id>
    <published>2016-12-16T06:36:29.000Z</published>
    <updated>2016-12-16T09:25:29.582Z</updated>
    
    <content type="html">&lt;p&gt;安装文件：官方网站 &lt;a href=&quot;http://www.mongodb.org/downloads&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.mongodb.org/downloads&lt;/a&gt;&lt;br&gt;选择对应系统的文件下载。&lt;/p&gt;
&lt;h3 id=&quot;一、解压缩文件。&quot;&gt;&lt;a href=&quot;#一、解压缩文件。&quot; class=&quot;headerlink&quot; title=&quot;一、解压缩文件。&quot;&gt;&lt;/a&gt;一、解压缩文件。&lt;/h3&gt;&lt;p&gt;  将压缩包解压，在D盘创建文件夹&lt;code&gt;mongodb&lt;/code&gt;,将压缩包解压到&lt;code&gt;mongodb&lt;/code&gt;文件夹中。&lt;/p&gt;
&lt;h3 id=&quot;二、建立工作目录。&quot;&gt;&lt;a href=&quot;#二、建立工作目录。&quot; class=&quot;headerlink&quot; title=&quot;二、建立工作目录。&quot;&gt;&lt;/a&gt;二、建立工作目录。&lt;/h3&gt;&lt;p&gt;  1、建立数据存放目录  &lt;code&gt;D:\mongodb\data\db&lt;/code&gt;&lt;br&gt;  2、建立日志文件  &lt;code&gt;D:\mongodb\db\log\mongodb.log&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;三、建立配置文件。&quot;&gt;&lt;a href=&quot;#三、建立配置文件。&quot; class=&quot;headerlink&quot; title=&quot;三、建立配置文件。&quot;&gt;&lt;/a&gt;三、建立配置文件。&lt;/h3&gt;&lt;p&gt;&lt;code&gt;mongodb&lt;/code&gt;文件夹下建立&lt;code&gt;mongodb.cfg&lt;/code&gt;文件，输入以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;dbpath=D:\MongoDB\data #数据库路径
logpath=D:\MongoDB\logs\mongodb.log #日志输出文件路径
logappend=true #错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件
journal=true #启用日志文件，默认启用
quiet=true #这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false
port=27017 #端口号 默认为27017
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里仅指定了几个常用项，更多详细配置请参考官方文档 &lt;a href=&quot;http://docs.mongodb.org/manual/reference/configuration-options/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://docs.mongodb.org/manual/reference/configuration-options/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;四、启动mongdb服务。&quot;&gt;&lt;a href=&quot;#四、启动mongdb服务。&quot; class=&quot;headerlink&quot; title=&quot;四、启动mongdb服务。&quot;&gt;&lt;/a&gt;四、启动mongdb服务。&lt;/h3&gt;&lt;p&gt;至此&lt;code&gt;mongodb&lt;/code&gt;文件夹下有文件夹及文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;D:\ mongodb\bin
D:\ mongodb\data\db
D:\ mongodb\data\log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置文件和相关目录建好后使用如下方式启动mongodb：&lt;/p&gt;
&lt;p&gt;控制台进入&lt;code&gt;D:\ mongodb\bin&lt;/code&gt;目录，执行以下命令:&lt;/p&gt;
&lt;p&gt;1 . 普通启动 &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;mongod --config D:\mongodb\mongodb.cfg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2 . 安装为Windows服务&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;mongod --config D:\mongodb\mongodb.cfg --install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：2.6版 这种方式在win7、win8 64位版无法安装成功，其他系统未测试&lt;br&gt;BUG链接 &lt;a href=&quot;https://jira.mongodb.org/browse/SERVER-13515&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://jira.mongodb.org/browse/SERVER-13515&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3 . 使用SC命令安装为Windows服务&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;sc create MongoDB binPath= &amp;quot;D:\mongodb\bin\mongod.exe --service --config=D:\mongodb\mongodb.cfg&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;五、系统服务启动与删除。&quot;&gt;&lt;a href=&quot;#五、系统服务启动与删除。&quot; class=&quot;headerlink&quot; title=&quot;五、系统服务启动与删除。&quot;&gt;&lt;/a&gt;五、系统服务启动与删除。&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;net start MongoDB  //启动MongoDB服务  
net stop MongoDB  //停止MongoDB服务   
mongod --remove  //移除MongoDB服务 
sc delete MongoDB   //通过该方式删除的话，服务中的 mongod仍会存在，注册表中不存在了，再重启之后服务的mongodb才会消失
&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;安装文件：官方网站 &lt;a href=&quot;http://www.mongodb.org/downloads&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.mongodb.org/downloads&lt;/a&gt;&lt;br&gt;选择对应系统的文件下载。&lt;
    
    </summary>
    
    
      <category term="mongodb" scheme="http://mmrxia.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>bigPipe方案实现及剖析</title>
    <link href="http://mmrxia.github.io/2016/11/16/bigPipe%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%89%96%E6%9E%90/"/>
    <id>http://mmrxia.github.io/2016/11/16/bigPipe方案实现及剖析/</id>
    <published>2016-11-16T09:24:43.000Z</published>
    <updated>2016-11-16T09:38:16.234Z</updated>
    
    <content type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;2010 年初的时候，Facebook 的前端性能研究小组开始了他们的优化项目，经过了六个月的努力，成功的将个人空间主页面加载耗时由原来的5 秒减少为现在的2.5 秒。&lt;br&gt;这是一个非常了不起的成就，也给用户来带来了很好的体验。在优化项目中，工程师提出了一种新的页面加载技术，称之为Bigpipe。&lt;br&gt;目前淘宝和Facebook面临的问题非常相似：海量数据和页面过大，如果可以在详情页、列表页中使用bigpipe，将会带来明显的页面加载速度提升。&lt;/p&gt;
&lt;h2 id=&quot;相关介绍&quot;&gt;&lt;a href=&quot;#相关介绍&quot; class=&quot;headerlink&quot; title=&quot;相关介绍&quot;&gt;&lt;/a&gt;相关介绍&lt;/h2&gt;&lt;p&gt;一、BigPipe与AJAX&lt;/p&gt;
&lt;p&gt;Web2.0的重要特征是网页显示大量动态内容，即web2.0注重网页与用户的交互。其核心技术是AJAX，如今所有主流网站都或多或少使用AJAX。与AJAX类似，BigPipe 实现了分块儿的概念，使页面能够分步输出，即每次输出一部分网页内容。接下来讨论BigPipe 与AJAX 的区别。&lt;/p&gt;
&lt;p&gt;简单的说，BigPipe 比AJAX 有三个好处：&lt;/p&gt;
&lt;p&gt;1 . AJAX 的核心是XMLHttpRequest，客户端需要异步的向服务器端发送请求，然后将传送过来的内容动态添加到网页上。如此实现存在一些缺陷，即发送往返请求需要耗费时间，而BigPipe 技术使浏览器并不需要发送XMLHttpRequest 请求，这样就节省时间损耗。&lt;/p&gt;
&lt;p&gt;2 . 使用AJAX时，浏览器和服务器的工作顺序执行。服务器必须等待浏览器的请求，这样就会造成服务器的空闲。浏览器工作时，服务器在等待，而服务器工作时，浏览器在等待，这也是一种性能的浪费。使用BigPipe，浏览器和服务器可以并行同时工作，服务器不需要等待浏览器的请求，而是一直处于加载页面内容的工作阶段，这就会使效率得到更大的提高。&lt;/p&gt;
&lt;p&gt;3 . 减少浏览器发送到请求。对一个5亿用户的网站来说，减少了使用AJAX额外带来的请求，会减少服务器的负载，同样会带来很大的性能提升。&lt;/p&gt;
&lt;p&gt;基于以上三点，Facebook 在进行页面优化时采用了BigPipe 技术。目前淘宝主搜索结果页中，需要加载类目，相关搜索，宝贝列表，广告等内容，前端这里使用php 的curl 的批处理来并发的访问引擎获取相应的数据，并进行分步输出。这种模式还是与bigpipe有些不同，这点后面会讲到。一般来讲，在页面比较大，而且比较复杂，样式表和脚本比较多的情况下，使用BigPipe 来优化输出页面是比较合适的。另外非常重要的一点，BigPipe 并不改变浏览器的结构与网络协议，仅使用JS就可以实现，用户不需要做任何的设置，就会看到明显的访问时间缩短。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.searchtb.com/2011/04/an-introduction-to-bigpipe.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.searchtb.com/2011/04/an-introduction-to-bigpipe.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;待续…&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;2010 年初的时候，Facebook 的前端性能研究小组开始了他们的优化项目，经过了六个月的努力，成功的将个人空间主页面加载耗时由原来的5
    
    </summary>
    
    
      <category term="nodejs" scheme="http://mmrxia.github.io/tags/nodejs/"/>
    
      <category term="bigPipe" scheme="http://mmrxia.github.io/tags/bigPipe/"/>
    
  </entry>
  
  <entry>
    <title>js encode或decode base64格式的字符串</title>
    <link href="http://mmrxia.github.io/2016/11/16/js-encode%E6%88%96decode-base64%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://mmrxia.github.io/2016/11/16/js-encode或decode-base64格式的字符串/</id>
    <published>2016-11-16T08:50:07.000Z</published>
    <updated>2016-11-16T09:13:35.557Z</updated>
    
    <content type="html">&lt;h4 id=&quot;方式一：Chrome、FireFox等现代主流浏览器或IE10及以上版本。&quot;&gt;&lt;a href=&quot;#方式一：Chrome、FireFox等现代主流浏览器或IE10及以上版本。&quot; class=&quot;headerlink&quot; title=&quot;方式一：Chrome、FireFox等现代主流浏览器或IE10及以上版本。&quot;&gt;&lt;/a&gt;方式一：Chrome、FireFox等现代主流浏览器或IE10及以上版本。&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 测试字符
var string = &amp;#39;Hello World!&amp;#39;;

// 加密
var encodedString = btoa(string);
console.log(encodedString); // 输出: &amp;quot;SGVsbG8gV29ybGQh&amp;quot;

// 解密
var decodedString = atob(encodedString);
console.log(decodedString); // 输出: &amp;quot;Hello World!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;方式二：跨浏览器的方法（压缩版本）&quot;&gt;&lt;a href=&quot;#方式二：跨浏览器的方法（压缩版本）&quot; class=&quot;headerlink&quot; title=&quot;方式二：跨浏览器的方法（压缩版本）&quot;&gt;&lt;/a&gt;方式二：跨浏览器的方法（压缩版本）&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 定义Base64对象
var Base64={_keyStr:&amp;quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&amp;quot;,encode:function(e){var t=&amp;quot;&amp;quot;;var n,r,i,s,o,u,a;var f=0;e=Base64._utf8_encode(e);while(f&amp;lt;e.length){n=e.charCodeAt(f++);r=e.charCodeAt(f++);i=e.charCodeAt(f++);s=n&amp;gt;&amp;gt;2;o=(n&amp;amp;3)&amp;lt;&amp;lt;4|r&amp;gt;&amp;gt;4;u=(r&amp;amp;15)&amp;lt;&amp;lt;2|i&amp;gt;&amp;gt;6;a=i&amp;amp;63;if(isNaN(r)){u=a=64}else if(isNaN(i)){a=64}t=t+this._keyStr.charAt(s)+this._keyStr.charAt(o)+this._keyStr.charAt(u)+this._keyStr.charAt(a)}return t},decode:function(e){var t=&amp;quot;&amp;quot;;var n,r,i;var s,o,u,a;var f=0;e=e.replace(/[^A-Za-z0-9+/=]/g,&amp;quot;&amp;quot;);while(f&amp;lt;e.length){s=this._keyStr.indexOf(e.charAt(f++));o=this._keyStr.indexOf(e.charAt(f++));u=this._keyStr.indexOf(e.charAt(f++));a=this._keyStr.indexOf(e.charAt(f++));n=s&amp;lt;&amp;lt;2|o&amp;gt;&amp;gt;4;r=(o&amp;amp;15)&amp;lt;&amp;lt;4|u&amp;gt;&amp;gt;2;i=(u&amp;amp;3)&amp;lt;&amp;lt;6|a;t=t+String.fromCharCode(n);if(u!=64){t=t+String.fromCharCode(r)}if(a!=64){t=t+String.fromCharCode(i)}}t=Base64._utf8_decode(t);return t},_utf8_encode:function(e){e=e.replace(/rn/g,&amp;quot;n&amp;quot;);var t=&amp;quot;&amp;quot;;for(var n=0;n&amp;lt;e.length;n++){var r=e.charCodeAt(n);if(r&amp;lt;128){t+=String.fromCharCode(r)}else if(r&amp;gt;127&amp;amp;&amp;amp;r&amp;lt;2048){t+=String.fromCharCode(r&amp;gt;&amp;gt;6|192);t+=String.fromCharCode(r&amp;amp;63|128)}else{t+=String.fromCharCode(r&amp;gt;&amp;gt;12|224);t+=String.fromCharCode(r&amp;gt;&amp;gt;6&amp;amp;63|128);t+=String.fromCharCode(r&amp;amp;63|128)}}return t},_utf8_decode:function(e){var t=&amp;quot;&amp;quot;;var n=0;var r=c1=c2=0;while(n&amp;lt;e.length){r=e.charCodeAt(n);if(r&amp;lt;128){t+=String.fromCharCode(r);n++}else if(r&amp;gt;191&amp;amp;&amp;amp;r&amp;lt;224){c2=e.charCodeAt(n+1);t+=String.fromCharCode((r&amp;amp;31)&amp;lt;&amp;lt;6|c2&amp;amp;63);n+=2}else{c2=e.charCodeAt(n+1);c3=e.charCodeAt(n+2);t+=String.fromCharCode((r&amp;amp;15)&amp;lt;&amp;lt;12|(c2&amp;amp;63)&amp;lt;&amp;lt;6|c3&amp;amp;63);n+=3}}return t}}

// 测试字符
var string = &amp;#39;Hello World!&amp;#39;;

// 加密
var encodedString = Base64.encode(string);
console.log(encodedString); // 输出: &amp;quot;SGVsbG8gV29ybGQh&amp;quot;

// 解密
var decodedString = Base64.decode(encodedString);
console.log(decodedString); // 输出: &amp;quot;Hello World!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;方式一：Chrome、FireFox等现代主流浏览器或IE10及以上版本。&quot;&gt;&lt;a href=&quot;#方式一：Chrome、FireFox等现代主流浏览器或IE10及以上版本。&quot; class=&quot;headerlink&quot; title=&quot;方式一：Chrome、FireFox
    
    </summary>
    
    
      <category term="javascript" scheme="http://mmrxia.github.io/tags/javascript/"/>
    
      <category term="base64" scheme="http://mmrxia.github.io/tags/base64/"/>
    
  </entry>
  
  <entry>
    <title>怎样使用js生成uuid</title>
    <link href="http://mmrxia.github.io/2016/09/01/%E6%80%8E%E6%A0%B7%E4%BD%BF%E7%94%A8js%E7%94%9F%E6%88%90uuid/"/>
    <id>http://mmrxia.github.io/2016/09/01/怎样使用js生成uuid/</id>
    <published>2016-09-01T06:57:55.000Z</published>
    <updated>2016-09-01T07:10:53.536Z</updated>
    
    <content type="html">&lt;p&gt;原问题：&lt;a href=&quot;http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How to create a GUID / UUID in Javascript?&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Introuction&quot;&gt;&lt;a href=&quot;#Introuction&quot; class=&quot;headerlink&quot; title=&quot;Introuction&quot;&gt;&lt;/a&gt;Introuction&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;UUID = Universally Unique IDentifier, 全球唯一标识符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本来我觉得UUID不是什么事，只是一个唯一性的ID字符串而已。在Stack Overflow上看到这个问题之后，倒开始觉得，也许UUID里也有一些值得去发掘的东西。&lt;/p&gt;
&lt;p&gt;于是我想到了这几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#UUID-and-GUID&quot;&gt;为什么有UUID和GUID这两个东西&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Specification&quot;&gt;有什么规范吗&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;好像我曾多次看到过有人讨论某种系统或变成语言下UUID的生成问题，&lt;a href=&quot;#UUID-and-implementation&quot;&gt;UUID跟系统或者编程语言有关系吗&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;带着这些问题，我查找并学习了一番。现在做个整理。&lt;/p&gt;
&lt;h2 id=&quot;UUID-and-GUID&quot;&gt;&lt;a href=&quot;#UUID-and-GUID&quot; class=&quot;headerlink&quot; title=&quot;UUID and GUID&quot;&gt;&lt;/a&gt;UUID and GUID&lt;/h2&gt;&lt;h4 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h4&gt;&lt;p&gt;UUID来自于IETF发布的一个规范：&lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;A Universally Unique IDentifier (UUID) URN Namespace&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This specification defines a Uniform Resource Name namespace for UUIDs (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDentifier).  A UUID is 128 bits long, and can guarantee uniqueness across space and time.  UUIDs were originally used in the Apollo Network Computing System and later in the Open Software Foundation’s (OSF) Distributed Computing Environment (DCE), and then in Microsoft Windows platforms.&lt;br&gt;This specification is derived from the DCE specification with the kind permission of the OSF (now known as The Open Group).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;UUID和GUID是同一个东西的两个名字。这两个名字的来源不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UUID来源于OSF的DCE规范，也就是RFC4122的前身&lt;/li&gt;
&lt;li&gt;GUID来源于微软，注意RFC4122的作者之一是微软员工&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;用途&quot;&gt;&lt;a href=&quot;#用途&quot; class=&quot;headerlink&quot; title=&quot;用途&quot;&gt;&lt;/a&gt;用途&lt;/h4&gt;&lt;p&gt;UUID的出现，是为了在一个复杂的系统中，唯一的标识每个信息实体，同时不需要有一个集中的id管理。也就是说，根据某种规则来为一个信息实体分配一个唯一的id，而且不需要一个id管理器来保证这个id的唯一性。&lt;/p&gt;
&lt;p&gt;它可以用来标识任何东西，Microsoft用它来表示Windows中的软件（GUID），Linux用它来表示系统中的文件。&lt;/p&gt;
&lt;h2 id=&quot;Specification&quot;&gt;&lt;a href=&quot;#Specification&quot; class=&quot;headerlink&quot; title=&quot;Specification&quot;&gt;&lt;/a&gt;Specification&lt;/h2&gt;&lt;h4 id=&quot;UUID格式规范&quot;&gt;&lt;a href=&quot;#UUID格式规范&quot; class=&quot;headerlink&quot; title=&quot;UUID格式规范&quot;&gt;&lt;/a&gt;UUID格式规范&lt;/h4&gt;&lt;p&gt;这128bits的结构如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          time_low                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       time_mid                |         time_hi_and_version   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |clk_seq_hi_res |  clk_seq_low  |         node (0-1)            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         node (2-5)                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      time-low               = 4hexOctet
      time-mid               = 2hexOctet
      time-high-and-version  = 2hexOctet    // MOST IMPORTANT !
      clock-seq-and-reserved = hexOctet
      clock-seq-low          = hexOctet
      node                   = 6hexOctet
      hexOctet               = hexDigit hexDigit
      hexDigit =
            &amp;quot;0&amp;quot; / &amp;quot;1&amp;quot; / &amp;quot;2&amp;quot; / &amp;quot;3&amp;quot; / &amp;quot;4&amp;quot; / &amp;quot;5&amp;quot; / &amp;quot;6&amp;quot; / &amp;quot;7&amp;quot; / &amp;quot;8&amp;quot; / &amp;quot;9&amp;quot; /
            &amp;quot;a&amp;quot; / &amp;quot;b&amp;quot; / &amp;quot;c&amp;quot; / &amp;quot;d&amp;quot; / &amp;quot;e&amp;quot; / &amp;quot;f&amp;quot; /
            &amp;quot;A&amp;quot; / &amp;quot;B&amp;quot; / &amp;quot;C&amp;quot; / &amp;quot;D&amp;quot; / &amp;quot;E&amp;quot; / &amp;quot;F&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;UUID生成算法&quot;&gt;&lt;a href=&quot;#UUID生成算法&quot; class=&quot;headerlink&quot; title=&quot;UUID生成算法&quot;&gt;&lt;/a&gt;UUID生成算法&lt;/h4&gt;&lt;p&gt;UUID本身也经过了&lt;a href=&quot;http://en.wikipedia.org/wiki/Universally_unique_identifier#Variants_and_versions&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;多个版本的演化&lt;/a&gt;。比如node字段的定义，最开始定义为来自IEEE 802 address，演化到后来的&lt;em&gt;a randomly or pseudo-randomly generated 48-bit value&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;最新的UUID生成算法是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Set the two most significant bits (bits 6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively.&lt;/li&gt;
&lt;li&gt;Set the four most significant bits (bits 12 through 15) of the time_hi_and_version field to the 4-bit version number.&lt;/li&gt;
&lt;li&gt;Set all the other bits to randomly (or pseudo-randomly) chosen values.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;UUID-and-implementation&quot;&gt;&lt;a href=&quot;#UUID-and-implementation&quot; class=&quot;headerlink&quot; title=&quot;UUID and implementation&quot;&gt;&lt;/a&gt;UUID and implementation&lt;/h2&gt;&lt;p&gt;越来越多的系统中使用着UUID，各自使用目的并不一样。而且由于限定在128bits，UUID规范本身并没有保证UUID真的是在全球唯一的。因此现在对UUID的使用，一般都是限定在一个范围内有唯一性保证，比如一个操作系统内。&lt;/p&gt;
&lt;p&gt;因此我们可以看到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微软有一个GUID生成lib：&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.guid(v=vs.110).aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://msdn.microsoft.com/en-us/library/system.guid(v=vs.110).aspx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Linux也同样有UUID生成lib：&lt;a href=&quot;http://en.wikipedia.org/wiki/Util-linux&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://en.wikipedia.org/wiki/Util-linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Android的UUID生成lib：&lt;a href=&quot;http://developer.android.com/reference/java/util/UUID.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://developer.android.com/reference/java/util/UUID.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用以上系统对应的UUID生成lib可以确保产生的UUID在系统范围内是唯一的。因此可以用来标识系统资源，比如文件、软件、设备等。&lt;/p&gt;
&lt;p&gt;而对于某种具体的编程语言，UUID的使用并没有必要。因为使用UUID的目的是给某个资源分配一个在当前环境下唯一的标识符。而一个程序只有在运行的时候才谈得上有一个&lt;strong&gt;环境&lt;/strong&gt;，进程之间又互不影响。因此，一般在编程语言规范中并没有对UUID生成方法进行规定。&lt;/p&gt;
&lt;p&gt;但&lt;em&gt;unique id&lt;/em&gt;还是很常用的，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PHP - uniqid() &lt;a href=&quot;http://php.net/manual/en/function.uniqid.php#94959&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://php.net/manual/en/function.uniqid.php#94959&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Mysql - UUID() &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/miscellaneous-functions.html#function_uuid&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://dev.mysql.com/doc/refman/5.1/en/miscellaneous-functions.html#function_uuid&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Java - UUID &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/UUID.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://docs.oracle.com/javase/7/docs/api/java/util/UUID.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但这些UUID方法只是借用了&lt;em&gt;唯一性&lt;/em&gt;的概念，并不是必须。而且uuid规定128bits，很多情况下有点浪费。&lt;/p&gt;
&lt;p&gt;你可以用任何方法来生成一个程序内唯一的字符串，比如mysql中的incremental id，它就比uuid实用。&lt;/p&gt;
&lt;p&gt;##UUID in Javascript&lt;br&gt;既然要生成UUID，那么得符合规范。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Javascript function&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function generateUUID(){
    var d = new Date().getTime();
    var uuid = &amp;#39;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&amp;#39;.replace(/[xy]/g, function(c) {
        var r = (d + Math.random()*16)%16 | 0;
        d = Math.floor(d/16);
        return (c==&amp;#39;x&amp;#39; ? r : (r&amp;amp;0x7|0x8)).toString(16);
    });
    return uuid;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Node module&lt;br&gt;&lt;a href=&quot;https://github.com/broofa/node-uuid&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/broofa/node-uuid&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;原问题：&lt;a href=&quot;http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How to cre
    
    </summary>
    
    
      <category term="javascript" scheme="http://mmrxia.github.io/tags/javascript/"/>
    
      <category term="uuid" scheme="http://mmrxia.github.io/tags/uuid/"/>
    
  </entry>
  
  <entry>
    <title>使用淘宝npm镜像cnpm</title>
    <link href="http://mmrxia.github.io/2016/08/05/%E4%BD%BF%E7%94%A8%E6%B7%98%E5%AE%9Dnpm%E9%95%9C%E5%83%8Fcnpm/"/>
    <id>http://mmrxia.github.io/2016/08/05/使用淘宝npm镜像cnpm/</id>
    <published>2016-08-05T03:24:36.000Z</published>
    <updated>2016-08-05T03:57:36.984Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;在使用 node 模块时可以使用 npm install 查找 package.json 中的声明的依赖模块并安装。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但因为国内网络原因，使用 npm 安装某些模块会非常慢，甚至无法安装所有的包。&lt;br&gt;幸运的是,国内有几个镜像站点可以供我们使用,比如 &lt;code&gt;https://registry.cnpmjs.org&lt;/code&gt;、&lt;code&gt;https://registry.npm.taobao.org&lt;/code&gt;,速度非常快,镜像站会实时更新,为我们节省了好多时间.    &lt;/p&gt;
&lt;h5 id=&quot;那么-如何给本机换源呢&quot;&gt;&lt;a href=&quot;#那么-如何给本机换源呢&quot; class=&quot;headerlink&quot; title=&quot;那么,如何给本机换源呢?&quot;&gt;&lt;/a&gt;那么,如何给本机换源呢?&lt;/h5&gt;&lt;p&gt;(1)[临时]通过 &lt;code&gt;config&lt;/code&gt; 配置指向国内镜像源&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;# 配置指向源
npm config set registry http://registry.cnpmjs.org
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(2)[临时]通过 &lt;code&gt;npm&lt;/code&gt; 命令指定下载源&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;npm --registry http://registry.cnpmjs.org
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(3)[linux]在配置文件 &lt;code&gt;~/.npmrc&lt;/code&gt; 文件写入源地址&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;//打开配置文件
nano ~/.npmrc
//写入配置文件
registry =https://registry.npm.taobao.org
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;推荐使用最后一种方法,一劳永逸,前面2钟方法都是临时改变包下载源.&lt;br&gt;如果你不想使用国内镜像站点,只需要将 写入 &lt;code&gt;~/.npmrc&lt;/code&gt; 的配置内容删除即可.  &lt;/p&gt;
&lt;p&gt;配置后可通过下面方式来验证是否成功&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;npm config get registry
// 或
npm info express
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&quot;使用cnpm&quot;&gt;&lt;a href=&quot;#使用cnpm&quot; class=&quot;headerlink&quot; title=&quot;使用cnpm&quot;&gt;&lt;/a&gt;使用cnpm&lt;/h5&gt;&lt;p&gt;或者你也可以安装&lt;code&gt;cnpm&lt;/code&gt;包，使用&lt;code&gt;cnpm&lt;/code&gt;替代&lt;code&gt;npm&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;npm install -g cnpm --registry=https://registry.npm.taobao.org
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后使用 &lt;code&gt;cnpm&lt;/code&gt; 安装模块：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;cnpm install [module-name]
&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在使用 node 模块时可以使用 npm install 查找 package.json 中的声明的依赖模块并安装。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但因为国内网络原因，使用 npm 安装某些模块会非常慢，甚至无法安装所有的包。&lt;br
    
    </summary>
    
    
      <category term="npm" scheme="http://mmrxia.github.io/tags/npm/"/>
    
      <category term="cnpm" scheme="http://mmrxia.github.io/tags/cnpm/"/>
    
  </entry>
  
  <entry>
    <title>html5在iOS设备上传图片调整方向实践</title>
    <link href="http://mmrxia.github.io/2016/07/18/html5%E5%9C%A8iOS%E8%AE%BE%E5%A4%87%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E8%B0%83%E6%95%B4%E6%96%B9%E5%90%91%E5%AE%9E%E8%B7%B5/"/>
    <id>http://mmrxia.github.io/2016/07/18/html5在iOS设备上传图片调整方向实践/</id>
    <published>2016-07-18T11:56:54.000Z</published>
    <updated>2016-07-18T11:59:19.353Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;解决在iOS设备上，用H5上传图片，有时图片方向会错乱的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用html5编写图片裁切上传，在iphone手机上可能会遇到图片方向错误问题，在此把解决方法和大家分享一下，&lt;br&gt;用到了html5的 FileReader和Canvas，如果还没有接触的同学，先了解一下其方法。   &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt; //此方法为file input元素的change事件
 function change(){
    var file = this.files[0];
    var orientation;
    //EXIF js 可以读取图片的元信息  https://github.com/exif-js/exif-js
    EXIF.getData(file,function(){
        orientation=EXIF.getTag(this,&amp;#39;Orientation&amp;#39;);
    });
    var reader = new FileReader();
    reader.onload = function(e) {   
        getImgData(this.result,orientation,function(data){
            //这里可以使用校正后的图片data了 
        }); 
    }
    reader.readAsDataURL(file);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面是具体的处理方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// @param {string} img 图片的base64
// @param {int} dir exif获取的方向信息
// @param {function} next 回调方法，返回校正方向后的base64
function getImgData(img,dir,next){
  var image=new Image();
  image.onload=function(){
    var degree=0,drawWidth,drawHeight,width,height;
    drawWidth=this.naturalWidth;
    drawHeight=this.naturalHeight;
    //以下改变一下图片大小
    var maxSide = Math.max(drawWidth, drawHeight);
    if (maxSide &amp;gt; 1024) {
        var minSide = Math.min(drawWidth, drawHeight);
        minSide = minSide / maxSide * 1024;
        maxSide = 1024;
        if (drawWidth &amp;gt; drawHeight) {
            drawWidth = maxSide;
            drawHeight = minSide;
        } else {
            drawWidth = minSide;
            drawHeight = maxSide;
        }
    }
    var canvas=document.createElement(&amp;#39;canvas&amp;#39;);
    canvas.width=width=drawWidth;
    canvas.height=height=drawHeight; 
    var context=canvas.getContext(&amp;#39;2d&amp;#39;);
    //判断图片方向，重置canvas大小，确定旋转角度，iphone默认的是home键在右方的横屏拍摄方式
    switch(dir){
       //iphone横屏拍摄，此时home键在左侧
        case 3:
            degree=180;
            drawWidth=-width;
            drawHeight=-height;
            break;
        //iphone竖屏拍摄，此时home键在下方(正常拿手机的方向)
        case 6:
            canvas.width=height;
            canvas.height=width; 
            degree=90;
            drawWidth=width;
            drawHeight=-height;
            break;
        //iphone竖屏拍摄，此时home键在上方
        case 8:
            canvas.width=height;
            canvas.height=width; 
            degree=270;
            drawWidth=-width;
            drawHeight=height;
            break;
    }
    //使用canvas旋转校正
    context.rotate(degree*Math.PI/180);
    context.drawImage(this,0,0,drawWidth,drawHeight);
    //返回校正图片
    next(canvas.toDataURL(&amp;quot;image/jpeg&amp;quot;,.8));
 }
  image.src=img;
}
&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;解决在iOS设备上，用H5上传图片，有时图片方向会错乱的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用html5编写图片裁切上传，在iphone手机上可能会遇到图片方向错误问题，在此把解决方法和大家分享一下，&lt;br&gt;用到了html5的 Fil
    
    </summary>
    
    
      <category term="移动端开发" scheme="http://mmrxia.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="js" scheme="http://mmrxia.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>centOS下配置git</title>
    <link href="http://mmrxia.github.io/2016/07/04/centOS%E4%B8%8B%E9%85%8D%E7%BD%AEgit/"/>
    <id>http://mmrxia.github.io/2016/07/04/centOS下配置git/</id>
    <published>2016-07-04T08:14:54.000Z</published>
    <updated>2016-07-17T06:26:55.420Z</updated>
    
    <content type="html">&lt;h4 id=&quot;1-安装git&quot;&gt;&lt;a href=&quot;#1-安装git&quot; class=&quot;headerlink&quot; title=&quot;1. 安装git&quot;&gt;&lt;/a&gt;1. 安装git&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost ~]# yum install git
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;2-配置git&quot;&gt;&lt;a href=&quot;#2-配置git&quot; class=&quot;headerlink&quot; title=&quot;2. 配置git&quot;&gt;&lt;/a&gt;2. 配置git&lt;/h4&gt;&lt;p&gt;1 . 进入 &lt;code&gt;.ssh&lt;/code&gt; 目录&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost ~]# cd .ssh/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2 . 生成ssh-keygen&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost .ssh]# ssh-keygen -t rsa -C &amp;#39;this.xqs@gmail.com&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会出现以下提示：&lt;/p&gt;
&lt;p&gt;Generating public/private rsa key pair.&lt;br&gt;Enter file in which to save the key (/root/.ssh/id_rsa): （可不填）&lt;br&gt;Enter passphrase (empty for no passphrase):  （可不填）&lt;br&gt;Enter same passphrase again:  （可不填）&lt;br&gt;Your identification has been saved in /root/.ssh/id_rsa.&lt;br&gt;Your public key has been saved in /root/.ssh/id_rsa.pub.&lt;br&gt;The key fingerprint is:&lt;br&gt;8f:8e:89:00:1a:3e:83:d1:95:fc:e8:9c:22:85:4c:a7 this.xqs@gmail.com        &lt;/p&gt;
&lt;p&gt;3 . 复制 &lt;code&gt;id_rsa.pub&lt;/code&gt; 文件中的内容，粘贴到github新增的ssh keys中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost .ssh]# ls
// id_rsa  id_rsa.pub

[root@localhost .ssh]# vim id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4 . 配置用户名和邮箱&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost .ssh]# git config --global user.name &amp;#39;bandwagonhost vps&amp;#39;
[root@localhost .ssh]# git config --global user.email &amp;#39;this.xqs@gmail.com&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5 . 测试连接&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost .ssh]# ssh -T git@github.com
Hi mmrxia! You&amp;#39;ve successfully authenticated, but GitHub does not provide shell access.
&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-安装git&quot;&gt;&lt;a href=&quot;#1-安装git&quot; class=&quot;headerlink&quot; title=&quot;1. 安装git&quot;&gt;&lt;/a&gt;1. 安装git&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost ~]
    
    </summary>
    
    
      <category term="Linux" scheme="http://mmrxia.github.io/tags/Linux/"/>
    
      <category term="git" scheme="http://mmrxia.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>centOS下安装nodeJS</title>
    <link href="http://mmrxia.github.io/2016/07/04/centOS%E4%B8%8B%E5%AE%89%E8%A3%85nodeJS/"/>
    <id>http://mmrxia.github.io/2016/07/04/centOS下安装nodeJS/</id>
    <published>2016-07-04T06:30:07.000Z</published>
    <updated>2016-07-07T09:35:21.098Z</updated>
    
    <content type="html">&lt;h4 id=&quot;一、源码安装&quot;&gt;&lt;a href=&quot;#一、源码安装&quot; class=&quot;headerlink&quot; title=&quot;一、源码安装&quot;&gt;&lt;/a&gt;一、源码安装&lt;/h4&gt;&lt;p&gt;1 . 安装gcc-c编译器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost ~]# sudo yum install gcc gcc-c++
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2 . 现在nodejs源码并解压  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost ~]# wget https://nodejs.org/dist/v4.4.7/node-v4.4.7-linux-x86.tar.gz
[root@localhost ~]# tar xvf node-v4.4.7-linux-x86
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3 . 编译&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost ~]# ./configure
[root@localhost ~]# make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;二、nvm安装&quot;&gt;&lt;a href=&quot;#二、nvm安装&quot; class=&quot;headerlink&quot; title=&quot;二、nvm安装&quot;&gt;&lt;/a&gt;二、nvm安装&lt;/h4&gt;&lt;p&gt;1 . 获取nvm&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.31.2/install.sh | bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2 . 安装nodejs&lt;/p&gt;
&lt;p&gt; 可用 &lt;code&gt;nvm ls-remote&lt;/code&gt; 列出所有可安装的node版本，然后安装需要的版本。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; nvm install v4.4.7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装完成后可查看node版本。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;node -v
&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、源码安装&quot;&gt;&lt;a href=&quot;#一、源码安装&quot; class=&quot;headerlink&quot; title=&quot;一、源码安装&quot;&gt;&lt;/a&gt;一、源码安装&lt;/h4&gt;&lt;p&gt;1 . 安装gcc-c编译器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[r
    
    </summary>
    
    
      <category term="nodejs" scheme="http://mmrxia.github.io/tags/nodejs/"/>
    
      <category term="Linux" scheme="http://mmrxia.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>express学习笔记</title>
    <link href="http://mmrxia.github.io/2016/07/01/express%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://mmrxia.github.io/2016/07/01/express学习笔记/</id>
    <published>2016-07-01T07:32:01.000Z</published>
    <updated>2016-07-18T11:44:35.814Z</updated>
    
    <content type="html">&lt;h4 id=&quot;1-app-render和res-render方法的区别？&quot;&gt;&lt;a href=&quot;#1-app-render和res-render方法的区别？&quot; class=&quot;headerlink&quot; title=&quot;1 . app.render和res.render方法的区别？&quot;&gt;&lt;/a&gt;1 . app.render和res.render方法的区别？&lt;/h4&gt;&lt;p&gt;官方的api文档中是这么说的：   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Think of app.render() as a utility function for generating rendered view strings. Internally res.render() uses app.render() to render views.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的理解：&lt;/p&gt;
&lt;p&gt;把&lt;code&gt;app.render&lt;/code&gt;当成一个生成视图的工具，而且&lt;code&gt;res.render&lt;/code&gt;内部也是调用了&lt;code&gt;app.render&lt;/code&gt;。&lt;br&gt;区别是这样，&lt;code&gt;app.render&lt;/code&gt;只负责生成视图，你会发现它是没能力把视图响应给客户端（浏览器）的，只有&lt;code&gt;res.render&lt;/code&gt;手里有&lt;code&gt;response&lt;/code&gt;对象，可以把视图响应给客户端。&lt;br&gt;&lt;code&gt;res.render&lt;/code&gt;的伪代码可以看做如下: &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;res.render = function(view, locals, cb){
    app.render(view, locals, function(err, html){
        if(typeof cb !== &amp;#39;undefined&amp;#39;){
            return cb(err, html);
        }
        res.send(html);
    });
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;2-res-write和res-send区别？&quot;&gt;&lt;a href=&quot;#2-res-write和res-send区别？&quot; class=&quot;headerlink&quot; title=&quot;2 . res.write和res.send区别？&quot;&gt;&lt;/a&gt;2 . res.write和res.send区别？&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;The res object represents the HTTP response that an Express app sends when it gets an HTTP request.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;res.write&lt;/code&gt;和&lt;code&gt;res.send&lt;/code&gt;都是发送报文到浏览器response中，并渲染在浏览器窗口。&lt;br&gt;&lt;code&gt;res.write&lt;/code&gt;使用时需要配合&lt;code&gt;res.end&lt;/code&gt;方法同时使用，否则浏览器http请求会一直处于pending状态，而&lt;code&gt;res.send&lt;/code&gt;单独使用即可。    &lt;/p&gt;
&lt;p&gt;代码示例：     &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//res.send
app.get(&amp;#39;/user/:id&amp;#39;, function(req, res){
  res.send(&amp;#39;user &amp;#39; + req.params.id);
});

//res.write
app.get(&amp;#39;/user/:id&amp;#39;, function(req, res){
 res.status(200).write(&amp;#39;user &amp;#39; + req.params.id);
 res.end();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;3-获取request请求参数的方法？&quot;&gt;&lt;a href=&quot;#3-获取request请求参数的方法？&quot; class=&quot;headerlink&quot; title=&quot;3 . 获取request请求参数的方法？&quot;&gt;&lt;/a&gt;3 . 获取request请求参数的方法？&lt;/h4&gt;&lt;p&gt;express获取参数有三种方法：  &lt;/p&gt;
&lt;p&gt;官网实例：   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Checks route params (req.params), ex: /user/:id&lt;br&gt;Checks query string params (req.query), ex: ?id=12&lt;br&gt;Checks urlencoded body params (req.body), ex: id=    &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;例如：127.0.0.1:3000/index，得到index，可以通过使用&lt;code&gt;req.params&lt;/code&gt;得到；   &lt;/li&gt;
&lt;li&gt;例如：127.0.0.1:3000/index?id=12，这种情况下，这种方式是获取客户端get方式传递过来的值，通过使用&lt;code&gt;req.query.id&lt;/code&gt;可以获得；     &lt;/li&gt;
&lt;li&gt;例如：127.0.0.1：300/index，然后post了一个id=2的值，这种方式是获取客户端post过来的数据，可以通过&lt;code&gt;req.body.id&lt;/code&gt;获取； &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：post请求，第三种方式需要以下配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;   var express        =         require(&amp;quot;express&amp;quot;);  
   var bodyParser     =         require(&amp;quot;body-parser&amp;quot;);  
   var app            =         express();  

   app.use(bodyParser.urlencoded({ extended: false }));   // necessary
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;4-session使用入门&quot;&gt;&lt;a href=&quot;#4-session使用入门&quot; class=&quot;headerlink&quot; title=&quot;4 . session使用入门&quot;&gt;&lt;/a&gt;4 . session使用入门&lt;/h4&gt;&lt;p&gt;&lt;code&gt;express-session&lt;/code&gt;是express中比较常用的处理session的中间件,使用npm安装：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;$ npm install express-session save
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;session的认证机制必须依赖cookie，所以还应该同时安装一个&lt;code&gt;cookie-parser&lt;/code&gt;，安装方法同上。然后再app.js中导入这两个中间件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var cookieParser = require(&amp;#39;cookie-parser&amp;#39;);
var session = require(&amp;#39;express-session&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后定义cookie解析器，注意，该定义必须写在路由分配之前：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;app.use(cookieParser());
app.use(session({
  secret: &amp;#39;secret_string&amp;#39;,
  name: &amp;#39;name&amp;#39;,
  cookie: {maxAge: 60000},
  resave: false,
  saveUninitialized: true,
}));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;各参数意义：&lt;br&gt;&lt;code&gt;secret&lt;/code&gt;：用来对session数据进行加密的字符串.这个属性值为必须指定的属性。&lt;br&gt;&lt;code&gt;name&lt;/code&gt;：表示cookie的name，默认cookie的name是：connect.sid。&lt;br&gt;&lt;code&gt;maxAge&lt;/code&gt;：cookie过期时间，毫秒。&lt;br&gt;&lt;code&gt;resave&lt;/code&gt;：是指每次请求都重新设置session cookie，假设你的cookie是6000毫秒过期，每次请求都会再设置6000毫秒。&lt;br&gt;&lt;code&gt;saveUninitialized&lt;/code&gt;： 是指无论有没有session cookie，每次请求都设置个session cookie ，默认给个标示为 connect.sid。     &lt;/p&gt;
&lt;p&gt;之后在处理请求时直接通过以下方式对session进行读写：        &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;req.session.userinfo = userinfo;  //写入至session
res.redirect(req.session.userinfo); //从session中读取
&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-app-render和res-render方法的区别？&quot;&gt;&lt;a href=&quot;#1-app-render和res-render方法的区别？&quot; class=&quot;headerlink&quot; title=&quot;1 . app.render和res.render方法的区别？&quot;&gt;&lt;
    
    </summary>
    
    
      <category term="nodejs" scheme="http://mmrxia.github.io/tags/nodejs/"/>
    
      <category term="express" scheme="http://mmrxia.github.io/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>16年后web开发趋势思考</title>
    <link href="http://mmrxia.github.io/2016/06/27/16%E5%B9%B4%E5%90%8Eweb%E5%BC%80%E5%8F%91%E8%B6%8B%E5%8A%BF%E6%80%9D%E8%80%83/"/>
    <id>http://mmrxia.github.io/2016/06/27/16年后web开发趋势思考/</id>
    <published>2016-06-27T07:21:44.000Z</published>
    <updated>2017-01-10T03:57:08.765Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;Rewriting your Frontend Framework every six week !!!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;近二年的进展&quot;&gt;&lt;a href=&quot;#近二年的进展&quot; class=&quot;headerlink&quot; title=&quot;近二年的进展&quot;&gt;&lt;/a&gt;近二年的进展&lt;/h3&gt;&lt;p&gt;前端发展日新月异, 甚至有一句戏言: “每六星期重写一个前端框架”, 行业是像火箭一样, 但我们前端工程师该何去何从呢?&lt;br&gt;我们来谈谈这个问题.&lt;br&gt;先来看看最流行的几项技术栈:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;AngularJS&lt;br&gt;首创的双向数据绑定, 以及内置的模块注入, 以及组件化的支持, 种种优势, 使得它迅速发展起来. 在 2014-2015 年, 有调查显示, 在使用了前端框架的项目, 有 50% 以上采用了 AngularJS. 但到底值不值我们继续学习, 我们再接下来看.&lt;br&gt;项目地址: &lt;a href=&quot;https://angularjs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;EmberJS&lt;br&gt;受 Rails 全栈框架的启发, EmberJS 逐步发展成前端领域的另一个 “Rails”, 成为另一个独特的选择, 理论上, 你选择了 EmberJS, 就选择了一个完整稳定的生态, 不用再折腾的轮子. EmberJS 不仅全面支持模块化, MVC, 也实现了类似 AngularJS 的双向绑定( 当然原理不同 ), 甚至还做到了内置的打包和发布应用功能. 总而言之, 它是一个十分全面的前端框架. 事实上, 如果说 AngularJS 是当前短暂的前端史的一个高峰, 它就是另一个高峰. 但最近, 人气有一定的下降, 原因何在, 我们再分解.&lt;br&gt;项目地址: &lt;a href=&quot;http://emberjs.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ReactJS&lt;br&gt;ReactJS 自发布之始, 就人气很高, 它是第一个采用虚拟节点( virtual dom )技术的框架, 通过这个技术点, 它独创性地整合了函数性编程的理念, 采用单向数据流来设计 dom 渲染与比对, 使得它轻量和灵活, 事实上, 它本身只专注于如何渲染 UI, 也不与 AngularJS 和 EmberJS 有冲突. 换言之, 你可以将它整合到其他框架中.&lt;br&gt;随着 ReactNative 和 Redux 方案的出现, ReactJS 重新回到前端的浪尖, 因为其简洁优雅的实现和对 Native APP 的冲击, 又一次成为新的弄潮儿.&lt;br&gt;但以后会怎么样, 谁也不知道, 但我也会再给一些解读.&lt;br&gt;项目地址: &lt;a href=&quot;https://facebook.github.io/react/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;流行不一定是发展最快, 我们再来看看近二年发展最快的几项前端技术栈:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ReactJS&lt;br&gt;上文已经提到, React 由于本身的简洁性和对组件化专注的实现, 一直没有被新的 ES6 标准和前端思潮落下, 它几乎不受 ES6 的影响, 以及前沿性的支持 native app 开发( 通过 ReactNative ), 所以一直发展趋势良好.&lt;br&gt;而 AngularJS 则不一样, 由于 ES6 的发布, 使得它的依赖注入特性成为鸡肋, 以及 AngularJS 第一版对组件化支持的蹩脚实现( 能支持是一回事, 好用是另一回事 ), 而组件化则学习成本过高, 过于复杂, 所以 AngularJS 决定推翻设计重新开发第二版, 而第二版过于激进的采用 Typescript, 完全不兼容的第一版的设计, 以及各种魔法的应用, 使得它离前端越走越远.   &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;VueJS&lt;br&gt;VueJS 是近二年的新秀, 它起步之初, 只是一个简化版的类似于 AngularJS 双向绑定的实现的研究( 当然原理并不同 ). 但其理念与 ReactJS 相近, 只是专注于实现数据绑定, 模块化与组件化, 所以足够的简单灵活.&lt;br&gt;随着生态的快速发展, VueJS 正好接了 AngularJS 第一版的班, 又改良了 AngularJS 的错误设计( 事后来看, 依赖注入与组件化两部分是比较失败的设计 ), 整体发展迅速, 逐步成为后起之秀.&lt;br&gt;项目地址: &lt;a href=&quot;http://vuejs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MeteorJS&lt;br&gt;MeteorJS 本不适合与上述几个前端框架比较, 因为它实际是一个全栈框架, 更像 Rails 这种角色, 但由于它是纯 Javascript 的方案, 所以还是放在这里.&lt;br&gt;如果说上述前端框架都是解决前端工程化的产物, 那 MeteorJS 是一个颠覆思维的 web 开发框架, 它将Javascript 同构技术应用到极端, 再整合 websocket 进行实时数据通知与热代码更新, 不同于前后端分离的理念, 它在开发者角度完全没有前后端的概念, API 既在前端又在后端, 再加它全生态的支持( 移动 app 支持, 应用发布), 也是一个全新的视角, 由于它发展速度极快, 所以列在这里.&lt;br&gt;项目地址: &lt;a href=&quot;https://www.meteor.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;各大框架都在迅速发展中, 它们有几个共性的发展方向:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ES6 支持&lt;br&gt;每一次 Javascript 的新标准发布, 都是各大框架更新的好机会, 所以 ES6 是肯定得到各大框架的良好支持, 建议大家一定要学好.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;web 组件化&lt;br&gt;毋庸置疑, 组件化是现代前端工程化中极为重要的特性, 甚至 google 还专门出了 Polymer 这个只做组件化实现的框架. 所以每一个够格的前端框架都非常重度支持它. 同时, 组件化也将作为 w3c 标准予于定义, 所以前端框架仍将不留余力地改进与标准的兼容.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Server-side Render&lt;br&gt;服务端渲染技术是 2016 年才开始火的概念, 它与传统的后端渲染不同, 为了解决前端框架第一次加载慢的问题, 以及 SEO 问题, 而提出的解决方案. 之前有 prerender, 现在各大框架都在尝试在内部集成并支持它. 但我个人觉得, 带来的问题远比解决的问题更多, 比如要求我们开发的时候有更多的限制.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;App Render&lt;br&gt;现在有一种大前端的概念, 可以理解为 web 前端对 App 开发的支持, 包括 Ionic ( 基于 AngularJS ), React Native( 基于 React 理念 ), Meteor 都是针对 App 开发的痛点而生.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分析了众多目前最流行的前端框架, 大家可能越来越胡涂了:&lt;br&gt;到底谁才是最值得我们去投入的技术呢?&lt;br&gt;接下来, 我们去掉一堆术语, 来从前端的定义本质来看它的发展. &lt;/p&gt;
&lt;h3 id=&quot;近二年本质的演进是什么&quot;&gt;&lt;a href=&quot;#近二年本质的演进是什么&quot; class=&quot;headerlink&quot; title=&quot;近二年本质的演进是什么&quot;&gt;&lt;/a&gt;近二年本质的演进是什么&lt;/h3&gt;&lt;p&gt;前端就是面向用户这一端的技术, 然而, 随着时代的发展:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户体验要求越来越高( 加载速度快, 响应快, 无闪烁 )&lt;/li&gt;
&lt;li&gt;前端需求越来越多&lt;/li&gt;
&lt;li&gt;前端代码越来越庞大&lt;/li&gt;
&lt;li&gt;移动端快速发展对 h5 前端的需求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而 jQuery, ProtoypeJS 等只解决了 Javascript 工具库的问题, 但工程化需求无好的解决方案.&lt;br&gt;前端工程化迫在眉捷. 而且有以下要求:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最好是纯 Javascript 方案&lt;/li&gt;
&lt;li&gt;支持模块化&lt;/li&gt;
&lt;li&gt;业务代码与框架代码分离&lt;/li&gt;
&lt;li&gt;可测性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是, 产生了几种不同的演进方案.&lt;br&gt;后端渲染技术:&lt;br&gt;ajax -&amp;gt; pjax -&amp;gt; sjr ( 需要服务端提供支持 )&lt;br&gt;后端渲染技术很快就发展到顶了. 但技术理解还是足够简单的. 我们还是回到前端框架上.&lt;br&gt;NodeJS, AMD(CMD), ES6 的出现, 使得组织起一个前端框架成为现实. 于是乎, 百团大战, 出现了上面众多框架混战的画面.&lt;br&gt;无论是 AngularJS, EmberJS, ReactJS, VueJS 都是围绕着这几点进行的不同的尝试.&lt;br&gt;但结果如何, 我们站在一个更高的高度重新思考 web 开发.      &lt;/p&gt;
&lt;h3 id=&quot;真正的用户市场需要什么&quot;&gt;&lt;a href=&quot;#真正的用户市场需要什么&quot; class=&quot;headerlink&quot; title=&quot;真正的用户市场需要什么&quot;&gt;&lt;/a&gt;真正的用户市场需要什么&lt;/h3&gt;&lt;p&gt;对用户   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更快的响应速度&lt;/li&gt;
&lt;li&gt;更好的体验&lt;br&gt;对开发者&lt;/li&gt;
&lt;li&gt;更快的开发速度&lt;/li&gt;
&lt;li&gt;更好的可维护性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再次思考, 我们要不要前后端分离? 哪些前端框架更满足我们以上的条件?&lt;br&gt;作为 Rails 工程师, 我也一直在思考一个问题: Rails 是否在前端上走上了绝路?&lt;br&gt;对于不熟悉 Rails 的朋友, 我还是简单回顾下 Rails 的前端是什么:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jQuery&lt;/li&gt;
&lt;li&gt;UJS&lt;/li&gt;
&lt;li&gt;Assets pipeline&lt;/li&gt;
&lt;li&gt;SJR( 服务端 JS 生成技术 )&lt;/li&gt;
&lt;li&gt;Turoblinks( 一种极小成本实现的单页效果的技术 )&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相比 php, java, python 等语言下的传统 web 框架来说, Rails 的前端技术还是非常丰富的.&lt;br&gt;关于各个框架我列了一个分数比较, 10 分为满分, 每个列会加在一起算成一个总分.&lt;br&gt; &lt;img src=&quot;http://7xth8v.com2.z0.glb.qiniucdn.com/image/n-web-score-2016.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上表可以看出:&lt;br&gt;Rails 这类的全栈框架特点有&lt;/p&gt;
&lt;p&gt;优势:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发效率极高&lt;/li&gt;
&lt;li&gt;通过 Turoblinks 技术, 体验也不错.&lt;/li&gt;
&lt;li&gt;也能支持混合应用开发&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前端代码可维护差&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ReactJS 学习成本较低, 通过 webpack 与 npm 的配合, 能够达到不错的可维护性, 但开发成本偏高, 这也是组件化的缺点之一.&lt;br&gt;而 EmberJS 学习门槛过高, 而且 EmberJS 发展也比较迅速, 不利于学习掌握, 相对而言, 总分也不会太高.&lt;br&gt;MeteorJS 也被我列在这里, 总分最低, 所以仍然不推荐学习, 除非你的应用属于实时应用.&lt;br&gt;我们再重新思考组件化, 组件化优势在于接口清晰, 可维护性高, 但开发成本是比较高的, 前端属于工程而不是科学, 所以, 我觉得组件化是对的, 但不要过于极端把所有的 dom 都组件化.&lt;br&gt;而且, 组件化也对现有的基础技术栈进行了破坏.&lt;br&gt;通过以上的分析, 我们基本上了解了现有技术栈的情况. 那我们该继续学什么? 这才是本文的重点.&lt;br&gt;所有的一切, 都是围绕着组件化, 可维护, 高效开发, 移动支持而生, 而它们的核心都是还是最基础的东西:     &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Javascript ( ES6, NodeJS )&lt;/li&gt;
&lt;li&gt;HTML&lt;/li&gt;
&lt;li&gt;CSS&lt;/li&gt;
&lt;li&gt;API&lt;br&gt;一句话, 还是应该先把基础打好.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基础技术栈&quot;&gt;&lt;a href=&quot;#基础技术栈&quot; class=&quot;headerlink&quot; title=&quot;基础技术栈&quot;&gt;&lt;/a&gt;基础技术栈&lt;/h3&gt;&lt;p&gt;应当好好掌握的内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Javascript 语言( 直接看 ES6 相关的 )&lt;/li&gt;
&lt;li&gt;NodeJS 生态( npm 与相关的包 )&lt;/li&gt;
&lt;li&gt;webpack ( 了解如何打包, 发布 )&lt;/li&gt;
&lt;li&gt;HTML ( 尤其是 form 标签, 以及 HTML5 的内容 )&lt;/li&gt;
&lt;li&gt;CSS ( 学习盒模型, 最新的 flex 布局, 以及 CSS3 )&lt;/li&gt;
&lt;li&gt;API ( 掌握如何开发 API )&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你必须是前端工程师, 同时又是后端工程师, 才能真正摸清晰当下时代的发展, 成为弄潮儿!&lt;/p&gt;
&lt;h3 id=&quot;预测未来&quot;&gt;&lt;a href=&quot;#预测未来&quot; class=&quot;headerlink&quot; title=&quot;预测未来&quot;&gt;&lt;/a&gt;预测未来&lt;/h3&gt;&lt;p&gt;首先, 我在 2014 年分析 web 开发的文中提到的 gulp, grunt 都已经成为过去式了. Bower 也已经有点不合事宜了.&lt;br&gt;目前前端构建建议使用 webpack 和 npm 足够, 不需要更多的工具链, 应该越简单, 越顺手!&lt;br&gt;列几个关心的问题尝试预测一下.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NodeJS 做后台开发怎么样 ?&lt;br&gt;NodeJS 已经是前端框架的一部分, 是极为成功的, 但对于 NodeJS 做后台开发说实在的, 它能够占一定的市场, 但将会非常少( 低于 5% ). 所以做 php 或 java 开发的朋友倒不用担心, 但如果只是搬砖写简单 API 的话, 就有危险了.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rails 还行不行 ?&lt;br&gt;Rails 已经到了一定的顶点, 不可能再突破性增长, 但仍然是目前最为顺手的 web 开发框架, 它的前端解决方案目前仍有不错的体验与开发效率, 但可维护性比较差, 如果是我的话, 我会带领团队采用混合式的开发, 但现在不会是引入 AngularJS 而会是 VueJS.&lt;br&gt;但 Rails 已经到达它的极限点了, 而众多前端框架才刚刚开始.( 虽然拿 Rails 与前端框架比较不够合适 )    &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AngularJS 还是 ReactJS ?&lt;br&gt;很简单, 建议直接上手 VueJS.&lt;br&gt;AnguarJS 第一版是个好的框架, 但 Angular2 并不是, 所以还不如直接学习 VueJS.&lt;br&gt;ReactJS 是个不错的框架, 但绝不是终点. VueJS 与 ReactJS 在实现上各有利弊. 两者可以择其一学之.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MeteorJS 值不值得学习 ?&lt;br&gt;我的建议是不值得, 因为它一开始就走在错误的道路上, 注定后面无路可走.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;前端会取代 Native APP 开发么?&lt;br&gt;一定会的, 未来 3 年后, 至少有 70% 左右的 APP 会用前端开发方案, 比如使用类似于 Ionic 或 Meteor 这样的框架.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;重新思考-web-开发&quot;&gt;&lt;a href=&quot;#重新思考-web-开发&quot; class=&quot;headerlink&quot; title=&quot;重新思考 web 开发&quot;&gt;&lt;/a&gt;重新思考 web 开发&lt;/h3&gt;&lt;p&gt;真正能长远的前端技术一定是简单的, 专注的, 比如 jQuery. 但目前几个框架都或多或少存在着问题.&lt;br&gt;ReactJS 不是表面那么简单, 而 AngularJS 更加复杂.&lt;br&gt;是否有更简单有效的解决它们的问题, 则能够成为下一代 web 前端框架.    &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Rewriting your Frontend Framework every six week !!!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;近二年的进展&quot;&gt;&lt;a href=&quot;#近二年的进展&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
    
      <category term="随笔" scheme="http://mmrxia.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>git 常用命令汇总</title>
    <link href="http://mmrxia.github.io/2016/06/03/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
    <id>http://mmrxia.github.io/2016/06/03/git-常用命令汇总/</id>
    <published>2016-06-03T06:26:42.000Z</published>
    <updated>2016-07-04T07:53:36.601Z</updated>
    
    <content type="html">&lt;h3 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h3&gt;&lt;p&gt;创建账户：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;git config -global user.name &amp;quot;Your name&amp;quot;
git config -global user.email &amp;quot;you@example.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从仓库克隆到提交文件通用流程：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt; git clone git@github.com:mmrxia/project-name.git
 git add .
 git commit -m &amp;#39;update file&amp;#39;
 git push -u origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看当前git仓库文件状态：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;git status
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;其他技巧&quot;&gt;&lt;a href=&quot;#其他技巧&quot; class=&quot;headerlink&quot; title=&quot;其他技巧&quot;&gt;&lt;/a&gt;其他技巧&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;新建.gitignore文件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;touch .gitignore
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查看文件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;vim README.md
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查看提交历史记录&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;git log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们常用 &lt;code&gt;-p&lt;/code&gt; 选项展开显示每次提交的内容差异，用 &lt;code&gt;-2&lt;/code&gt; 则仅显示最近的两次更新。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h3&gt;&lt;p&gt;创建账户：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;git config -global u
    
    </summary>
    
    
      <category term="git" scheme="http://mmrxia.github.io/tags/git/"/>
    
      <category term="bash" scheme="http://mmrxia.github.io/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>nodejs实践知识点汇总</title>
    <link href="http://mmrxia.github.io/2016/06/03/nodejs%E5%AE%9E%E8%B7%B5%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <id>http://mmrxia.github.io/2016/06/03/nodejs实践知识点汇总/</id>
    <published>2016-06-03T02:21:03.000Z</published>
    <updated>2016-07-20T09:45:37.353Z</updated>
    
    <content type="html">&lt;h3 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h3&gt;&lt;p&gt;1 . &lt;strong&gt;npm -v、node -v&lt;/strong&gt;： 查看npm或nodejs版本。示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;npm -v
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2 . &lt;strong&gt;npm init&lt;/strong&gt;： 会在当前目录引导创建一个package.json文件，包括名称、版本、作者这些信息等。示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;npm init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3 . &lt;strong&gt;npm install&lt;/strong&gt;： 根据package.json文件自动安装需要的模块。示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;npm install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;–save 命令，安装模块时，写入到package.json的依赖字段（dependencies）中。&lt;br&gt;使用&lt;code&gt;--save-dev&lt;/code&gt;命令，可写入到开发依赖字段（devDependencies）中。&lt;br&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;npm install express --save
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;-g 将包安装到全局环境中，如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;npm install express -g
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4 . &lt;strong&gt;npm uninstall &lt;name&gt;&lt;/name&gt;&lt;/strong&gt;： 卸载node模块&lt;/p&gt;
&lt;p&gt;5 . &lt;strong&gt;npm update &lt;name&gt;&lt;/name&gt;&lt;/strong&gt;： 更新node模块&lt;/p&gt;
&lt;p&gt;6 . 其他&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;npm root：查看当前包的安装路径&lt;/li&gt;
&lt;li&gt;npm root -g：查看全局的包的安装路径&lt;/li&gt;
&lt;li&gt;npm outdated：检查包是否已经过时，此命令会列出所有已经过时的包，可以及时进行包的更新&lt;/li&gt;
&lt;li&gt;npm list：查看当前目录下已安装的node包&lt;/li&gt;
&lt;li&gt;npm help：查看帮助命令&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h3&gt;&lt;p&gt;1 . &lt;strong&gt;npm -v、node -v&lt;/strong&gt;： 查看npm或nodejs版本。示例：&lt;/p&gt;
&lt;p
    
    </summary>
    
    
      <category term="nodejs" scheme="http://mmrxia.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>图片等比压缩居中显示</title>
    <link href="http://mmrxia.github.io/2016/06/02/%E5%9B%BE%E7%89%87%E7%AD%89%E6%AF%94%E5%8E%8B%E7%BC%A9%E5%B1%85%E4%B8%AD%E6%98%BE%E7%A4%BA/"/>
    <id>http://mmrxia.github.io/2016/06/02/图片等比压缩居中显示/</id>
    <published>2016-06-02T08:16:21.000Z</published>
    <updated>2017-01-10T04:08:09.718Z</updated>
    
    <content type="html">&lt;h3 id=&quot;1-需求&quot;&gt;&lt;a href=&quot;#1-需求&quot; class=&quot;headerlink&quot; title=&quot;1.需求&quot;&gt;&lt;/a&gt;1.需求&lt;/h3&gt;&lt;p&gt;某些场景如幻灯片切换展示，个人资料头像展示等。&lt;br&gt;如果图片所在的外容器具有一定的宽高，而图片却又是不定宽高时，就需要我们在显示时需要注意几点：&lt;br&gt;1、图片不能被拉伸变形&lt;br&gt;2、尽量友好的显示图片内容&lt;/p&gt;
&lt;h3 id=&quot;2-逻辑分析&quot;&gt;&lt;a href=&quot;#2-逻辑分析&quot; class=&quot;headerlink&quot; title=&quot;2.逻辑分析&quot;&gt;&lt;/a&gt;2.逻辑分析&lt;/h3&gt;&lt;p&gt;基于上面的需求，这就需要前端人员在控制显示的时候，尤其是一些图片尺寸过大，超出了外容器的图片，需要等比压缩居中显示；&lt;br&gt;对于尺寸太小，宽高都达不到外容器的范围的图片，最好也能居中显示，这样能保证最佳的显示效果。&lt;/p&gt;
&lt;p&gt;那么这样才能做到等比压缩还居中显示呢？我们先看下图。&lt;/p&gt;
&lt;p&gt;下面是一个宽高分别为200和100像素的外容器（块元素）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xth8v.com2.z0.glb.qiniucdn.com/image/n_img_radio_commpress_01.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;内部有一张图片： 高200px、宽250px&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xth8v.com2.z0.glb.qiniucdn.com/image/n_img_radio_commpress_02.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;经过等比压缩后，应该如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xth8v.com2.z0.glb.qiniucdn.com/image/n_img_radio_commpress_03.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;最终图片设置的宽高分别为200和160像素，这个是怎么算来的呢？&lt;/p&gt;
&lt;p&gt;首先，我们分别取到宽高的最大压缩比ratio，也就是外容器像素值除以图片像素值。示例中分别是：&lt;br&gt;宽： 200/250 = 0.8&lt;br&gt;高： 100/200 = 0.5&lt;/p&gt;
&lt;p&gt;所以我们取的max值是0.8，这样就能保证最终在计算的时候在宽度上完全撑满，即 250 * 0.8 = 200。&lt;/p&gt;
&lt;p&gt;有了这个缩放比，自然就能计算出图片压缩后的高度，即 200 * 0.8 = 160。&lt;/p&gt;
&lt;p&gt;确定了图片的宽高，接下来就需要图片居中显示，这时候只需要在外容器设置负的margin值就可以了，数值就是图片和容器差值的一半。&lt;/p&gt;
&lt;p&gt;注意：这里涉及到一个问题，如果缩放比 ratio &amp;gt; 1， 也就是图片的宽高都比外容器值小怎么办？&lt;br&gt;这种情况很简单，只需要保持图片在容器中居中就可以了，不改变原图片的尺寸。&lt;/p&gt;
&lt;p&gt;核心代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/*外容器宽高*/
var wrapper = {
    width: me.parent().width(),
    height: me.parent().height()
};

var size = {}; //最终要设置的宽高

if (img.width &amp;gt; 0 &amp;amp;&amp;amp; img.height &amp;gt; 0) {
    var ratio_w = wrapper.width / img.width;
    var ratio_h = wrapper.height / img.height;

    var ratio = Math.max.apply(null, [ratio_w, ratio_h]);   //取比例最大值

    if (ratio &amp;gt; 1) {
        size.width = img.width;
        size.height = img.height;
    } else {
        size.width = img.width * ratio;
        size.height = img.height * ratio;
    }

    /*设置样式*/
    me.css({
        &amp;quot;width&amp;quot;: size.width + &amp;#39;px&amp;#39;,
        &amp;quot;height&amp;quot;: size.height + &amp;#39;px&amp;#39;,
        &amp;quot;margin-top&amp;quot;: (wrapper.height - size.height) / 2 + &amp;#39;px&amp;#39;,
        &amp;quot;margin-left&amp;quot;: (wrapper.width - size.width) / 2 + &amp;#39;px&amp;#39;
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;3-调用方式：&quot;&gt;&lt;a href=&quot;#3-调用方式：&quot; class=&quot;headerlink&quot; title=&quot;3.调用方式：&quot;&gt;&lt;/a&gt;3.调用方式：&lt;/h3&gt;&lt;p&gt;结合以上逻辑，可以将代码进行封装，做成jquery插件的形式以供调用。&lt;br&gt;附上链接：&lt;br&gt;&lt;a href=&quot;https://github.com/mmrxia/lab/blob/master/examples/img-radio-compress/img-ratio-compress.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/mmrxia/lab/blob/master/examples/img-radio-compress/img-ratio-compress.js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HTML:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div class=&amp;quot;img-wrapper&amp;quot;&amp;gt;
    &amp;lt;img class=&amp;quot;img&amp;quot; src=&amp;quot;image/tmp_01.jpg&amp;quot; alt=&amp;quot;demo1&amp;quot;/&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;quot;img-wrapper&amp;quot;&amp;gt;
    &amp;lt;img class=&amp;quot;img&amp;quot; src=&amp;quot;image/tmp_02.jpg&amp;quot; alt=&amp;quot;demo2&amp;quot;/&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;quot;img-wrapper&amp;quot;&amp;gt;
    &amp;lt;img class=&amp;quot;img&amp;quot; src=&amp;quot;image/tmp_03.png&amp;quot; alt=&amp;quot;demo3&amp;quot;/&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;quot;img-wrapper&amp;quot;&amp;gt;
    &amp;lt;img class=&amp;quot;img&amp;quot; src=&amp;quot;image/tmp_04.png&amp;quot; alt=&amp;quot;demo4&amp;quot;/&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CSS:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.img-wrapper{border: 1px dashed #2F9DC2;height: 100px;overflow: hidden;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JS:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;lt;script src=&amp;quot;../../static/js/lib/jquery.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;img-ratio-compress.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    $(&amp;#39;.img&amp;#39;).ratioCompress({resize:true});
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;4-效果展示：&quot;&gt;&lt;a href=&quot;#4-效果展示：&quot; class=&quot;headerlink&quot; title=&quot;4.效果展示：&quot;&gt;&lt;/a&gt;4.效果展示：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://rawgit.com/mmrxia/lab/master/examples/img-radio-compress/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点我查看示例&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xth8v.com2.z0.glb.qiniucdn.com/image/n_img_radio_commpress.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;（demo中设置了随窗口变化图片位置自适应，可以缩放浏览器尺寸或者F12调整为移动端模式查看。）&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-需求&quot;&gt;&lt;a href=&quot;#1-需求&quot; class=&quot;headerlink&quot; title=&quot;1.需求&quot;&gt;&lt;/a&gt;1.需求&lt;/h3&gt;&lt;p&gt;某些场景如幻灯片切换展示，个人资料头像展示等。&lt;br&gt;如果图片所在的外容器具有一定的宽高，而图片却又是不定宽高时，就需要我们
    
    </summary>
    
    
      <category term="随笔" scheme="http://mmrxia.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="javascript" scheme="http://mmrxia.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>js 数组复制操作</title>
    <link href="http://mmrxia.github.io/2016/05/22/js-%E6%95%B0%E7%BB%84%E5%A4%8D%E5%88%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://mmrxia.github.io/2016/05/22/js-数组复制操作/</id>
    <published>2016-05-22T03:31:55.000Z</published>
    <updated>2016-05-22T03:45:23.699Z</updated>
    
    <content type="html">&lt;p&gt;js中数组和对象，使用“=”号赋值的时候，由于是引用类型，只是改变了引用对象的指针指向，改变值时会引起连锁反应。&lt;br&gt;简单效果如下：&lt;br&gt;&lt;img src=&quot;http://7xth8v.com2.z0.glb.qiniucdn.com/image/arr1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;避免指针指向的方法主要有一下几种：&lt;br&gt;（1）使用slice()方法。slice() 函数可从已有的数组中返回选定的元素；语法为：arr.slice(start,end);&lt;br&gt;slice()函数将会返回一个新的数组对象，所以使用slice(0)或slice()就可以实现数组的复制。如下：&lt;br&gt;&lt;img src=&quot;http://7xth8v.com2.z0.glb.qiniucdn.com/image/arr2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;（2）使用concat()方法。语法为：arr.concat(arr1,arr2,arr3,…,arrn);&lt;br&gt;concat()用于多个数组的合并，但是返回的结果是一个新的数组，而不再引用用于合并的任何一个数组。如下：&lt;br&gt;&lt;img src=&quot;http://7xth8v.com2.z0.glb.qiniucdn.com/image/arr3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;（3）笨方法：使用for循环；原理就不说了，直接上代码：&lt;br&gt;&lt;img src=&quot;http://7xth8v.com2.z0.glb.qiniucdn.com/image/arr4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;（4）使用jQuery的extend或merge方法：&lt;br&gt;$.extend 功能很强大，可以合并数组，对象！具体可参见jQuery api。&lt;br&gt;&lt;img src=&quot;http://7xth8v.com2.z0.glb.qiniucdn.com/image/arr5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;$.merge 只能合并一维数组，且一次只能合并2个，个人觉得没有concat方法强大。&lt;br&gt;&lt;img src=&quot;http://7xth8v.com2.z0.glb.qiniucdn.com/image/arr6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其他参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.html-js.com/article/1589&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;javascript 原始类型和引用类型&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;js中数组和对象，使用“=”号赋值的时候，由于是引用类型，只是改变了引用对象的指针指向，改变值时会引起连锁反应。&lt;br&gt;简单效果如下：&lt;br&gt;&lt;img src=&quot;http://7xth8v.com2.z0.glb.qiniucdn.com/image/arr1.png&quot; a
    
    </summary>
    
    
      <category term="js" scheme="http://mmrxia.github.io/tags/js/"/>
    
      <category term="数组" scheme="http://mmrxia.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>真假美猴王死的到底是谁</title>
    <link href="http://mmrxia.github.io/2016/05/17/%E7%9C%9F%E5%81%87%E7%BE%8E%E7%8C%B4%E7%8E%8B%E6%AD%BB%E7%9A%84%E5%88%B0%E5%BA%95%E6%98%AF%E8%B0%81/"/>
    <id>http://mmrxia.github.io/2016/05/17/真假美猴王死的到底是谁/</id>
    <published>2016-05-17T07:18:14.000Z</published>
    <updated>2016-05-22T03:28:21.650Z</updated>
    
    <content type="html">&lt;p&gt;看《西游记》第五十七回，说是“六耳猕猴”化作孙悟空的摸样，伤了唐僧，后又和孙悟空大打出手。。。这位假孙悟空，实力不用多说了吧，和真孙悟空一般无二，大战孙悟空，闹到上天入地下海。在唐僧那：念紧箍咒，两个都喊疼，自然看不出哪个真假；到天宫：拖塔天王拿照妖镜照，也看不出；又到观音那：观音也看不出。最后到幽冥处阎罗那，经“谛听”听过之后，“谛听”却说：“我看出来了，却不敢说”。。。最后还是如来老佛爷道出六耳真身并用金钵盂罩住，才被孙悟空一棍子打死。&lt;/p&gt;
&lt;p&gt;这是整个故事，看似很简单，很完整，不过，却有一个天大的伏笔。&lt;br&gt;咱现在先假设一下，被打死的那个是悟空，活的那个是六耳猕猴。我这不是胡说的，是有道理的，一下是我的一些理论：&lt;/p&gt;
&lt;p&gt;一、六耳猕猴和孙悟空一模一样，谁也看不出来，就算如来骗大家说六耳猕猴就是真的悟空，而这个谎言，也只有如来知道真相，真正的孙悟空，他只是个哑巴吃黄连。&lt;/p&gt;
&lt;p&gt;二、六耳猕猴很有可能是如来安排的一个托儿，大家都知道，孙悟空是个叛逆者，而如来是西天的最高统治者，哪个统治者会允许一个叛逆者生活在这个世界上？再加上，大家都知道的，孙悟空一向不敬重如来。所以如来会想方设法消灭孙悟空。当然不能明白着把孙悟空直接杀了，所以才出现一个一模一样的悟空，杀孙悟空于无形。而这个也是有证据的。&lt;/p&gt;
&lt;p&gt;1：比如在地府里面，经“谛听”听过之后，“谛听”明知道真假，却不敢说，其想法肯定不是怕两个悟空大闹地府，而是这个六耳猕猴有很强大的后台，那就是如来。所以，“谛听”自然不敢说出真相。&lt;br&gt;2：其次，可以证明“谛听”不是真正的怕二猴大闹地府的原因还有一个，大家都知道，当时在场的还有一个法力很强的人，当然，不是阎罗，阎罗和这人比，是天壤之别，这人就是“地藏王菩萨”，“地藏王菩萨”何许人啊，是佛教四大菩萨之首，与观音、文殊、普贤齐名，可见此人厉害。既然有这么厉害的佛门中人在此，难道“谛听”还担心这两泼猴会闹了地府不成？&lt;/p&gt;
&lt;p&gt;三、大家都知道，孙悟空的师傅是“菩提祖师”，“菩提祖师”何许人？《封神榜》上有个线索，就是“混鲲祖师”的徒弟，而恰巧，“混鲲祖师”弟子无数，而让他最得意的两大弟子，便是如来(又名“接引道人“）和菩提祖师(又名“准提道人“）。。。&lt;br&gt;一个大胆的想法，既然两位圣人是同门师兄，且《封神榜》中曾经略提到过，说二弟子准提道人（也就是说菩提祖师），其间不知与接引道人（如来）间发生了什么变故，却神秘消失，从此再不闻踪迹。这是一个很有力度的线索，证明二人之间有矛盾。&lt;br&gt;然后再回到孙悟空，而孙悟空又恰巧是菩提祖师的徒弟，如来见到昔日仇人的徒弟，又有翻天覆地之本领，不想方设法除之更待何时？&lt;/p&gt;
&lt;p&gt;四、西游记上讲述了孙悟空在菩提祖师处学了一身法术之后神通广大。而恰巧，和冒充孙悟空的六耳猕猴却也拥有和孙悟空一模一样的法术，甚至连长相声音装的都完全一样？这是巧合吗？大家都知道孙悟空只学个72变和筋斗云都学了几年，六耳猕猴不可能不学就天生就有这本领吧？肯定有和孙悟空同门出处的高人指点，自然菩提祖师不会在此之列，因为老人家既然有了孙悟空这样有情有义的徒弟，难道还要在造出一个六耳猕猴来和孙悟空对着干吗？所以，指点六耳猕猴来和孙悟空对着干的只有一个人，那就是菩提祖师的同门师兄，如来。&lt;/p&gt;
&lt;p&gt;五、再回到《西游记》第五十八回，话说，二猴打闹到如来这里要如来辩个真假。。。如来却对众佛说：“我观假悟空乃六耳猕猴也。此猴若立一处，能知千里外之事，凡人说话，亦能知之，故此善聆音，能察理，知前后，万物皆明。与真悟空同象同音者，六耳猕猴也”。&lt;br&gt;经如来这么一说，众佛知道了，原来天下众生中还有这么一个叫“六耳猕猴”，而西游记的读者们却忽略了如来的这一句话里的一个线索：如来说的意思是，此猴和孙悟空不同，孙悟空是“灵明石猴”，同变化，识天时，知地利，移星换斗。而六耳猕猴是“知前后，万物皆明”。很厉害吧，竟然知道过去和未来发生的一切事。这是一个很大的破绽！！！既然六耳猕猴知道他的未来将要被如来制服，被孙悟空一棒打死，他为什么还要和孙悟空到如来处辩真假，那不是自讨苦吃吗？所以只有一个可能，如来早都把事情安排的妥当，在他的说明下，让众佛都以为六耳猕猴就是“真悟空”，而真正的悟空，却被当成了“六耳猕猴”被如来制服，然后被一棒打死。&lt;br&gt;而当“六耳猕猴”被打死之后，一向慈悲为怀的如来却没一点怪罪之意，只是合并双手，道了句：“善哉，善哉！”。。。大家都知道，以如来的本领，当“孙悟空”想要一棒子打死“六耳猕猴”的话，如来想要出手相救，是何等的容易，可见，如来本意就是想让他死。而“六耳猕猴”本无太大的罪过，也就是和孙悟空大闹了下，一向慈悲的如来何必要让他死呢，想当年孙悟空闹了龙宫，闹了地府，闹了天宫，如来都还没让他死呢，怎么“六耳猕猴”这么一个小小的错误就要必须死呢？这里面肯定有隐情。所以那个隐情就是，如来是真正想处死的是孙悟空，而被一棒子打死的，却恰好是真正的孙悟空。&lt;/p&gt;
&lt;p&gt;六、大家会以为，孙悟空不是已经被生死薄删除了名字，又吃了那么多蟠桃和仙丹，早都可以长生不老，也有了金刚不坏之躯，怎么能这么容易就给打死了呢。这个也许就只有如来自己知道了，大家可以想象，如来既然当年有能力把孙悟空压打五行山，现在虽然杀不了孙悟空，当然也肯定有办法让孙悟空永远消失的活着。&lt;/p&gt;
&lt;p&gt;七、又回到孙悟空的师傅“菩提祖师”这。西游记里曾经记载，孙悟空在大闹天宫之后，惹了一大堆麻烦只好跟着唐僧西天取经，遇到困难又回去找他师傅“菩提祖师”的时候，“菩提祖师”早已不见踪影，只是和孙悟空隔空说话，并不见面。这是为什么呢？想必孙悟空用“菩提祖师”所教的本领大闹天宫之后，如来必有察觉，肯定会发现此七十二变和筋斗云正是同门法术。刚才我也说过了，菩提祖师和如来曾经因为一些矛盾，后来菩提祖师隐居了。如果如来看到孙悟空的本领后，肯定便知此本领肯定是菩提祖师所受，自然要追寻这个消失已久的仇人。所以，菩提祖师得知孙悟空大闹天宫之后，为防止不必要的麻烦，也已经消失的无影无踪。。。&lt;br&gt;而话又说回来了，菩提祖师本领并不亚于如来，这个可以从《西游记》第八回看出。。。其中有一段，如来说：“我西牛贺洲者，不贪不杀，养气潜灵，虽无上真，人人固寿”。大家注意了，如来说，“西牛贺州，虽无上真”，这恰恰说明，菩提在西牛贺洲传道能逃过如来法眼，说明菩提不比如来差。 &lt;/p&gt;
&lt;p&gt;八、大家发现没，在真假美猴王事出之前，孙悟空并不完全都听唐僧的话，甚至有时候，还闹个小矛盾，导致唐僧只好念紧箍咒，典型的一个叛逆者形象。可自从真假美猴王事出之后，孙悟空从此保护唐僧安安分分。而以此事可以看出，孙悟空前后可判若两人。不排除，孙悟空已被如来利用六耳猕猴一战中，安安静静、无人知晓的已被安排下台了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;其实还有另外一个版本，且待我慢慢道来：&lt;/p&gt;
&lt;p&gt;六耳猕猴是西游记中最奇特的一个妖怪，怎么奇特呢？我们来看一看：&lt;/p&gt;
&lt;h3 id=&quot;一、人物奇特&quot;&gt;&lt;a href=&quot;#一、人物奇特&quot; class=&quot;headerlink&quot; title=&quot;一、人物奇特&quot;&gt;&lt;/a&gt;一、人物奇特&lt;/h3&gt;&lt;p&gt;西游记主要是看孙悟空的戏，六耳猕猴这个妖怪居然敢冒充主角孙悟空，上演了一出《真假美猴王》的好戏。&lt;br&gt;按妖怪的胆量、能力与勇气大致可以分为三种：&lt;br&gt;1.怕孙悟空的妖怪根本不敢冒充孙悟空。&lt;br&gt;2.不把孙悟空放在眼里的妖怪根本不屑于冒充孙悟空。&lt;br&gt;3.和孙悟空势均力敌的妖怪，手段也颇高了，完全没有必要冒充孙悟空。&lt;br&gt;六耳猕猴这个妖怪的本事和孙悟空是一样的，他完全有能力独霸一方，干吗还要冒充孙悟空呢？因此，六耳猕猴冒充孙悟空，就显得格外的奇特。&lt;/p&gt;
&lt;h3 id=&quot;二、地点奇特&quot;&gt;&lt;a href=&quot;#二、地点奇特&quot; class=&quot;headerlink&quot; title=&quot;二、地点奇特&quot;&gt;&lt;/a&gt;二、地点奇特&lt;/h3&gt;&lt;p&gt;唐僧遇到六耳猕猴的地方，是强盗出没的山林，这里至少有三十几个以上的强盗在此地谋生活，这就说明这个山头是属于强盗的，按说不会有妖怪，若有妖怪，则强盗们根本无法生存，更不可能结成团伙，形成气候，早被妖怪吃了。&lt;br&gt;可见，六耳猕猴这个妖怪并不是本地妖怪，那他是从哪儿来的？&lt;br&gt;西游记中的妖怪无论法力大小，都有一块属于自己的地盘，厉害的妖怪管的宽一些，不厉害的妖怪地盘小点，怎么说，得有一片生存的土壤，否则，他是成不了妖的。&lt;br&gt;六耳猕猴呢？他有没有自己的地盘呢？有，在花果山，乘孙悟空不在的时候，他跑到花果山占山为王了，并且没有被其他的猴子们发觉。&lt;br&gt;可见，六耳猕猴对孙悟空的行踪及过去的经历了如指掌。&lt;/p&gt;
&lt;h3 id=&quot;三、行为奇特&quot;&gt;&lt;a href=&quot;#三、行为奇特&quot; class=&quot;headerlink&quot; title=&quot;三、行为奇特&quot;&gt;&lt;/a&gt;三、行为奇特&lt;/h3&gt;&lt;p&gt;妖怪们都有很强烈的领地感，只在自己控制的势力范围内吃人，基本上吃的都是你自己瞎了眼睛送上门来的，或是采用手段把你诱骗去的，一般不会越界行凶。许多妖怪都说过“若过了此地就不归我管”这类的话。&lt;br&gt;妖怪与妖怪之间是和谐的，没有争斗，偶尔还有聚会，我抓到一个人请你吃，你抓到一个人请我吃，大家都遵守江湖道义。不到别处去撒野，不到别人的门面上去抢生意。&lt;br&gt;而六耳猕猴，则不管这一套，他是从花果山不远万里赶来作案的！这个行为实在是太奇特了，这是其他妖怪所没有的。&lt;/p&gt;
&lt;h3 id=&quot;四、手段奇特&quot;&gt;&lt;a href=&quot;#四、手段奇特&quot; class=&quot;headerlink&quot; title=&quot;四、手段奇特&quot;&gt;&lt;/a&gt;四、手段奇特&lt;/h3&gt;&lt;p&gt;六耳猕猴作案的手段更是怪异，他不像别的妖怪那样躲在半空中，瞅准机会一阵风把唐僧掳走。&lt;br&gt;而是跪在路旁，双手捧着一杯水给唐僧喝，唐僧不喝，骂了他一顿，六耳猕猴就轮铁棒望长老脊背上砑了一下，那长老昏晕在地，不能言语，被他把两个青毡包袱，提在手中，驾筋斗云，不知去向。&lt;br&gt;六耳猕猴并没有抓唐僧，而是把唐僧打了一顿，然后抢了包裹行李，扬长而去的。没有一个妖怪是像他这样搞的。&lt;/p&gt;
&lt;h3 id=&quot;五、动机奇特&quot;&gt;&lt;a href=&quot;#五、动机奇特&quot; class=&quot;headerlink&quot; title=&quot;五、动机奇特&quot;&gt;&lt;/a&gt;五、动机奇特&lt;/h3&gt;&lt;p&gt;六耳猕猴作案的动机，也和其他妖怪不同，妖怪抓唐僧，无非是要吃唐僧肉，或是要交配，而六耳猕猴则是要自己拉一班人马去西天取经！&lt;br&gt;六耳猕猴高坐在石台之上，双手扯着通关文牒，念了从头又念，反复学习。他说：“我今熟读了牒文，我自己上西方拜佛求经，送上东土，我独成功，教那南赡部洲人立我为祖，万代传名也。”&lt;br&gt;六耳猕猴不仅冒充了孙悟空，还找了几个猴精冒充了唐三藏、猪八戒、沙僧和一匹白马，企图上西天，成佛做祖！这个妖怪简直太有创意了！&lt;/p&gt;
&lt;h3 id=&quot;六、过程奇特&quot;&gt;&lt;a href=&quot;#六、过程奇特&quot; class=&quot;headerlink&quot; title=&quot;六、过程奇特&quot;&gt;&lt;/a&gt;六、过程奇特&lt;/h3&gt;&lt;p&gt;六耳猕猴和孙悟空不仅外型一模一样，本事也是一模一样，走到哪儿，都无法分辨谁是真的谁是假的！&lt;br&gt;1.观音菩萨暗念《紧箍儿咒》，两个一齐喊疼，菩萨无计奈何。&lt;br&gt;2.李天王取照妖镜照住，镜中乃是两个孙悟空，毫发不差。玉帝亦辨不出。&lt;br&gt;3.唐僧念《紧箍儿咒》，二人一齐叫苦，唐僧也不认得真假。&lt;br&gt;4.阎罗殿的谛听可以分辨的出真假，却不敢说出来。&lt;br&gt;5.最后被如来佛辨出真假，是所有神仙都没有听说过的新物种：六耳猕猴。&lt;br&gt;6.六耳猕猴被孙悟空当场处决，打死了。&lt;/p&gt;
&lt;p&gt;以上种种疑点，实在太多，这里面就存在无法解释的问题：&lt;br&gt;1.既然阎罗殿的谛听可以分辨的出真假，却为什么不敢说出来？六耳猕猴与孙悟空的本事是一样大的，只要谛听说出哪个是假的，随便加几个人就可以帮孙悟空抓住六耳猕猴，谛听为什么不说？他怕什么？&lt;br&gt;2.既然六耳猕猴熟悉孙悟空的一切，当然就应该十分清楚如来佛祖是非常厉害的，他为什么不跑呢？还要到雷音寺去送死？这不是脑子进了水么？！&lt;br&gt;3.六耳猕猴只不过打了唐僧，既没有打死，也没有要吃唐僧肉，最多论个行凶抢劫罪，怎么说，罪不致死，为什么就把他打死了？！量刑是否过重？&lt;br&gt;4.六耳猕猴的目的是要取经，又是主动的，目标一致，如来佛应该高兴才对，这样的人才哪里找啊？把他也安排进取经的队伍，岂不是更好？&lt;br&gt;5.为什么只有如来佛一个人知道世上还存在“六耳猕猴”这一类物种？而所有的神仙包括菩萨都是闻所未闻的？难道就没一个人知道吗？&lt;br&gt;6.如果所有人都不知道有“六耳猕猴”这一类物种，那么，如来佛祖与六耳猕猴之间，究竟存在着怎样的渊源呢？&lt;/p&gt;
&lt;p&gt;六耳猕猴的下场太惨了，这个和孙悟空一样的上进青年，就这么突然之间死于非命了，可怜，可惜。&lt;br&gt;但是，这件事情的真相，真的就是这样简单么？其中究竟隐藏着怎样的内幕？&lt;br&gt;真假美猴王这一回，不知道欺骗了多少观众，死的到底是谁，先来分析分析。&lt;br&gt;其实呢，这一回中根本就没有妖怪，那个所谓的六耳猕猴并不存在。从头到尾都是孙悟空一个人捣的鬼！大家看西游记把大脑都看的僵化了，总以为孙悟空是捉妖怪的，却怎么都想不到：孙悟空也会冒充妖怪，把唐僧这个泼秃领导暴打一顿以泻私愤吧！&lt;/p&gt;
&lt;p&gt;孙悟空在这件事的起先，他是个受害者，而结果，却变成了最大的受益者，因此，孙悟空是第一嫌疑人。我们再来重新看这一幕：&lt;/p&gt;
&lt;h3 id=&quot;一、起因&quot;&gt;&lt;a href=&quot;#一、起因&quot; class=&quot;headerlink&quot; title=&quot;一、起因&quot;&gt;&lt;/a&gt;一、起因&lt;/h3&gt;&lt;p&gt;孙悟空打死了两个强盗，唐僧念经超度强盗的亡灵：拜惟好汉，我以好话，尔等不听，却遭行者，棍下伤身。你到森罗殿下兴词，他姓孙，我姓陈，各居异姓。冤有头，债有主，切莫告我取经僧人。&lt;br&gt;八戒笑道：“师父推了干净，他打时却也没有我们两个。”三藏又祷告道：“好汉告状，只告行者，也不干八戒、沙僧之事。”&lt;br&gt;孙悟空道：“师父，你老人家忒没情义。虽是我动手打，却也只是为你。你不往西天取经，我不与你做徒弟，怎么会来这里打杀人！”然后骂道：“触恼了我的性子，将你打死了，尽你到那里去告，我老孙是不怕，玉帝认得我，天王随得我；二十八宿惧我，九曜星官怕我；十代阎君曾与我为仆从，五路猖神曾与我当后生；三界五司，十方诸宰，都与我情深面熟，随你那里去告！”&lt;br&gt;这绝对是在恐吓唐僧，把老子惹火了，连你也打死，你去告吧！&lt;br&gt;三藏见他说出这般恶话，心惊肉跳道：“徒弟呀，你怎么就认真起来？”&lt;br&gt;晚上，在老杨家借宿，老杨的儿子是强盗一伙，孙悟空又打死了二三十个强盗，还把老杨儿子的头割下来，拧给唐僧看。&lt;br&gt;唐僧大惊，念起《紧箍儿咒》，把个行者勒得耳红面赤，眼胀头昏，在地下打滚，翻筋斗，竖蜻蜓，疼痛难禁。把大圣咒倒在地，箍儿陷在肉里有一寸来深浅。并威胁道：“快走！迟了些儿，我又念真言，这番决不住口，把你脑浆都勒出来哩！”&lt;br&gt;这是唐僧第三次赶孙悟空滚蛋。西天路走了一大半了，眼看就要出成果了，他要他滚蛋！&lt;br&gt;大圣疼痛难忍，忽然省悟道：“这和尚负了我心。”&lt;br&gt;于是，孙悟空发怒了，终于撕破脸皮反了目：你这泼秃！没了俺老孙，连口水都没得喝，还这般刁难俺，不给点颜色看看，你就不知道俺老孙的狠气！我管你是哪个！一棒子将唐僧打晕在地，扬长而去。丢下了这样一句话：“你这个狠心的泼秃，十分贱我！”&lt;/p&gt;
&lt;h3 id=&quot;二、经过&quot;&gt;&lt;a href=&quot;#二、经过&quot; class=&quot;headerlink&quot; title=&quot;二、经过&quot;&gt;&lt;/a&gt;二、经过&lt;/h3&gt;&lt;p&gt;沙僧来找他算帐，他说没有，绝对没有的事，俺老孙怎会干这样的缺德事呢，你若不信，菩萨可以作证嘛，我这几天一直都在这儿。&lt;br&gt;沙僧当然不信，因为你会架筋斗云，又会分身法。于是，菩萨叫沙僧与悟空同去见个真假。结果，沙僧看到了两个一模一样的孙悟空，长相、声音、本领都是一样的。这些条件是妖怪有可能具备的，可是，最重要的证据金箍棒、紧箍咒也是一样的，而这两个条件是妖怪不可能具备的。这就说明根本没有假的，这明摆着是孙悟空使的分身法嘛！&lt;br&gt;孙悟空上天庭借照妖镜，鉴定结果：两个都是真的。玉帝当然辨不出哪个假。“这大圣呵呵冷笑，那行者也哈哈欢喜”，就说明他正在暗自得意：嘿嘿！你们谁都想不到吧！&lt;br&gt;到阎罗殿去查，谛听是知道真相的，却不敢当面说破，否则，孙悟空不打死他才怪，发起恶来，把阎罗殿都拆了！&lt;br&gt;孙悟空走到哪儿都问的理直气壮：“你们看我两个谁是假的！”都辨不出，因为根本没有假的。他的目的就是要闹得让天、地、神、人、鬼尽知，不是俺老孙打的你这泼秃，而是你这泼秃缺了俺老孙就会碰到妖怪。&lt;/p&gt;
&lt;h3 id=&quot;三、结果&quot;&gt;&lt;a href=&quot;#三、结果&quot; class=&quot;headerlink&quot; title=&quot;三、结果&quot;&gt;&lt;/a&gt;三、结果&lt;/h3&gt;&lt;p&gt;最后闹到雷音寺，孙悟空与如来佛说的话，和在前面别处说的是有区别的，他先说这一路上我这般辛苦，不知费了多少精神，师父却把我赶出来。现在，请佛祖与&lt;em&gt;**&lt;/em&gt;辨明邪正，我才好保唐僧过来把佛经取回东土，帮你永传大教。&lt;br&gt;注意：他说的是辨明邪正，不是辨明真假，而在前面别处他都是说的辨个真假。这个区别是相当大的，真假，是指两个人谁真谁假，邪正，是问我的行为对不对，请如来公断。&lt;br&gt;孙悟空这点分身术的小把戏，又岂能瞒得过如来佛？！在他还没来之前，如来佛就已经对大众说了：“汝等俱是一心，且看他二心斗来。”你们这些人呀，一心要看他谁真谁假，又岂能识破他的二心呢？根本就不是两个人，是二心也，孙猴子生了二心，把老师都打了！你们却以为是妖怪。&lt;br&gt;但是，这能说吗？一说破，就无法收场了，这个经就彻底的取不成了！如来的计划就破产了！所以，大局为重，如来佛也不能说破，不但不能说，反而还要很默契地配合他假戏真做！所以如来才杜撰出一个谁也没听说、没见过、根本就不存在的六耳猕猴来。&lt;br&gt;原著中这样写道：如来正欲道破，忽见…，如来笑道：我观假悟空乃六耳猕猴也。&lt;br&gt;孙悟空没想到如来佛会瞎扯，很是震惊，不知道如来要干什么，如来也没有辨真假，而是直接吓唬猴子：“悟空休动，待我与你擒住他。”悟空生怕被抓住把柄，急变蜂儿飞跑。大众不知，以为走了。如来笑云：“汝等休要再言，妖精未走，在我钵盂之下。”将钵盂揭起，果见一六耳猕猴。&lt;br&gt;孙大圣忍不住，将其打死。“忍不住”这三字用的好啊，悟空的心理素质到底比不上如来佛祖。佛法无边的如来总算帮神通广大的悟空把这个弥天大谎撒团圆了，皆大欢喜。&lt;br&gt;大圣叩头谢道：“上告如来：那师父若不要我，却不又枉劳一番神思！还是放我还俗去罢。”如来道：“你休乱想，切莫放刁，我教观音送你，不怕他不收。好生保护他去，那时功成归极乐，汝亦坐莲台。”&lt;br&gt;经过这一场闹剧，孙悟空明确的被如来内定为预备佛员，这是对他敢打师父的一种肯定，一种奖励！唐僧呢，这个刁酸无能的泼秃领导吃了哑巴亏，白挨了一顿揍。这种人欠揍，揍他一顿，他自然就老实了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;看《西游记》第五十七回，说是“六耳猕猴”化作孙悟空的摸样，伤了唐僧，后又和孙悟空大打出手。。。这位假孙悟空，实力不用多说了吧，和真孙悟空一般无二，大战孙悟空，闹到上天入地下海。在唐僧那：念紧箍咒，两个都喊疼，自然看不出哪个真假；到天宫：拖塔天王拿照妖镜照，也看不出；又到观音
    
    </summary>
    
    
      <category term="西游记" scheme="http://mmrxia.github.io/tags/%E8%A5%BF%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
</feed>
