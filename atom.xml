<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>芥子园 | xiaqingsong&#39;s blog</title>
  <subtitle>须弥藏芥子，芥子纳须弥</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mmrxia.github.io/"/>
  <updated>2016-12-16T07:42:25.843Z</updated>
  <id>http://mmrxia.github.io/</id>
  
  <author>
    <name>芥子园</name>
    <email>this.xqs@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>windows下安装配置mongodb</title>
    <link href="http://mmrxia.github.io/2016/12/16/windows%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmongodb/"/>
    <id>http://mmrxia.github.io/2016/12/16/windows下安装配置mongodb/</id>
    <published>2016-12-16T06:36:29.000Z</published>
    <updated>2016-12-16T07:42:25.843Z</updated>
    
    <content type="html">&lt;p&gt;安装文件：官方网站 &lt;a href=&quot;http://www.mongodb.org/downloads&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.mongodb.org/downloads&lt;/a&gt;&lt;br&gt;选择对应系统的文件下载。&lt;/p&gt;
&lt;p&gt;一、解压缩文件。&lt;br&gt;  将压缩包解压，在D盘创建文件夹&lt;code&gt;mongodb&lt;/code&gt;,将压缩包解压到&lt;code&gt;mongodb&lt;/code&gt;文件夹中。&lt;/p&gt;
&lt;p&gt;二、建立工作目录。&lt;br&gt;  1、建立数据存放目录  &lt;code&gt;D:\mongodb\data\db&lt;/code&gt;&lt;br&gt;  2、建立日志文件  &lt;code&gt;D:\mongodb\db\log\mongodb.log&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;三、建立配置文件。&lt;br&gt;  &lt;code&gt;mongodb&lt;/code&gt;文件夹下建立&lt;code&gt;mongodb.cfg&lt;/code&gt;文件，输入以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;  dbpath=D:\MongoDB\data #数据库路径
  logpath=D:\MongoDB\logs\mongodb.log #日志输出文件路径
  logappend=true #错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件
  journal=true #启用日志文件，默认启用
  quiet=true #这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false
  port=27017 #端口号 默认为27017
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;  这里仅指定了几个常用项，更多详细配置请参考官方文档 &lt;a href=&quot;http://docs.mongodb.org/manual/reference/configuration-options/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://docs.mongodb.org/manual/reference/configuration-options/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;四、启动mongdb服务。&lt;/p&gt;
&lt;p&gt;  至此&lt;code&gt;mongodb&lt;/code&gt;文件夹下有文件夹及文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;  D:\ mongodb\bin
  D:\ mongodb\data\db
  D:\ mongodb\data\log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;  配置文件和相关目录建好后使用如下方式启动mongodb：&lt;/p&gt;
&lt;p&gt;  控制台进入&lt;code&gt;D:\ mongodb\bin&lt;/code&gt;目录，执行以下命令:&lt;/p&gt;
&lt;p&gt;  1 . 普通启动 &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;  mongod --config D:\mongodb\mongodb.cfg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;  2 . 安装为Windows服务&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;  mongod --config D:\mongodb\mongodb.cfg --install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;  注：2.6版 这种方式在win7、win8 64位版无法安装成功，其他系统未测试&lt;br&gt;  BUG链接 &lt;a href=&quot;https://jira.mongodb.org/browse/SERVER-13515&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://jira.mongodb.org/browse/SERVER-13515&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  3 . 使用SC命令安装为Windows服务&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;  sc create MongoDB binPath= &amp;quot;D:\mongodb\bin\mongod.exe --service --config=D:\mongodb\mongodb.cfg&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;五、系统服务启动与删除。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;net start MongoDB  //启动MongoDB服务  
net stop MongoDB  //停止MongoDB服务   
mongod --remove //移除MongoDB服务
&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;安装文件：官方网站 &lt;a href=&quot;http://www.mongodb.org/downloads&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.mongodb.org/downloads&lt;/a&gt;&lt;br&gt;选择对应系统的文件下载。&lt;
    
    </summary>
    
    
      <category term="mongodb" scheme="http://mmrxia.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>bigPipe方案实现及剖析</title>
    <link href="http://mmrxia.github.io/2016/11/16/bigPipe%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%89%96%E6%9E%90/"/>
    <id>http://mmrxia.github.io/2016/11/16/bigPipe方案实现及剖析/</id>
    <published>2016-11-16T09:24:43.000Z</published>
    <updated>2016-11-16T09:38:16.234Z</updated>
    
    <content type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;2010 年初的时候，Facebook 的前端性能研究小组开始了他们的优化项目，经过了六个月的努力，成功的将个人空间主页面加载耗时由原来的5 秒减少为现在的2.5 秒。&lt;br&gt;这是一个非常了不起的成就，也给用户来带来了很好的体验。在优化项目中，工程师提出了一种新的页面加载技术，称之为Bigpipe。&lt;br&gt;目前淘宝和Facebook面临的问题非常相似：海量数据和页面过大，如果可以在详情页、列表页中使用bigpipe，将会带来明显的页面加载速度提升。&lt;/p&gt;
&lt;h2 id=&quot;相关介绍&quot;&gt;&lt;a href=&quot;#相关介绍&quot; class=&quot;headerlink&quot; title=&quot;相关介绍&quot;&gt;&lt;/a&gt;相关介绍&lt;/h2&gt;&lt;p&gt;一、BigPipe与AJAX&lt;/p&gt;
&lt;p&gt;Web2.0的重要特征是网页显示大量动态内容，即web2.0注重网页与用户的交互。其核心技术是AJAX，如今所有主流网站都或多或少使用AJAX。与AJAX类似，BigPipe 实现了分块儿的概念，使页面能够分步输出，即每次输出一部分网页内容。接下来讨论BigPipe 与AJAX 的区别。&lt;/p&gt;
&lt;p&gt;简单的说，BigPipe 比AJAX 有三个好处：&lt;/p&gt;
&lt;p&gt;1 . AJAX 的核心是XMLHttpRequest，客户端需要异步的向服务器端发送请求，然后将传送过来的内容动态添加到网页上。如此实现存在一些缺陷，即发送往返请求需要耗费时间，而BigPipe 技术使浏览器并不需要发送XMLHttpRequest 请求，这样就节省时间损耗。&lt;/p&gt;
&lt;p&gt;2 . 使用AJAX时，浏览器和服务器的工作顺序执行。服务器必须等待浏览器的请求，这样就会造成服务器的空闲。浏览器工作时，服务器在等待，而服务器工作时，浏览器在等待，这也是一种性能的浪费。使用BigPipe，浏览器和服务器可以并行同时工作，服务器不需要等待浏览器的请求，而是一直处于加载页面内容的工作阶段，这就会使效率得到更大的提高。&lt;/p&gt;
&lt;p&gt;3 . 减少浏览器发送到请求。对一个5亿用户的网站来说，减少了使用AJAX额外带来的请求，会减少服务器的负载，同样会带来很大的性能提升。&lt;/p&gt;
&lt;p&gt;基于以上三点，Facebook 在进行页面优化时采用了BigPipe 技术。目前淘宝主搜索结果页中，需要加载类目，相关搜索，宝贝列表，广告等内容，前端这里使用php 的curl 的批处理来并发的访问引擎获取相应的数据，并进行分步输出。这种模式还是与bigpipe有些不同，这点后面会讲到。一般来讲，在页面比较大，而且比较复杂，样式表和脚本比较多的情况下，使用BigPipe 来优化输出页面是比较合适的。另外非常重要的一点，BigPipe 并不改变浏览器的结构与网络协议，仅使用JS就可以实现，用户不需要做任何的设置，就会看到明显的访问时间缩短。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.searchtb.com/2011/04/an-introduction-to-bigpipe.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.searchtb.com/2011/04/an-introduction-to-bigpipe.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;待续…&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;2010 年初的时候，Facebook 的前端性能研究小组开始了他们的优化项目，经过了六个月的努力，成功的将个人空间主页面加载耗时由原来的5
    
    </summary>
    
    
      <category term="nodejs" scheme="http://mmrxia.github.io/tags/nodejs/"/>
    
      <category term="bigPipe" scheme="http://mmrxia.github.io/tags/bigPipe/"/>
    
  </entry>
  
  <entry>
    <title>js encode或decode base64格式的字符串</title>
    <link href="http://mmrxia.github.io/2016/11/16/js-encode%E6%88%96decode-base64%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://mmrxia.github.io/2016/11/16/js-encode或decode-base64格式的字符串/</id>
    <published>2016-11-16T08:50:07.000Z</published>
    <updated>2016-11-16T09:13:35.557Z</updated>
    
    <content type="html">&lt;h4 id=&quot;方式一：Chrome、FireFox等现代主流浏览器或IE10及以上版本。&quot;&gt;&lt;a href=&quot;#方式一：Chrome、FireFox等现代主流浏览器或IE10及以上版本。&quot; class=&quot;headerlink&quot; title=&quot;方式一：Chrome、FireFox等现代主流浏览器或IE10及以上版本。&quot;&gt;&lt;/a&gt;方式一：Chrome、FireFox等现代主流浏览器或IE10及以上版本。&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 测试字符
var string = &amp;#39;Hello World!&amp;#39;;

// 加密
var encodedString = btoa(string);
console.log(encodedString); // 输出: &amp;quot;SGVsbG8gV29ybGQh&amp;quot;

// 解密
var decodedString = atob(encodedString);
console.log(decodedString); // 输出: &amp;quot;Hello World!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;方式二：跨浏览器的方法（压缩版本）&quot;&gt;&lt;a href=&quot;#方式二：跨浏览器的方法（压缩版本）&quot; class=&quot;headerlink&quot; title=&quot;方式二：跨浏览器的方法（压缩版本）&quot;&gt;&lt;/a&gt;方式二：跨浏览器的方法（压缩版本）&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 定义Base64对象
var Base64={_keyStr:&amp;quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&amp;quot;,encode:function(e){var t=&amp;quot;&amp;quot;;var n,r,i,s,o,u,a;var f=0;e=Base64._utf8_encode(e);while(f&amp;lt;e.length){n=e.charCodeAt(f++);r=e.charCodeAt(f++);i=e.charCodeAt(f++);s=n&amp;gt;&amp;gt;2;o=(n&amp;amp;3)&amp;lt;&amp;lt;4|r&amp;gt;&amp;gt;4;u=(r&amp;amp;15)&amp;lt;&amp;lt;2|i&amp;gt;&amp;gt;6;a=i&amp;amp;63;if(isNaN(r)){u=a=64}else if(isNaN(i)){a=64}t=t+this._keyStr.charAt(s)+this._keyStr.charAt(o)+this._keyStr.charAt(u)+this._keyStr.charAt(a)}return t},decode:function(e){var t=&amp;quot;&amp;quot;;var n,r,i;var s,o,u,a;var f=0;e=e.replace(/[^A-Za-z0-9+/=]/g,&amp;quot;&amp;quot;);while(f&amp;lt;e.length){s=this._keyStr.indexOf(e.charAt(f++));o=this._keyStr.indexOf(e.charAt(f++));u=this._keyStr.indexOf(e.charAt(f++));a=this._keyStr.indexOf(e.charAt(f++));n=s&amp;lt;&amp;lt;2|o&amp;gt;&amp;gt;4;r=(o&amp;amp;15)&amp;lt;&amp;lt;4|u&amp;gt;&amp;gt;2;i=(u&amp;amp;3)&amp;lt;&amp;lt;6|a;t=t+String.fromCharCode(n);if(u!=64){t=t+String.fromCharCode(r)}if(a!=64){t=t+String.fromCharCode(i)}}t=Base64._utf8_decode(t);return t},_utf8_encode:function(e){e=e.replace(/rn/g,&amp;quot;n&amp;quot;);var t=&amp;quot;&amp;quot;;for(var n=0;n&amp;lt;e.length;n++){var r=e.charCodeAt(n);if(r&amp;lt;128){t+=String.fromCharCode(r)}else if(r&amp;gt;127&amp;amp;&amp;amp;r&amp;lt;2048){t+=String.fromCharCode(r&amp;gt;&amp;gt;6|192);t+=String.fromCharCode(r&amp;amp;63|128)}else{t+=String.fromCharCode(r&amp;gt;&amp;gt;12|224);t+=String.fromCharCode(r&amp;gt;&amp;gt;6&amp;amp;63|128);t+=String.fromCharCode(r&amp;amp;63|128)}}return t},_utf8_decode:function(e){var t=&amp;quot;&amp;quot;;var n=0;var r=c1=c2=0;while(n&amp;lt;e.length){r=e.charCodeAt(n);if(r&amp;lt;128){t+=String.fromCharCode(r);n++}else if(r&amp;gt;191&amp;amp;&amp;amp;r&amp;lt;224){c2=e.charCodeAt(n+1);t+=String.fromCharCode((r&amp;amp;31)&amp;lt;&amp;lt;6|c2&amp;amp;63);n+=2}else{c2=e.charCodeAt(n+1);c3=e.charCodeAt(n+2);t+=String.fromCharCode((r&amp;amp;15)&amp;lt;&amp;lt;12|(c2&amp;amp;63)&amp;lt;&amp;lt;6|c3&amp;amp;63);n+=3}}return t}}

// 测试字符
var string = &amp;#39;Hello World!&amp;#39;;

// 加密
var encodedString = Base64.encode(string);
console.log(encodedString); // 输出: &amp;quot;SGVsbG8gV29ybGQh&amp;quot;

// 解密
var decodedString = Base64.decode(encodedString);
console.log(decodedString); // 输出: &amp;quot;Hello World!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;方式一：Chrome、FireFox等现代主流浏览器或IE10及以上版本。&quot;&gt;&lt;a href=&quot;#方式一：Chrome、FireFox等现代主流浏览器或IE10及以上版本。&quot; class=&quot;headerlink&quot; title=&quot;方式一：Chrome、FireFox
    
    </summary>
    
    
      <category term="javascript" scheme="http://mmrxia.github.io/tags/javascript/"/>
    
      <category term="base64" scheme="http://mmrxia.github.io/tags/base64/"/>
    
  </entry>
  
  <entry>
    <title>怎样使用js生成uuid</title>
    <link href="http://mmrxia.github.io/2016/09/01/%E6%80%8E%E6%A0%B7%E4%BD%BF%E7%94%A8js%E7%94%9F%E6%88%90uuid/"/>
    <id>http://mmrxia.github.io/2016/09/01/怎样使用js生成uuid/</id>
    <published>2016-09-01T06:57:55.000Z</published>
    <updated>2016-09-01T07:10:53.536Z</updated>
    
    <content type="html">&lt;p&gt;原问题：&lt;a href=&quot;http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How to create a GUID / UUID in Javascript?&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Introuction&quot;&gt;&lt;a href=&quot;#Introuction&quot; class=&quot;headerlink&quot; title=&quot;Introuction&quot;&gt;&lt;/a&gt;Introuction&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;UUID = Universally Unique IDentifier, 全球唯一标识符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本来我觉得UUID不是什么事，只是一个唯一性的ID字符串而已。在Stack Overflow上看到这个问题之后，倒开始觉得，也许UUID里也有一些值得去发掘的东西。&lt;/p&gt;
&lt;p&gt;于是我想到了这几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#UUID-and-GUID&quot;&gt;为什么有UUID和GUID这两个东西&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Specification&quot;&gt;有什么规范吗&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;好像我曾多次看到过有人讨论某种系统或变成语言下UUID的生成问题，&lt;a href=&quot;#UUID-and-implementation&quot;&gt;UUID跟系统或者编程语言有关系吗&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;带着这些问题，我查找并学习了一番。现在做个整理。&lt;/p&gt;
&lt;h2 id=&quot;UUID-and-GUID&quot;&gt;&lt;a href=&quot;#UUID-and-GUID&quot; class=&quot;headerlink&quot; title=&quot;UUID and GUID&quot;&gt;&lt;/a&gt;UUID and GUID&lt;/h2&gt;&lt;h4 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h4&gt;&lt;p&gt;UUID来自于IETF发布的一个规范：&lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;A Universally Unique IDentifier (UUID) URN Namespace&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This specification defines a Uniform Resource Name namespace for UUIDs (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDentifier).  A UUID is 128 bits long, and can guarantee uniqueness across space and time.  UUIDs were originally used in the Apollo Network Computing System and later in the Open Software Foundation’s (OSF) Distributed Computing Environment (DCE), and then in Microsoft Windows platforms.&lt;br&gt;This specification is derived from the DCE specification with the kind permission of the OSF (now known as The Open Group).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;UUID和GUID是同一个东西的两个名字。这两个名字的来源不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UUID来源于OSF的DCE规范，也就是RFC4122的前身&lt;/li&gt;
&lt;li&gt;GUID来源于微软，注意RFC4122的作者之一是微软员工&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;用途&quot;&gt;&lt;a href=&quot;#用途&quot; class=&quot;headerlink&quot; title=&quot;用途&quot;&gt;&lt;/a&gt;用途&lt;/h4&gt;&lt;p&gt;UUID的出现，是为了在一个复杂的系统中，唯一的标识每个信息实体，同时不需要有一个集中的id管理。也就是说，根据某种规则来为一个信息实体分配一个唯一的id，而且不需要一个id管理器来保证这个id的唯一性。&lt;/p&gt;
&lt;p&gt;它可以用来标识任何东西，Microsoft用它来表示Windows中的软件（GUID），Linux用它来表示系统中的文件。&lt;/p&gt;
&lt;h2 id=&quot;Specification&quot;&gt;&lt;a href=&quot;#Specification&quot; class=&quot;headerlink&quot; title=&quot;Specification&quot;&gt;&lt;/a&gt;Specification&lt;/h2&gt;&lt;h4 id=&quot;UUID格式规范&quot;&gt;&lt;a href=&quot;#UUID格式规范&quot; class=&quot;headerlink&quot; title=&quot;UUID格式规范&quot;&gt;&lt;/a&gt;UUID格式规范&lt;/h4&gt;&lt;p&gt;这128bits的结构如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          time_low                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       time_mid                |         time_hi_and_version   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |clk_seq_hi_res |  clk_seq_low  |         node (0-1)            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         node (2-5)                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      time-low               = 4hexOctet
      time-mid               = 2hexOctet
      time-high-and-version  = 2hexOctet    // MOST IMPORTANT !
      clock-seq-and-reserved = hexOctet
      clock-seq-low          = hexOctet
      node                   = 6hexOctet
      hexOctet               = hexDigit hexDigit
      hexDigit =
            &amp;quot;0&amp;quot; / &amp;quot;1&amp;quot; / &amp;quot;2&amp;quot; / &amp;quot;3&amp;quot; / &amp;quot;4&amp;quot; / &amp;quot;5&amp;quot; / &amp;quot;6&amp;quot; / &amp;quot;7&amp;quot; / &amp;quot;8&amp;quot; / &amp;quot;9&amp;quot; /
            &amp;quot;a&amp;quot; / &amp;quot;b&amp;quot; / &amp;quot;c&amp;quot; / &amp;quot;d&amp;quot; / &amp;quot;e&amp;quot; / &amp;quot;f&amp;quot; /
            &amp;quot;A&amp;quot; / &amp;quot;B&amp;quot; / &amp;quot;C&amp;quot; / &amp;quot;D&amp;quot; / &amp;quot;E&amp;quot; / &amp;quot;F&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;UUID生成算法&quot;&gt;&lt;a href=&quot;#UUID生成算法&quot; class=&quot;headerlink&quot; title=&quot;UUID生成算法&quot;&gt;&lt;/a&gt;UUID生成算法&lt;/h4&gt;&lt;p&gt;UUID本身也经过了&lt;a href=&quot;http://en.wikipedia.org/wiki/Universally_unique_identifier#Variants_and_versions&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;多个版本的演化&lt;/a&gt;。比如node字段的定义，最开始定义为来自IEEE 802 address，演化到后来的&lt;em&gt;a randomly or pseudo-randomly generated 48-bit value&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;最新的UUID生成算法是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Set the two most significant bits (bits 6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively.&lt;/li&gt;
&lt;li&gt;Set the four most significant bits (bits 12 through 15) of the time_hi_and_version field to the 4-bit version number.&lt;/li&gt;
&lt;li&gt;Set all the other bits to randomly (or pseudo-randomly) chosen values.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;UUID-and-implementation&quot;&gt;&lt;a href=&quot;#UUID-and-implementation&quot; class=&quot;headerlink&quot; title=&quot;UUID and implementation&quot;&gt;&lt;/a&gt;UUID and implementation&lt;/h2&gt;&lt;p&gt;越来越多的系统中使用着UUID，各自使用目的并不一样。而且由于限定在128bits，UUID规范本身并没有保证UUID真的是在全球唯一的。因此现在对UUID的使用，一般都是限定在一个范围内有唯一性保证，比如一个操作系统内。&lt;/p&gt;
&lt;p&gt;因此我们可以看到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微软有一个GUID生成lib：&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.guid(v=vs.110).aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://msdn.microsoft.com/en-us/library/system.guid(v=vs.110).aspx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Linux也同样有UUID生成lib：&lt;a href=&quot;http://en.wikipedia.org/wiki/Util-linux&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://en.wikipedia.org/wiki/Util-linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Android的UUID生成lib：&lt;a href=&quot;http://developer.android.com/reference/java/util/UUID.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://developer.android.com/reference/java/util/UUID.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用以上系统对应的UUID生成lib可以确保产生的UUID在系统范围内是唯一的。因此可以用来标识系统资源，比如文件、软件、设备等。&lt;/p&gt;
&lt;p&gt;而对于某种具体的编程语言，UUID的使用并没有必要。因为使用UUID的目的是给某个资源分配一个在当前环境下唯一的标识符。而一个程序只有在运行的时候才谈得上有一个&lt;strong&gt;环境&lt;/strong&gt;，进程之间又互不影响。因此，一般在编程语言规范中并没有对UUID生成方法进行规定。&lt;/p&gt;
&lt;p&gt;但&lt;em&gt;unique id&lt;/em&gt;还是很常用的，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PHP - uniqid() &lt;a href=&quot;http://php.net/manual/en/function.uniqid.php#94959&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://php.net/manual/en/function.uniqid.php#94959&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Mysql - UUID() &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/miscellaneous-functions.html#function_uuid&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://dev.mysql.com/doc/refman/5.1/en/miscellaneous-functions.html#function_uuid&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Java - UUID &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/UUID.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://docs.oracle.com/javase/7/docs/api/java/util/UUID.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但这些UUID方法只是借用了&lt;em&gt;唯一性&lt;/em&gt;的概念，并不是必须。而且uuid规定128bits，很多情况下有点浪费。&lt;/p&gt;
&lt;p&gt;你可以用任何方法来生成一个程序内唯一的字符串，比如mysql中的incremental id，它就比uuid实用。&lt;/p&gt;
&lt;p&gt;##UUID in Javascript&lt;br&gt;既然要生成UUID，那么得符合规范。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Javascript function&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function generateUUID(){
    var d = new Date().getTime();
    var uuid = &amp;#39;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&amp;#39;.replace(/[xy]/g, function(c) {
        var r = (d + Math.random()*16)%16 | 0;
        d = Math.floor(d/16);
        return (c==&amp;#39;x&amp;#39; ? r : (r&amp;amp;0x7|0x8)).toString(16);
    });
    return uuid;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Node module&lt;br&gt;&lt;a href=&quot;https://github.com/broofa/node-uuid&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/broofa/node-uuid&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;原问题：&lt;a href=&quot;http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How to cre
    
    </summary>
    
    
      <category term="javascript" scheme="http://mmrxia.github.io/tags/javascript/"/>
    
      <category term="uuid" scheme="http://mmrxia.github.io/tags/uuid/"/>
    
  </entry>
  
  <entry>
    <title>使用淘宝npm镜像cnpm</title>
    <link href="http://mmrxia.github.io/2016/08/05/%E4%BD%BF%E7%94%A8%E6%B7%98%E5%AE%9Dnpm%E9%95%9C%E5%83%8Fcnpm/"/>
    <id>http://mmrxia.github.io/2016/08/05/使用淘宝npm镜像cnpm/</id>
    <published>2016-08-05T03:24:36.000Z</published>
    <updated>2016-08-05T03:57:36.984Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;在使用 node 模块时可以使用 npm install 查找 package.json 中的声明的依赖模块并安装。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但因为国内网络原因，使用 npm 安装某些模块会非常慢，甚至无法安装所有的包。&lt;br&gt;幸运的是,国内有几个镜像站点可以供我们使用,比如 &lt;code&gt;https://registry.cnpmjs.org&lt;/code&gt;、&lt;code&gt;https://registry.npm.taobao.org&lt;/code&gt;,速度非常快,镜像站会实时更新,为我们节省了好多时间.    &lt;/p&gt;
&lt;h5 id=&quot;那么-如何给本机换源呢&quot;&gt;&lt;a href=&quot;#那么-如何给本机换源呢&quot; class=&quot;headerlink&quot; title=&quot;那么,如何给本机换源呢?&quot;&gt;&lt;/a&gt;那么,如何给本机换源呢?&lt;/h5&gt;&lt;p&gt;(1)[临时]通过 &lt;code&gt;config&lt;/code&gt; 配置指向国内镜像源&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;# 配置指向源
npm config set registry http://registry.cnpmjs.org
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(2)[临时]通过 &lt;code&gt;npm&lt;/code&gt; 命令指定下载源&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;npm --registry http://registry.cnpmjs.org
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(3)[linux]在配置文件 &lt;code&gt;~/.npmrc&lt;/code&gt; 文件写入源地址&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;//打开配置文件
nano ~/.npmrc
//写入配置文件
registry =https://registry.npm.taobao.org
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;推荐使用最后一种方法,一劳永逸,前面2钟方法都是临时改变包下载源.&lt;br&gt;如果你不想使用国内镜像站点,只需要将 写入 &lt;code&gt;~/.npmrc&lt;/code&gt; 的配置内容删除即可.  &lt;/p&gt;
&lt;p&gt;配置后可通过下面方式来验证是否成功&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;npm config get registry
// 或
npm info express
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&quot;使用cnpm&quot;&gt;&lt;a href=&quot;#使用cnpm&quot; class=&quot;headerlink&quot; title=&quot;使用cnpm&quot;&gt;&lt;/a&gt;使用cnpm&lt;/h5&gt;&lt;p&gt;或者你也可以安装&lt;code&gt;cnpm&lt;/code&gt;包，使用&lt;code&gt;cnpm&lt;/code&gt;替代&lt;code&gt;npm&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;npm install -g cnpm --registry=https://registry.npm.taobao.org
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后使用 &lt;code&gt;cnpm&lt;/code&gt; 安装模块：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;cnpm install [module-name]
&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在使用 node 模块时可以使用 npm install 查找 package.json 中的声明的依赖模块并安装。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但因为国内网络原因，使用 npm 安装某些模块会非常慢，甚至无法安装所有的包。&lt;br
    
    </summary>
    
    
      <category term="npm" scheme="http://mmrxia.github.io/tags/npm/"/>
    
      <category term="cnpm" scheme="http://mmrxia.github.io/tags/cnpm/"/>
    
  </entry>
  
  <entry>
    <title>html5在iOS设备上传图片调整方向实践</title>
    <link href="http://mmrxia.github.io/2016/07/18/html5%E5%9C%A8iOS%E8%AE%BE%E5%A4%87%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E8%B0%83%E6%95%B4%E6%96%B9%E5%90%91%E5%AE%9E%E8%B7%B5/"/>
    <id>http://mmrxia.github.io/2016/07/18/html5在iOS设备上传图片调整方向实践/</id>
    <published>2016-07-18T11:56:54.000Z</published>
    <updated>2016-07-18T11:59:19.353Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;解决在iOS设备上，用H5上传图片，有时图片方向会错乱的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用html5编写图片裁切上传，在iphone手机上可能会遇到图片方向错误问题，在此把解决方法和大家分享一下，&lt;br&gt;用到了html5的 FileReader和Canvas，如果还没有接触的同学，先了解一下其方法。   &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt; //此方法为file input元素的change事件
 function change(){
    var file = this.files[0];
    var orientation;
    //EXIF js 可以读取图片的元信息  https://github.com/exif-js/exif-js
    EXIF.getData(file,function(){
        orientation=EXIF.getTag(this,&amp;#39;Orientation&amp;#39;);
    });
    var reader = new FileReader();
    reader.onload = function(e) {   
        getImgData(this.result,orientation,function(data){
            //这里可以使用校正后的图片data了 
        }); 
    }
    reader.readAsDataURL(file);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面是具体的处理方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// @param {string} img 图片的base64
// @param {int} dir exif获取的方向信息
// @param {function} next 回调方法，返回校正方向后的base64
function getImgData(img,dir,next){
  var image=new Image();
  image.onload=function(){
    var degree=0,drawWidth,drawHeight,width,height;
    drawWidth=this.naturalWidth;
    drawHeight=this.naturalHeight;
    //以下改变一下图片大小
    var maxSide = Math.max(drawWidth, drawHeight);
    if (maxSide &amp;gt; 1024) {
        var minSide = Math.min(drawWidth, drawHeight);
        minSide = minSide / maxSide * 1024;
        maxSide = 1024;
        if (drawWidth &amp;gt; drawHeight) {
            drawWidth = maxSide;
            drawHeight = minSide;
        } else {
            drawWidth = minSide;
            drawHeight = maxSide;
        }
    }
    var canvas=document.createElement(&amp;#39;canvas&amp;#39;);
    canvas.width=width=drawWidth;
    canvas.height=height=drawHeight; 
    var context=canvas.getContext(&amp;#39;2d&amp;#39;);
    //判断图片方向，重置canvas大小，确定旋转角度，iphone默认的是home键在右方的横屏拍摄方式
    switch(dir){
       //iphone横屏拍摄，此时home键在左侧
        case 3:
            degree=180;
            drawWidth=-width;
            drawHeight=-height;
            break;
        //iphone竖屏拍摄，此时home键在下方(正常拿手机的方向)
        case 6:
            canvas.width=height;
            canvas.height=width; 
            degree=90;
            drawWidth=width;
            drawHeight=-height;
            break;
        //iphone竖屏拍摄，此时home键在上方
        case 8:
            canvas.width=height;
            canvas.height=width; 
            degree=270;
            drawWidth=-width;
            drawHeight=height;
            break;
    }
    //使用canvas旋转校正
    context.rotate(degree*Math.PI/180);
    context.drawImage(this,0,0,drawWidth,drawHeight);
    //返回校正图片
    next(canvas.toDataURL(&amp;quot;image/jpeg&amp;quot;,.8));
 }
  image.src=img;
}
&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;解决在iOS设备上，用H5上传图片，有时图片方向会错乱的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用html5编写图片裁切上传，在iphone手机上可能会遇到图片方向错误问题，在此把解决方法和大家分享一下，&lt;br&gt;用到了html5的 Fil
    
    </summary>
    
    
      <category term="js" scheme="http://mmrxia.github.io/tags/js/"/>
    
      <category term="移动端开发" scheme="http://mmrxia.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>centOS下配置git</title>
    <link href="http://mmrxia.github.io/2016/07/04/centOS%E4%B8%8B%E9%85%8D%E7%BD%AEgit/"/>
    <id>http://mmrxia.github.io/2016/07/04/centOS下配置git/</id>
    <published>2016-07-04T08:14:54.000Z</published>
    <updated>2016-07-17T06:26:55.420Z</updated>
    
    <content type="html">&lt;h4 id=&quot;1-安装git&quot;&gt;&lt;a href=&quot;#1-安装git&quot; class=&quot;headerlink&quot; title=&quot;1. 安装git&quot;&gt;&lt;/a&gt;1. 安装git&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost ~]# yum install git
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;2-配置git&quot;&gt;&lt;a href=&quot;#2-配置git&quot; class=&quot;headerlink&quot; title=&quot;2. 配置git&quot;&gt;&lt;/a&gt;2. 配置git&lt;/h4&gt;&lt;p&gt;1 . 进入 &lt;code&gt;.ssh&lt;/code&gt; 目录&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost ~]# cd .ssh/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2 . 生成ssh-keygen&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost .ssh]# ssh-keygen -t rsa -C &amp;#39;this.xqs@gmail.com&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会出现以下提示：&lt;/p&gt;
&lt;p&gt;Generating public/private rsa key pair.&lt;br&gt;Enter file in which to save the key (/root/.ssh/id_rsa): （可不填）&lt;br&gt;Enter passphrase (empty for no passphrase):  （可不填）&lt;br&gt;Enter same passphrase again:  （可不填）&lt;br&gt;Your identification has been saved in /root/.ssh/id_rsa.&lt;br&gt;Your public key has been saved in /root/.ssh/id_rsa.pub.&lt;br&gt;The key fingerprint is:&lt;br&gt;8f:8e:89:00:1a:3e:83:d1:95:fc:e8:9c:22:85:4c:a7 this.xqs@gmail.com        &lt;/p&gt;
&lt;p&gt;3 . 复制 &lt;code&gt;id_rsa.pub&lt;/code&gt; 文件中的内容，粘贴到github新增的ssh keys中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost .ssh]# ls
// id_rsa  id_rsa.pub

[root@localhost .ssh]# vim id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4 . 配置用户名和邮箱&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost .ssh]# git config --global user.name &amp;#39;bandwagonhost vps&amp;#39;
[root@localhost .ssh]# git config --global user.email &amp;#39;this.xqs@gmail.com&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5 . 测试连接&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost .ssh]# ssh -T git@github.com
Hi mmrxia! You&amp;#39;ve successfully authenticated, but GitHub does not provide shell access.
&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-安装git&quot;&gt;&lt;a href=&quot;#1-安装git&quot; class=&quot;headerlink&quot; title=&quot;1. 安装git&quot;&gt;&lt;/a&gt;1. 安装git&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost ~]
    
    </summary>
    
    
      <category term="git" scheme="http://mmrxia.github.io/tags/git/"/>
    
      <category term="Linux" scheme="http://mmrxia.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>centOS下安装nodeJS</title>
    <link href="http://mmrxia.github.io/2016/07/04/centOS%E4%B8%8B%E5%AE%89%E8%A3%85nodeJS/"/>
    <id>http://mmrxia.github.io/2016/07/04/centOS下安装nodeJS/</id>
    <published>2016-07-04T06:30:07.000Z</published>
    <updated>2016-07-07T09:35:21.098Z</updated>
    
    <content type="html">&lt;h4 id=&quot;一、源码安装&quot;&gt;&lt;a href=&quot;#一、源码安装&quot; class=&quot;headerlink&quot; title=&quot;一、源码安装&quot;&gt;&lt;/a&gt;一、源码安装&lt;/h4&gt;&lt;p&gt;1 . 安装gcc-c编译器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost ~]# sudo yum install gcc gcc-c++
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2 . 现在nodejs源码并解压  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost ~]# wget https://nodejs.org/dist/v4.4.7/node-v4.4.7-linux-x86.tar.gz
[root@localhost ~]# tar xvf node-v4.4.7-linux-x86
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3 . 编译&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost ~]# ./configure
[root@localhost ~]# make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;二、nvm安装&quot;&gt;&lt;a href=&quot;#二、nvm安装&quot; class=&quot;headerlink&quot; title=&quot;二、nvm安装&quot;&gt;&lt;/a&gt;二、nvm安装&lt;/h4&gt;&lt;p&gt;1 . 获取nvm&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.31.2/install.sh | bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2 . 安装nodejs&lt;/p&gt;
&lt;p&gt; 可用 &lt;code&gt;nvm ls-remote&lt;/code&gt; 列出所有可安装的node版本，然后安装需要的版本。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; nvm install v4.4.7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装完成后可查看node版本。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;node -v
&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、源码安装&quot;&gt;&lt;a href=&quot;#一、源码安装&quot; class=&quot;headerlink&quot; title=&quot;一、源码安装&quot;&gt;&lt;/a&gt;一、源码安装&lt;/h4&gt;&lt;p&gt;1 . 安装gcc-c编译器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[r
    
    </summary>
    
    
      <category term="nodejs" scheme="http://mmrxia.github.io/tags/nodejs/"/>
    
      <category term="Linux" scheme="http://mmrxia.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>express学习笔记</title>
    <link href="http://mmrxia.github.io/2016/07/01/express%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://mmrxia.github.io/2016/07/01/express学习笔记/</id>
    <published>2016-07-01T07:32:01.000Z</published>
    <updated>2016-07-18T11:44:35.814Z</updated>
    
    <content type="html">&lt;h4 id=&quot;1-app-render和res-render方法的区别？&quot;&gt;&lt;a href=&quot;#1-app-render和res-render方法的区别？&quot; class=&quot;headerlink&quot; title=&quot;1 . app.render和res.render方法的区别？&quot;&gt;&lt;/a&gt;1 . app.render和res.render方法的区别？&lt;/h4&gt;&lt;p&gt;官方的api文档中是这么说的：   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Think of app.render() as a utility function for generating rendered view strings. Internally res.render() uses app.render() to render views.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的理解：&lt;/p&gt;
&lt;p&gt;把&lt;code&gt;app.render&lt;/code&gt;当成一个生成视图的工具，而且&lt;code&gt;res.render&lt;/code&gt;内部也是调用了&lt;code&gt;app.render&lt;/code&gt;。&lt;br&gt;区别是这样，&lt;code&gt;app.render&lt;/code&gt;只负责生成视图，你会发现它是没能力把视图响应给客户端（浏览器）的，只有&lt;code&gt;res.render&lt;/code&gt;手里有&lt;code&gt;response&lt;/code&gt;对象，可以把视图响应给客户端。&lt;br&gt;&lt;code&gt;res.render&lt;/code&gt;的伪代码可以看做如下: &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;res.render = function(view, locals, cb){
    app.render(view, locals, function(err, html){
        if(typeof cb !== &amp;#39;undefined&amp;#39;){
            return cb(err, html);
        }
        res.send(html);
    });
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;2-res-write和res-send区别？&quot;&gt;&lt;a href=&quot;#2-res-write和res-send区别？&quot; class=&quot;headerlink&quot; title=&quot;2 . res.write和res.send区别？&quot;&gt;&lt;/a&gt;2 . res.write和res.send区别？&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;The res object represents the HTTP response that an Express app sends when it gets an HTTP request.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;res.write&lt;/code&gt;和&lt;code&gt;res.send&lt;/code&gt;都是发送报文到浏览器response中，并渲染在浏览器窗口。&lt;br&gt;&lt;code&gt;res.write&lt;/code&gt;使用时需要配合&lt;code&gt;res.end&lt;/code&gt;方法同时使用，否则浏览器http请求会一直处于pending状态，而&lt;code&gt;res.send&lt;/code&gt;单独使用即可。    &lt;/p&gt;
&lt;p&gt;代码示例：     &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//res.send
app.get(&amp;#39;/user/:id&amp;#39;, function(req, res){
  res.send(&amp;#39;user &amp;#39; + req.params.id);
});

//res.write
app.get(&amp;#39;/user/:id&amp;#39;, function(req, res){
 res.status(200).write(&amp;#39;user &amp;#39; + req.params.id);
 res.end();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;3-获取request请求参数的方法？&quot;&gt;&lt;a href=&quot;#3-获取request请求参数的方法？&quot; class=&quot;headerlink&quot; title=&quot;3 . 获取request请求参数的方法？&quot;&gt;&lt;/a&gt;3 . 获取request请求参数的方法？&lt;/h4&gt;&lt;p&gt;express获取参数有三种方法：  &lt;/p&gt;
&lt;p&gt;官网实例：   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Checks route params (req.params), ex: /user/:id&lt;br&gt;Checks query string params (req.query), ex: ?id=12&lt;br&gt;Checks urlencoded body params (req.body), ex: id=    &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;例如：127.0.0.1:3000/index，得到index，可以通过使用&lt;code&gt;req.params&lt;/code&gt;得到；   &lt;/li&gt;
&lt;li&gt;例如：127.0.0.1:3000/index?id=12，这种情况下，这种方式是获取客户端get方式传递过来的值，通过使用&lt;code&gt;req.query.id&lt;/code&gt;可以获得；     &lt;/li&gt;
&lt;li&gt;例如：127.0.0.1：300/index，然后post了一个id=2的值，这种方式是获取客户端post过来的数据，可以通过&lt;code&gt;req.body.id&lt;/code&gt;获取； &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：post请求，第三种方式需要以下配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;   var express        =         require(&amp;quot;express&amp;quot;);  
   var bodyParser     =         require(&amp;quot;body-parser&amp;quot;);  
   var app            =         express();  

   app.use(bodyParser.urlencoded({ extended: false }));   // necessary
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;4-session使用入门&quot;&gt;&lt;a href=&quot;#4-session使用入门&quot; class=&quot;headerlink&quot; title=&quot;4 . session使用入门&quot;&gt;&lt;/a&gt;4 . session使用入门&lt;/h4&gt;&lt;p&gt;&lt;code&gt;express-session&lt;/code&gt;是express中比较常用的处理session的中间件,使用npm安装：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;$ npm install express-session save
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;session的认证机制必须依赖cookie，所以还应该同时安装一个&lt;code&gt;cookie-parser&lt;/code&gt;，安装方法同上。然后再app.js中导入这两个中间件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var cookieParser = require(&amp;#39;cookie-parser&amp;#39;);
var session = require(&amp;#39;express-session&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后定义cookie解析器，注意，该定义必须写在路由分配之前：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;app.use(cookieParser());
app.use(session({
  secret: &amp;#39;secret_string&amp;#39;,
  name: &amp;#39;name&amp;#39;,
  cookie: {maxAge: 60000},
  resave: false,
  saveUninitialized: true,
}));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;各参数意义：&lt;br&gt;&lt;code&gt;secret&lt;/code&gt;：用来对session数据进行加密的字符串.这个属性值为必须指定的属性。&lt;br&gt;&lt;code&gt;name&lt;/code&gt;：表示cookie的name，默认cookie的name是：connect.sid。&lt;br&gt;&lt;code&gt;maxAge&lt;/code&gt;：cookie过期时间，毫秒。&lt;br&gt;&lt;code&gt;resave&lt;/code&gt;：是指每次请求都重新设置session cookie，假设你的cookie是6000毫秒过期，每次请求都会再设置6000毫秒。&lt;br&gt;&lt;code&gt;saveUninitialized&lt;/code&gt;： 是指无论有没有session cookie，每次请求都设置个session cookie ，默认给个标示为 connect.sid。     &lt;/p&gt;
&lt;p&gt;之后在处理请求时直接通过以下方式对session进行读写：        &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;req.session.userinfo = userinfo;  //写入至session
res.redirect(req.session.userinfo); //从session中读取
&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-app-render和res-render方法的区别？&quot;&gt;&lt;a href=&quot;#1-app-render和res-render方法的区别？&quot; class=&quot;headerlink&quot; title=&quot;1 . app.render和res.render方法的区别？&quot;&gt;&lt;
    
    </summary>
    
    
      <category term="nodejs" scheme="http://mmrxia.github.io/tags/nodejs/"/>
    
      <category term="express" scheme="http://mmrxia.github.io/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>16年后web开发趋势思考</title>
    <link href="http://mmrxia.github.io/2016/06/27/16%E5%B9%B4%E5%90%8Eweb%E5%BC%80%E5%8F%91%E8%B6%8B%E5%8A%BF%E6%80%9D%E8%80%83/"/>
    <id>http://mmrxia.github.io/2016/06/27/16年后web开发趋势思考/</id>
    <published>2016-06-27T07:21:44.000Z</published>
    <updated>2016-06-27T07:42:10.855Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;Rewriting your Frontend Framework every six week !!!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;近二年的进展&quot;&gt;&lt;a href=&quot;#近二年的进展&quot; class=&quot;headerlink&quot; title=&quot;近二年的进展&quot;&gt;&lt;/a&gt;近二年的进展&lt;/h3&gt;&lt;p&gt;前端发展日新月异, 甚至有一句戏言: “每六星期重写一个前端框架”, 行业是像火箭一样, 但我们前端工程师该何去何从呢?&lt;br&gt;我们来谈谈这个问题.&lt;br&gt;先来看看最流行的几项技术栈:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;AngularJS&lt;br&gt;首创的双向数据绑定, 以及内置的模块注入, 以及组件化的支持, 种种优势, 使得它迅速发展起来. 在 2014-2015 年, 有调查显示, 在使用了前端框架的项目, 有 50% 以上采用了 AngularJS. 但到底值不值我们继续学习, 我们再接下来看.&lt;br&gt;项目地址: &lt;a href=&quot;https://angularjs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;EmberJS&lt;br&gt;受 Rails 全栈框架的启发, EmberJS 逐步发展成前端领域的另一个 “Rails”, 成为另一个独特的选择, 理论上, 你选择了 EmberJS, 就选择了一个完整稳定的生态, 不用再折腾的轮子. EmberJS 不仅全面支持模块化, MVC, 也实现了类似 AngularJS 的双向绑定( 当然原理不同 ), 甚至还做到了内置的打包和发布应用功能. 总而言之, 它是一个十分全面的前端框架. 事实上, 如果说 AngularJS 是当前短暂的前端史的一个高峰, 它就是另一个高峰. 但最近, 人气有一定的下降, 原因何在, 我们再分解.&lt;br&gt;项目地址: &lt;a href=&quot;http://emberjs.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ReactJS&lt;br&gt;ReactJS 自发布之始, 就人气很高, 它是第一个采用虚拟节点( virtual dom )技术的框架, 通过这个技术点, 它独创性地整合了函数性编程的理念, 采用单向数据流来设计 dom 渲染与比对, 使得它轻量和灵活, 事实上, 它本身只专注于如何渲染 UI, 也不与 AngularJS 和 EmberJS 有冲突. 换言之, 你可以将它整合到其他框架中.&lt;br&gt;随着 ReactNative 和 Redux 方案的出现, ReactJS 重新回到前端的浪尖, 因为其简洁优雅的实现和对 Native APP 的冲击, 又一次成为新的弄潮儿.&lt;br&gt;但以后会怎么样, 谁也不知道, 但我也会再给一些解读.&lt;br&gt;项目地址: &lt;a href=&quot;https://facebook.github.io/react/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;流行不一定是发展最快, 我们再来看看近二年发展最快的几项前端技术栈:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ReactJS&lt;br&gt;上文已经提到, React 由于本身的简洁性和对组件化专注的实现, 一直没有被新的 ES6 标准和前端思潮落下, 它几乎不受 ES6 的影响, 以及前沿性的支持 native app 开发( 通过 ReactNative ), 所以一直发展趋势良好.&lt;br&gt;而 AngularJS 则不一样, 由于 ES6 的发布, 使得它的依赖注入特性成为鸡肋, 以及 AngularJS 第一版对组件化支持的蹩脚实现( 能支持是一回事, 好用是另一回事 ), 而组件化则学习成本过高, 过于复杂, 所以 AngularJS 决定推翻设计重新开发第二版, 而第二版过于激进的采用 Typescript, 完全不兼容的第一版的设计, 以及各种魔法的应用, 使得它离前端越走越远.   &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;VueJS&lt;br&gt;VueJS 是近二年的新秀, 它起步之初, 只是一个简化版的类似于 AngularJS 双向绑定的实现的研究( 当然原理并不同 ). 但其理念与 ReactJS 相近, 只是专注于实现数据绑定, 模块化与组件化, 所以足够的简单灵活.&lt;br&gt;随着生态的快速发展, VueJS 正好接了 AngularJS 第一版的班, 又改良了 AngularJS 的错误设计( 事后来看, 依赖注入与组件化两部分是比较失败的设计 ), 整体发展迅速, 逐步成为后起之秀.&lt;br&gt;项目地址: &lt;a href=&quot;http://vuejs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MeteorJS&lt;br&gt;MeteorJS 本不适合与上述几个前端框架比较, 因为它实际是一个全栈框架, 更像 Rails 这种角色, 但由于它是纯 Javascript 的方案, 所以还是放在这里.&lt;br&gt;如果说上述前端框架都是解决前端工程化的产物, 那 MeteorJS 是一个颠覆思维的 web 开发框架, 它将Javascript 同构技术应用到极端, 再整合 websocket 进行实时数据通知与热代码更新, 不同于前后端分离的理念, 它在开发者角度完全没有前后端的概念, API 既在前端又在后端, 再加它全生态的支持( 移动 app 支持, 应用发布), 也是一个全新的视角, 由于它发展速度极快, 所以列在这里.&lt;br&gt;项目地址: &lt;a href=&quot;https://www.meteor.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;各大框架都在迅速发展中, 它们有几个共性的发展方向:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ES6 支持&lt;br&gt;每一次 Javascript 的新标准发布, 都是各大框架更新的好机会, 所以 ES6 是肯定得到各大框架的良好支持, 建议大家一定要学好.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;web 组件化&lt;br&gt;毋庸置疑, 组件化是现代前端工程化中极为重要的特性, 甚至 google 还专门出了 Polymer 这个只做组件化实现的框架. 所以每一个够格的前端框架都非常重度支持它. 同时, 组件化也将作为 w3c 标准予于定义, 所以前端框架仍将不留余力地改进与标准的兼容.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Server-side Render&lt;br&gt;服务端渲染技术是 2016 年才开始火的概念, 它与传统的后端渲染不同, 为了解决前端框架第一次加载慢的问题, 以及 SEO 问题, 而提出的解决方案. 之前有 prerender, 现在各大框架都在尝试在内部集成并支持它. 但我个人觉得, 带来的问题远比解决的问题更多, 比如要求我们开发的时候有更多的限制.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;App Render&lt;br&gt;现在有一种大前端的概念, 可以理解为 web 前端对 App 开发的支持, 包括 Ionic ( 基于 AngularJS ), React Native( 基于 React 理念 ), Meteor 都是针对 App 开发的痛点而生.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分析了众多目前最流行的前端框架, 大家可能越来越胡涂了:&lt;br&gt;到底谁才是最值得我们去投入的技术呢?&lt;br&gt;接下来, 我们去掉一堆术语, 来从前端的定义本质来看它的发展. &lt;/p&gt;
&lt;h3 id=&quot;近二年本质的演进是什么&quot;&gt;&lt;a href=&quot;#近二年本质的演进是什么&quot; class=&quot;headerlink&quot; title=&quot;近二年本质的演进是什么&quot;&gt;&lt;/a&gt;近二年本质的演进是什么&lt;/h3&gt;&lt;p&gt;前端就是面向用户这一端的技术, 然而, 随着时代的发展:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户体验要求越来越高( 加载速度快, 响应快, 无闪烁 )&lt;/li&gt;
&lt;li&gt;前端需求越来越多&lt;/li&gt;
&lt;li&gt;前端代码越来越庞大&lt;/li&gt;
&lt;li&gt;移动端快速发展对 h5 前端的需求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而 jQuery, ProtoypeJS 等只解决了 Javascript 工具库的问题, 但工程化需求无好的解决方案.&lt;br&gt;前端工程化迫在眉捷. 而且有以下要求:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最好是纯 Javascript 方案&lt;/li&gt;
&lt;li&gt;支持模块化&lt;/li&gt;
&lt;li&gt;业务代码与框架代码分离&lt;/li&gt;
&lt;li&gt;可测性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是, 产生了几种不同的演进方案.&lt;br&gt;后端渲染技术:&lt;br&gt;ajax -&amp;gt; pjax -&amp;gt; sjr ( 需要服务端提供支持 )&lt;br&gt;后端渲染技术很快就发展到顶了. 但技术理解还是足够简单的. 我们还是回到前端框架上.&lt;br&gt;NodeJS, AMD(CMD), ES6 的出现, 使得组织起一个前端框架成为现实. 于是乎, 百团大战, 出现了上面众多框架混战的画面.&lt;br&gt;无论是 AngularJS, EmberJS, ReactJS, VueJS 都是围绕着这几点进行的不同的尝试.&lt;br&gt;但结果如何, 我们站在一个更高的高度重新思考 web 开发.      &lt;/p&gt;
&lt;h3 id=&quot;真正的用户市场需要什么&quot;&gt;&lt;a href=&quot;#真正的用户市场需要什么&quot; class=&quot;headerlink&quot; title=&quot;真正的用户市场需要什么&quot;&gt;&lt;/a&gt;真正的用户市场需要什么&lt;/h3&gt;&lt;p&gt;对用户   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更快的响应速度&lt;/li&gt;
&lt;li&gt;更好的体验&lt;br&gt;对开发者&lt;/li&gt;
&lt;li&gt;更快的开发速度&lt;/li&gt;
&lt;li&gt;更好的可维护性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再次思考, 我们要不要前后端分离? 哪些前端框架更满足我们以上的条件?&lt;br&gt;作为 Rails 工程师, 我也一直在思考一个问题: Rails 是否在前端上走上了绝路?&lt;br&gt;对于不熟悉 Rails 的朋友, 我还是简单回顾下 Rails 的前端是什么:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jQuery&lt;/li&gt;
&lt;li&gt;UJS&lt;/li&gt;
&lt;li&gt;Assets pipeline&lt;/li&gt;
&lt;li&gt;SJR( 服务端 JS 生成技术 )&lt;/li&gt;
&lt;li&gt;Turoblinks( 一种极小成本实现的单页效果的技术 )&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相比 php, java, python 等语言下的传统 web 框架来说, Rails 的前端技术还是非常丰富的.&lt;br&gt;关于各个框架我列了一个分数比较, 10 分为满分, 每个列会加在一起算成一个总分.&lt;br&gt; &lt;img src=&quot;http://7xth8v.com2.z0.glb.qiniucdn.com/image/n-web-score-2016.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上表可以看出:&lt;br&gt;Rails 这类的全栈框架特点有&lt;/p&gt;
&lt;p&gt;优势:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发效率极高&lt;/li&gt;
&lt;li&gt;通过 Turoblinks 技术, 体验也不错.&lt;/li&gt;
&lt;li&gt;也能支持混合应用开发&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前端代码可维护差&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ReactJS 学习成本较低, 通过 webpack 与 npm 的配合, 能够达到不错的可维护性, 但开发成本偏高, 这也是组件化的缺点之一.&lt;br&gt;而 EmberJS 学习门槛过高, 而且 EmberJS 发展也比较迅速, 不利于学习掌握, 相对而言, 总分也不会太高.&lt;br&gt;MeteorJS 也被我列在这里, 总分最低, 所以仍然不推荐学习, 除非你的应用属于实时应用.&lt;br&gt;我们再重新思考组件化, 组件化优势在于接口清晰, 可维护性高, 但开发成本是比较高的, 前端属于工程而不是科学, 所以, 我觉得组件化是对的, 但不要过于极端把所有的 dom 都组件化.&lt;br&gt;而且, 组件化也对现有的基础技术栈进行了破坏.&lt;br&gt;通过以上的分析, 我们基本上了解了现有技术栈的情况. 那我们该继续学什么? 这才是本文的重点.&lt;br&gt;所有的一切, 都是围绕着组件化, 可维护, 高效开发, 移动支持而生, 而它们的核心都是还是最基础的东西:     &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Javascript ( ES6, NodeJS )&lt;/li&gt;
&lt;li&gt;HTML&lt;/li&gt;
&lt;li&gt;CSS&lt;/li&gt;
&lt;li&gt;API&lt;br&gt;一句话, 还是应该先把基础打好.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基础技术栈&quot;&gt;&lt;a href=&quot;#基础技术栈&quot; class=&quot;headerlink&quot; title=&quot;基础技术栈&quot;&gt;&lt;/a&gt;基础技术栈&lt;/h3&gt;&lt;p&gt;应当好好掌握的内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Javascript 语言( 直接看 ES6 相关的 )&lt;/li&gt;
&lt;li&gt;NodeJS 生态( npm 与相关的包 )&lt;/li&gt;
&lt;li&gt;webpack ( 了解如何打包, 发布 )&lt;/li&gt;
&lt;li&gt;HTML ( 尤其是 form 标签, 以及 HTML5 的内容 )&lt;/li&gt;
&lt;li&gt;CSS ( 学习盒模型, 最新的 flex 布局, 以及 CSS3 )&lt;/li&gt;
&lt;li&gt;API ( 掌握如何开发 API )&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你必须是前端工程师, 同时又是后端工程师, 才能真正摸清晰当下时代的发展, 成为弄潮儿!&lt;/p&gt;
&lt;h3 id=&quot;预测未来&quot;&gt;&lt;a href=&quot;#预测未来&quot; class=&quot;headerlink&quot; title=&quot;预测未来&quot;&gt;&lt;/a&gt;预测未来&lt;/h3&gt;&lt;p&gt;首先, 我在 2014 年分析 web 开发的文中提到的 gulp, grunt 都已经成为过去式了. Bower 也已经有点不合事宜了.&lt;br&gt;目前前端构建建议使用 webpack 和 npm 足够, 不需要更多的工具链, 应该越简单, 越顺手!&lt;br&gt;列几个关心的问题尝试预测一下.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NodeJS 做后台开发怎么样 ?&lt;br&gt;NodeJS 已经是前端框架的一部分, 是极为成功的, 但对于 NodeJS 做后台开发说实在的, 它能够占一定的市场, 但将会非常少( 低于 5% ). 所以做 php 或 java 开发的朋友倒不用担心, 但如果只是搬砖写简单 API 的话, 就有危险了.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rails 还行不行 ?&lt;br&gt;Rails 已经到了一定的顶点, 不可能再突破性增长, 但仍然是目前最为顺手的 web 开发框架, 它的前端解决方案目前仍有不错的体验与开发效率, 但可维护性比较差, 如果是我的话, 我会带领团队采用混合式的开发, 但现在不会是引入 AngularJS 而会是 VueJS.&lt;br&gt;但 Rails 已经到达它的极限点了, 而众多前端框架才刚刚开始.( 虽然拿 Rails 与前端框架比较不够合适 )    &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AngularJS 还是 ReactJS ?&lt;br&gt;很简单, 建议直接上手 VueJS.&lt;br&gt;AnguarJS 第一版是个好的框架, 但 Angular2 并不是, 所以还不如直接学习 VueJS.&lt;br&gt;ReactJS 是个不错的框架, 但绝不是终点. VueJS 与 ReactJS 在实现上各有利弊. 两者可以择其一学之.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MeteorJS 值不值得学习 ?&lt;br&gt;我的建议是不值得, 因为它一开始就走在错误的道路上, 注定后面无路可走.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;前端会取代 Native APP 开发么?&lt;br&gt;一定会的, 未来 3 年后, 至少有 70% 左右的 APP 会用前端开发方案, 比如使用类似于 Ionic 或 Meteor 这样的框架.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;重新思考-web-开发&quot;&gt;&lt;a href=&quot;#重新思考-web-开发&quot; class=&quot;headerlink&quot; title=&quot;重新思考 web 开发&quot;&gt;&lt;/a&gt;重新思考 web 开发&lt;/h3&gt;&lt;p&gt;真正能长远的前端技术一定是简单的, 专注的, 比如 jQuery. 但目前几个框架都或多或少存在着问题.&lt;br&gt;ReactJS 不是表面那么简单, 而 AngularJS 更加复杂.&lt;br&gt;是否有更简单有效的解决它们的问题, 则能够成为下一代 web 前端框架.    &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Rewriting your Frontend Framework every six week !!!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;近二年的进展&quot;&gt;&lt;a href=&quot;#近二年的进展&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
    
      <category term="前端" scheme="http://mmrxia.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>git 常用命令汇总</title>
    <link href="http://mmrxia.github.io/2016/06/03/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
    <id>http://mmrxia.github.io/2016/06/03/git-常用命令汇总/</id>
    <published>2016-06-03T06:26:42.000Z</published>
    <updated>2016-07-04T07:53:36.601Z</updated>
    
    <content type="html">&lt;h3 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h3&gt;&lt;p&gt;创建账户：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;git config -global user.name &amp;quot;Your name&amp;quot;
git config -global user.email &amp;quot;you@example.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从仓库克隆到提交文件通用流程：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt; git clone git@github.com:mmrxia/project-name.git
 git add .
 git commit -m &amp;#39;update file&amp;#39;
 git push -u origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看当前git仓库文件状态：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;git status
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;其他技巧&quot;&gt;&lt;a href=&quot;#其他技巧&quot; class=&quot;headerlink&quot; title=&quot;其他技巧&quot;&gt;&lt;/a&gt;其他技巧&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;新建.gitignore文件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;touch .gitignore
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查看文件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;vim README.md
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查看提交历史记录&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;git log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们常用 &lt;code&gt;-p&lt;/code&gt; 选项展开显示每次提交的内容差异，用 &lt;code&gt;-2&lt;/code&gt; 则仅显示最近的两次更新。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h3&gt;&lt;p&gt;创建账户：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;git config -global u
    
    </summary>
    
    
      <category term="git" scheme="http://mmrxia.github.io/tags/git/"/>
    
      <category term="bash" scheme="http://mmrxia.github.io/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>nodejs实践知识点汇总</title>
    <link href="http://mmrxia.github.io/2016/06/03/nodejs%E5%AE%9E%E8%B7%B5%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <id>http://mmrxia.github.io/2016/06/03/nodejs实践知识点汇总/</id>
    <published>2016-06-03T02:21:03.000Z</published>
    <updated>2016-07-20T09:45:37.353Z</updated>
    
    <content type="html">&lt;h3 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h3&gt;&lt;p&gt;1 . &lt;strong&gt;npm -v、node -v&lt;/strong&gt;： 查看npm或nodejs版本。示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;npm -v
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2 . &lt;strong&gt;npm init&lt;/strong&gt;： 会在当前目录引导创建一个package.json文件，包括名称、版本、作者这些信息等。示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;npm init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3 . &lt;strong&gt;npm install&lt;/strong&gt;： 根据package.json文件自动安装需要的模块。示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;npm install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;–save 命令，安装模块时，写入到package.json的依赖字段（dependencies）中。&lt;br&gt;使用&lt;code&gt;--save-dev&lt;/code&gt;命令，可写入到开发依赖字段（devDependencies）中。&lt;br&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;npm install express --save
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;-g 将包安装到全局环境中，如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;npm install express -g
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4 . &lt;strong&gt;npm uninstall &lt;name&gt;&lt;/name&gt;&lt;/strong&gt;： 卸载node模块&lt;/p&gt;
&lt;p&gt;5 . &lt;strong&gt;npm update &lt;name&gt;&lt;/name&gt;&lt;/strong&gt;： 更新node模块&lt;/p&gt;
&lt;p&gt;6 . 其他&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;npm root：查看当前包的安装路径&lt;/li&gt;
&lt;li&gt;npm root -g：查看全局的包的安装路径&lt;/li&gt;
&lt;li&gt;npm outdated：检查包是否已经过时，此命令会列出所有已经过时的包，可以及时进行包的更新&lt;/li&gt;
&lt;li&gt;npm list：查看当前目录下已安装的node包&lt;/li&gt;
&lt;li&gt;npm help：查看帮助命令&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h3&gt;&lt;p&gt;1 . &lt;strong&gt;npm -v、node -v&lt;/strong&gt;： 查看npm或nodejs版本。示例：&lt;/p&gt;
&lt;p
    
    </summary>
    
    
      <category term="nodejs" scheme="http://mmrxia.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>图片等比压缩居中显示</title>
    <link href="http://mmrxia.github.io/2016/06/02/%E5%9B%BE%E7%89%87%E7%AD%89%E6%AF%94%E5%8E%8B%E7%BC%A9%E5%B1%85%E4%B8%AD%E6%98%BE%E7%A4%BA/"/>
    <id>http://mmrxia.github.io/2016/06/02/图片等比压缩居中显示/</id>
    <published>2016-06-02T08:16:21.000Z</published>
    <updated>2016-06-02T08:35:19.322Z</updated>
    
    <content type="html">&lt;h3 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h3&gt;&lt;p&gt;html中的img标签元素，在元素容器中保证等比压缩居中显示。不能拉伸变形，尽量做成jQuery插件的调用方式。&lt;/p&gt;
&lt;h3 id=&quot;调用方式：&quot;&gt;&lt;a href=&quot;#调用方式：&quot; class=&quot;headerlink&quot; title=&quot;调用方式：&quot;&gt;&lt;/a&gt;调用方式：&lt;/h3&gt;&lt;p&gt;HTML:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div class=&amp;quot;img-wrapper&amp;quot;&amp;gt;
    &amp;lt;img class=&amp;quot;img&amp;quot; src=&amp;quot;image/tmp_01.jpg&amp;quot; alt=&amp;quot;demo1&amp;quot;/&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;quot;img-wrapper&amp;quot;&amp;gt;
    &amp;lt;img class=&amp;quot;img&amp;quot; src=&amp;quot;image/tmp_02.jpg&amp;quot; alt=&amp;quot;demo2&amp;quot;/&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;quot;img-wrapper&amp;quot;&amp;gt;
    &amp;lt;img class=&amp;quot;img&amp;quot; src=&amp;quot;image/tmp_03.png&amp;quot; alt=&amp;quot;demo3&amp;quot;/&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;quot;img-wrapper&amp;quot;&amp;gt;
    &amp;lt;img class=&amp;quot;img&amp;quot; src=&amp;quot;image/tmp_04.png&amp;quot; alt=&amp;quot;demo4&amp;quot;/&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CSS:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.img-wrapper{border: 1px dashed #2F9DC2;height: 100px;overflow: hidden;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JS:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;lt;script src=&amp;quot;../../static/js/lib/jquery.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;img-ratio-compress.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    $(&amp;#39;.img&amp;#39;).ratioCompress({resize:true});
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;效果如下：&quot;&gt;&lt;a href=&quot;#效果如下：&quot; class=&quot;headerlink&quot; title=&quot;效果如下：&quot;&gt;&lt;/a&gt;效果如下：&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://7xth8v.com2.z0.glb.qiniucdn.com/image/n_img_radio_commpress.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;示例演示：&quot;&gt;&lt;a href=&quot;#示例演示：&quot; class=&quot;headerlink&quot; title=&quot;示例演示：&quot;&gt;&lt;/a&gt;示例演示：&lt;/h3&gt;&lt;p&gt;大家可以点开页面查看图片源文件，查看图片尺寸。&lt;br&gt;demo中设置了随窗口变化图片位置自适应，可以缩放浏览器尺寸或者F12调整为移动端模式查看。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://rawgit.com/mmrxia/lab/master/examples/img-radio-compress/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点我查看示例&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h3&gt;&lt;p&gt;html中的img标签元素，在元素容器中保证等比压缩居中显示。不能拉伸变形，尽量做成jQuery插件的调用方式。&lt;/p&gt;
&lt;h3 id=&quot;调
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js 数组复制操作</title>
    <link href="http://mmrxia.github.io/2016/05/22/js-%E6%95%B0%E7%BB%84%E5%A4%8D%E5%88%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://mmrxia.github.io/2016/05/22/js-数组复制操作/</id>
    <published>2016-05-22T03:31:55.000Z</published>
    <updated>2016-05-22T03:45:23.699Z</updated>
    
    <content type="html">&lt;p&gt;js中数组和对象，使用“=”号赋值的时候，由于是引用类型，只是改变了引用对象的指针指向，改变值时会引起连锁反应。&lt;br&gt;简单效果如下：&lt;br&gt;&lt;img src=&quot;http://7xth8v.com2.z0.glb.qiniucdn.com/image/arr1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;避免指针指向的方法主要有一下几种：&lt;br&gt;（1）使用slice()方法。slice() 函数可从已有的数组中返回选定的元素；语法为：arr.slice(start,end);&lt;br&gt;slice()函数将会返回一个新的数组对象，所以使用slice(0)或slice()就可以实现数组的复制。如下：&lt;br&gt;&lt;img src=&quot;http://7xth8v.com2.z0.glb.qiniucdn.com/image/arr2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;（2）使用concat()方法。语法为：arr.concat(arr1,arr2,arr3,…,arrn);&lt;br&gt;concat()用于多个数组的合并，但是返回的结果是一个新的数组，而不再引用用于合并的任何一个数组。如下：&lt;br&gt;&lt;img src=&quot;http://7xth8v.com2.z0.glb.qiniucdn.com/image/arr3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;（3）笨方法：使用for循环；原理就不说了，直接上代码：&lt;br&gt;&lt;img src=&quot;http://7xth8v.com2.z0.glb.qiniucdn.com/image/arr4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;（4）使用jQuery的extend或merge方法：&lt;br&gt;$.extend 功能很强大，可以合并数组，对象！具体可参见jQuery api。&lt;br&gt;&lt;img src=&quot;http://7xth8v.com2.z0.glb.qiniucdn.com/image/arr5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;$.merge 只能合并一维数组，且一次只能合并2个，个人觉得没有concat方法强大。&lt;br&gt;&lt;img src=&quot;http://7xth8v.com2.z0.glb.qiniucdn.com/image/arr6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其他参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.html-js.com/article/1589&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;javascript 原始类型和引用类型&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;js中数组和对象，使用“=”号赋值的时候，由于是引用类型，只是改变了引用对象的指针指向，改变值时会引起连锁反应。&lt;br&gt;简单效果如下：&lt;br&gt;&lt;img src=&quot;http://7xth8v.com2.z0.glb.qiniucdn.com/image/arr1.png&quot; a
    
    </summary>
    
    
      <category term="js" scheme="http://mmrxia.github.io/tags/js/"/>
    
      <category term="数组" scheme="http://mmrxia.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>真假美猴王死的到底是谁</title>
    <link href="http://mmrxia.github.io/2016/05/17/%E7%9C%9F%E5%81%87%E7%BE%8E%E7%8C%B4%E7%8E%8B%E6%AD%BB%E7%9A%84%E5%88%B0%E5%BA%95%E6%98%AF%E8%B0%81/"/>
    <id>http://mmrxia.github.io/2016/05/17/真假美猴王死的到底是谁/</id>
    <published>2016-05-17T07:18:14.000Z</published>
    <updated>2016-05-22T03:28:21.650Z</updated>
    
    <content type="html">&lt;p&gt;看《西游记》第五十七回，说是“六耳猕猴”化作孙悟空的摸样，伤了唐僧，后又和孙悟空大打出手。。。这位假孙悟空，实力不用多说了吧，和真孙悟空一般无二，大战孙悟空，闹到上天入地下海。在唐僧那：念紧箍咒，两个都喊疼，自然看不出哪个真假；到天宫：拖塔天王拿照妖镜照，也看不出；又到观音那：观音也看不出。最后到幽冥处阎罗那，经“谛听”听过之后，“谛听”却说：“我看出来了，却不敢说”。。。最后还是如来老佛爷道出六耳真身并用金钵盂罩住，才被孙悟空一棍子打死。&lt;/p&gt;
&lt;p&gt;这是整个故事，看似很简单，很完整，不过，却有一个天大的伏笔。&lt;br&gt;咱现在先假设一下，被打死的那个是悟空，活的那个是六耳猕猴。我这不是胡说的，是有道理的，一下是我的一些理论：&lt;/p&gt;
&lt;p&gt;一、六耳猕猴和孙悟空一模一样，谁也看不出来，就算如来骗大家说六耳猕猴就是真的悟空，而这个谎言，也只有如来知道真相，真正的孙悟空，他只是个哑巴吃黄连。&lt;/p&gt;
&lt;p&gt;二、六耳猕猴很有可能是如来安排的一个托儿，大家都知道，孙悟空是个叛逆者，而如来是西天的最高统治者，哪个统治者会允许一个叛逆者生活在这个世界上？再加上，大家都知道的，孙悟空一向不敬重如来。所以如来会想方设法消灭孙悟空。当然不能明白着把孙悟空直接杀了，所以才出现一个一模一样的悟空，杀孙悟空于无形。而这个也是有证据的。&lt;/p&gt;
&lt;p&gt;1：比如在地府里面，经“谛听”听过之后，“谛听”明知道真假，却不敢说，其想法肯定不是怕两个悟空大闹地府，而是这个六耳猕猴有很强大的后台，那就是如来。所以，“谛听”自然不敢说出真相。&lt;br&gt;2：其次，可以证明“谛听”不是真正的怕二猴大闹地府的原因还有一个，大家都知道，当时在场的还有一个法力很强的人，当然，不是阎罗，阎罗和这人比，是天壤之别，这人就是“地藏王菩萨”，“地藏王菩萨”何许人啊，是佛教四大菩萨之首，与观音、文殊、普贤齐名，可见此人厉害。既然有这么厉害的佛门中人在此，难道“谛听”还担心这两泼猴会闹了地府不成？&lt;/p&gt;
&lt;p&gt;三、大家都知道，孙悟空的师傅是“菩提祖师”，“菩提祖师”何许人？《封神榜》上有个线索，就是“混鲲祖师”的徒弟，而恰巧，“混鲲祖师”弟子无数，而让他最得意的两大弟子，便是如来(又名“接引道人“）和菩提祖师(又名“准提道人“）。。。&lt;br&gt;一个大胆的想法，既然两位圣人是同门师兄，且《封神榜》中曾经略提到过，说二弟子准提道人（也就是说菩提祖师），其间不知与接引道人（如来）间发生了什么变故，却神秘消失，从此再不闻踪迹。这是一个很有力度的线索，证明二人之间有矛盾。&lt;br&gt;然后再回到孙悟空，而孙悟空又恰巧是菩提祖师的徒弟，如来见到昔日仇人的徒弟，又有翻天覆地之本领，不想方设法除之更待何时？&lt;/p&gt;
&lt;p&gt;四、西游记上讲述了孙悟空在菩提祖师处学了一身法术之后神通广大。而恰巧，和冒充孙悟空的六耳猕猴却也拥有和孙悟空一模一样的法术，甚至连长相声音装的都完全一样？这是巧合吗？大家都知道孙悟空只学个72变和筋斗云都学了几年，六耳猕猴不可能不学就天生就有这本领吧？肯定有和孙悟空同门出处的高人指点，自然菩提祖师不会在此之列，因为老人家既然有了孙悟空这样有情有义的徒弟，难道还要在造出一个六耳猕猴来和孙悟空对着干吗？所以，指点六耳猕猴来和孙悟空对着干的只有一个人，那就是菩提祖师的同门师兄，如来。&lt;/p&gt;
&lt;p&gt;五、再回到《西游记》第五十八回，话说，二猴打闹到如来这里要如来辩个真假。。。如来却对众佛说：“我观假悟空乃六耳猕猴也。此猴若立一处，能知千里外之事，凡人说话，亦能知之，故此善聆音，能察理，知前后，万物皆明。与真悟空同象同音者，六耳猕猴也”。&lt;br&gt;经如来这么一说，众佛知道了，原来天下众生中还有这么一个叫“六耳猕猴”，而西游记的读者们却忽略了如来的这一句话里的一个线索：如来说的意思是，此猴和孙悟空不同，孙悟空是“灵明石猴”，同变化，识天时，知地利，移星换斗。而六耳猕猴是“知前后，万物皆明”。很厉害吧，竟然知道过去和未来发生的一切事。这是一个很大的破绽！！！既然六耳猕猴知道他的未来将要被如来制服，被孙悟空一棒打死，他为什么还要和孙悟空到如来处辩真假，那不是自讨苦吃吗？所以只有一个可能，如来早都把事情安排的妥当，在他的说明下，让众佛都以为六耳猕猴就是“真悟空”，而真正的悟空，却被当成了“六耳猕猴”被如来制服，然后被一棒打死。&lt;br&gt;而当“六耳猕猴”被打死之后，一向慈悲为怀的如来却没一点怪罪之意，只是合并双手，道了句：“善哉，善哉！”。。。大家都知道，以如来的本领，当“孙悟空”想要一棒子打死“六耳猕猴”的话，如来想要出手相救，是何等的容易，可见，如来本意就是想让他死。而“六耳猕猴”本无太大的罪过，也就是和孙悟空大闹了下，一向慈悲的如来何必要让他死呢，想当年孙悟空闹了龙宫，闹了地府，闹了天宫，如来都还没让他死呢，怎么“六耳猕猴”这么一个小小的错误就要必须死呢？这里面肯定有隐情。所以那个隐情就是，如来是真正想处死的是孙悟空，而被一棒子打死的，却恰好是真正的孙悟空。&lt;/p&gt;
&lt;p&gt;六、大家会以为，孙悟空不是已经被生死薄删除了名字，又吃了那么多蟠桃和仙丹，早都可以长生不老，也有了金刚不坏之躯，怎么能这么容易就给打死了呢。这个也许就只有如来自己知道了，大家可以想象，如来既然当年有能力把孙悟空压打五行山，现在虽然杀不了孙悟空，当然也肯定有办法让孙悟空永远消失的活着。&lt;/p&gt;
&lt;p&gt;七、又回到孙悟空的师傅“菩提祖师”这。西游记里曾经记载，孙悟空在大闹天宫之后，惹了一大堆麻烦只好跟着唐僧西天取经，遇到困难又回去找他师傅“菩提祖师”的时候，“菩提祖师”早已不见踪影，只是和孙悟空隔空说话，并不见面。这是为什么呢？想必孙悟空用“菩提祖师”所教的本领大闹天宫之后，如来必有察觉，肯定会发现此七十二变和筋斗云正是同门法术。刚才我也说过了，菩提祖师和如来曾经因为一些矛盾，后来菩提祖师隐居了。如果如来看到孙悟空的本领后，肯定便知此本领肯定是菩提祖师所受，自然要追寻这个消失已久的仇人。所以，菩提祖师得知孙悟空大闹天宫之后，为防止不必要的麻烦，也已经消失的无影无踪。。。&lt;br&gt;而话又说回来了，菩提祖师本领并不亚于如来，这个可以从《西游记》第八回看出。。。其中有一段，如来说：“我西牛贺洲者，不贪不杀，养气潜灵，虽无上真，人人固寿”。大家注意了，如来说，“西牛贺州，虽无上真”，这恰恰说明，菩提在西牛贺洲传道能逃过如来法眼，说明菩提不比如来差。 &lt;/p&gt;
&lt;p&gt;八、大家发现没，在真假美猴王事出之前，孙悟空并不完全都听唐僧的话，甚至有时候，还闹个小矛盾，导致唐僧只好念紧箍咒，典型的一个叛逆者形象。可自从真假美猴王事出之后，孙悟空从此保护唐僧安安分分。而以此事可以看出，孙悟空前后可判若两人。不排除，孙悟空已被如来利用六耳猕猴一战中，安安静静、无人知晓的已被安排下台了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;其实还有另外一个版本，且待我慢慢道来：&lt;/p&gt;
&lt;p&gt;六耳猕猴是西游记中最奇特的一个妖怪，怎么奇特呢？我们来看一看：&lt;/p&gt;
&lt;h3 id=&quot;一、人物奇特&quot;&gt;&lt;a href=&quot;#一、人物奇特&quot; class=&quot;headerlink&quot; title=&quot;一、人物奇特&quot;&gt;&lt;/a&gt;一、人物奇特&lt;/h3&gt;&lt;p&gt;西游记主要是看孙悟空的戏，六耳猕猴这个妖怪居然敢冒充主角孙悟空，上演了一出《真假美猴王》的好戏。&lt;br&gt;按妖怪的胆量、能力与勇气大致可以分为三种：&lt;br&gt;1.怕孙悟空的妖怪根本不敢冒充孙悟空。&lt;br&gt;2.不把孙悟空放在眼里的妖怪根本不屑于冒充孙悟空。&lt;br&gt;3.和孙悟空势均力敌的妖怪，手段也颇高了，完全没有必要冒充孙悟空。&lt;br&gt;六耳猕猴这个妖怪的本事和孙悟空是一样的，他完全有能力独霸一方，干吗还要冒充孙悟空呢？因此，六耳猕猴冒充孙悟空，就显得格外的奇特。&lt;/p&gt;
&lt;h3 id=&quot;二、地点奇特&quot;&gt;&lt;a href=&quot;#二、地点奇特&quot; class=&quot;headerlink&quot; title=&quot;二、地点奇特&quot;&gt;&lt;/a&gt;二、地点奇特&lt;/h3&gt;&lt;p&gt;唐僧遇到六耳猕猴的地方，是强盗出没的山林，这里至少有三十几个以上的强盗在此地谋生活，这就说明这个山头是属于强盗的，按说不会有妖怪，若有妖怪，则强盗们根本无法生存，更不可能结成团伙，形成气候，早被妖怪吃了。&lt;br&gt;可见，六耳猕猴这个妖怪并不是本地妖怪，那他是从哪儿来的？&lt;br&gt;西游记中的妖怪无论法力大小，都有一块属于自己的地盘，厉害的妖怪管的宽一些，不厉害的妖怪地盘小点，怎么说，得有一片生存的土壤，否则，他是成不了妖的。&lt;br&gt;六耳猕猴呢？他有没有自己的地盘呢？有，在花果山，乘孙悟空不在的时候，他跑到花果山占山为王了，并且没有被其他的猴子们发觉。&lt;br&gt;可见，六耳猕猴对孙悟空的行踪及过去的经历了如指掌。&lt;/p&gt;
&lt;h3 id=&quot;三、行为奇特&quot;&gt;&lt;a href=&quot;#三、行为奇特&quot; class=&quot;headerlink&quot; title=&quot;三、行为奇特&quot;&gt;&lt;/a&gt;三、行为奇特&lt;/h3&gt;&lt;p&gt;妖怪们都有很强烈的领地感，只在自己控制的势力范围内吃人，基本上吃的都是你自己瞎了眼睛送上门来的，或是采用手段把你诱骗去的，一般不会越界行凶。许多妖怪都说过“若过了此地就不归我管”这类的话。&lt;br&gt;妖怪与妖怪之间是和谐的，没有争斗，偶尔还有聚会，我抓到一个人请你吃，你抓到一个人请我吃，大家都遵守江湖道义。不到别处去撒野，不到别人的门面上去抢生意。&lt;br&gt;而六耳猕猴，则不管这一套，他是从花果山不远万里赶来作案的！这个行为实在是太奇特了，这是其他妖怪所没有的。&lt;/p&gt;
&lt;h3 id=&quot;四、手段奇特&quot;&gt;&lt;a href=&quot;#四、手段奇特&quot; class=&quot;headerlink&quot; title=&quot;四、手段奇特&quot;&gt;&lt;/a&gt;四、手段奇特&lt;/h3&gt;&lt;p&gt;六耳猕猴作案的手段更是怪异，他不像别的妖怪那样躲在半空中，瞅准机会一阵风把唐僧掳走。&lt;br&gt;而是跪在路旁，双手捧着一杯水给唐僧喝，唐僧不喝，骂了他一顿，六耳猕猴就轮铁棒望长老脊背上砑了一下，那长老昏晕在地，不能言语，被他把两个青毡包袱，提在手中，驾筋斗云，不知去向。&lt;br&gt;六耳猕猴并没有抓唐僧，而是把唐僧打了一顿，然后抢了包裹行李，扬长而去的。没有一个妖怪是像他这样搞的。&lt;/p&gt;
&lt;h3 id=&quot;五、动机奇特&quot;&gt;&lt;a href=&quot;#五、动机奇特&quot; class=&quot;headerlink&quot; title=&quot;五、动机奇特&quot;&gt;&lt;/a&gt;五、动机奇特&lt;/h3&gt;&lt;p&gt;六耳猕猴作案的动机，也和其他妖怪不同，妖怪抓唐僧，无非是要吃唐僧肉，或是要交配，而六耳猕猴则是要自己拉一班人马去西天取经！&lt;br&gt;六耳猕猴高坐在石台之上，双手扯着通关文牒，念了从头又念，反复学习。他说：“我今熟读了牒文，我自己上西方拜佛求经，送上东土，我独成功，教那南赡部洲人立我为祖，万代传名也。”&lt;br&gt;六耳猕猴不仅冒充了孙悟空，还找了几个猴精冒充了唐三藏、猪八戒、沙僧和一匹白马，企图上西天，成佛做祖！这个妖怪简直太有创意了！&lt;/p&gt;
&lt;h3 id=&quot;六、过程奇特&quot;&gt;&lt;a href=&quot;#六、过程奇特&quot; class=&quot;headerlink&quot; title=&quot;六、过程奇特&quot;&gt;&lt;/a&gt;六、过程奇特&lt;/h3&gt;&lt;p&gt;六耳猕猴和孙悟空不仅外型一模一样，本事也是一模一样，走到哪儿，都无法分辨谁是真的谁是假的！&lt;br&gt;1.观音菩萨暗念《紧箍儿咒》，两个一齐喊疼，菩萨无计奈何。&lt;br&gt;2.李天王取照妖镜照住，镜中乃是两个孙悟空，毫发不差。玉帝亦辨不出。&lt;br&gt;3.唐僧念《紧箍儿咒》，二人一齐叫苦，唐僧也不认得真假。&lt;br&gt;4.阎罗殿的谛听可以分辨的出真假，却不敢说出来。&lt;br&gt;5.最后被如来佛辨出真假，是所有神仙都没有听说过的新物种：六耳猕猴。&lt;br&gt;6.六耳猕猴被孙悟空当场处决，打死了。&lt;/p&gt;
&lt;p&gt;以上种种疑点，实在太多，这里面就存在无法解释的问题：&lt;br&gt;1.既然阎罗殿的谛听可以分辨的出真假，却为什么不敢说出来？六耳猕猴与孙悟空的本事是一样大的，只要谛听说出哪个是假的，随便加几个人就可以帮孙悟空抓住六耳猕猴，谛听为什么不说？他怕什么？&lt;br&gt;2.既然六耳猕猴熟悉孙悟空的一切，当然就应该十分清楚如来佛祖是非常厉害的，他为什么不跑呢？还要到雷音寺去送死？这不是脑子进了水么？！&lt;br&gt;3.六耳猕猴只不过打了唐僧，既没有打死，也没有要吃唐僧肉，最多论个行凶抢劫罪，怎么说，罪不致死，为什么就把他打死了？！量刑是否过重？&lt;br&gt;4.六耳猕猴的目的是要取经，又是主动的，目标一致，如来佛应该高兴才对，这样的人才哪里找啊？把他也安排进取经的队伍，岂不是更好？&lt;br&gt;5.为什么只有如来佛一个人知道世上还存在“六耳猕猴”这一类物种？而所有的神仙包括菩萨都是闻所未闻的？难道就没一个人知道吗？&lt;br&gt;6.如果所有人都不知道有“六耳猕猴”这一类物种，那么，如来佛祖与六耳猕猴之间，究竟存在着怎样的渊源呢？&lt;/p&gt;
&lt;p&gt;六耳猕猴的下场太惨了，这个和孙悟空一样的上进青年，就这么突然之间死于非命了，可怜，可惜。&lt;br&gt;但是，这件事情的真相，真的就是这样简单么？其中究竟隐藏着怎样的内幕？&lt;br&gt;真假美猴王这一回，不知道欺骗了多少观众，死的到底是谁，先来分析分析。&lt;br&gt;其实呢，这一回中根本就没有妖怪，那个所谓的六耳猕猴并不存在。从头到尾都是孙悟空一个人捣的鬼！大家看西游记把大脑都看的僵化了，总以为孙悟空是捉妖怪的，却怎么都想不到：孙悟空也会冒充妖怪，把唐僧这个泼秃领导暴打一顿以泻私愤吧！&lt;/p&gt;
&lt;p&gt;孙悟空在这件事的起先，他是个受害者，而结果，却变成了最大的受益者，因此，孙悟空是第一嫌疑人。我们再来重新看这一幕：&lt;/p&gt;
&lt;h3 id=&quot;一、起因&quot;&gt;&lt;a href=&quot;#一、起因&quot; class=&quot;headerlink&quot; title=&quot;一、起因&quot;&gt;&lt;/a&gt;一、起因&lt;/h3&gt;&lt;p&gt;孙悟空打死了两个强盗，唐僧念经超度强盗的亡灵：拜惟好汉，我以好话，尔等不听，却遭行者，棍下伤身。你到森罗殿下兴词，他姓孙，我姓陈，各居异姓。冤有头，债有主，切莫告我取经僧人。&lt;br&gt;八戒笑道：“师父推了干净，他打时却也没有我们两个。”三藏又祷告道：“好汉告状，只告行者，也不干八戒、沙僧之事。”&lt;br&gt;孙悟空道：“师父，你老人家忒没情义。虽是我动手打，却也只是为你。你不往西天取经，我不与你做徒弟，怎么会来这里打杀人！”然后骂道：“触恼了我的性子，将你打死了，尽你到那里去告，我老孙是不怕，玉帝认得我，天王随得我；二十八宿惧我，九曜星官怕我；十代阎君曾与我为仆从，五路猖神曾与我当后生；三界五司，十方诸宰，都与我情深面熟，随你那里去告！”&lt;br&gt;这绝对是在恐吓唐僧，把老子惹火了，连你也打死，你去告吧！&lt;br&gt;三藏见他说出这般恶话，心惊肉跳道：“徒弟呀，你怎么就认真起来？”&lt;br&gt;晚上，在老杨家借宿，老杨的儿子是强盗一伙，孙悟空又打死了二三十个强盗，还把老杨儿子的头割下来，拧给唐僧看。&lt;br&gt;唐僧大惊，念起《紧箍儿咒》，把个行者勒得耳红面赤，眼胀头昏，在地下打滚，翻筋斗，竖蜻蜓，疼痛难禁。把大圣咒倒在地，箍儿陷在肉里有一寸来深浅。并威胁道：“快走！迟了些儿，我又念真言，这番决不住口，把你脑浆都勒出来哩！”&lt;br&gt;这是唐僧第三次赶孙悟空滚蛋。西天路走了一大半了，眼看就要出成果了，他要他滚蛋！&lt;br&gt;大圣疼痛难忍，忽然省悟道：“这和尚负了我心。”&lt;br&gt;于是，孙悟空发怒了，终于撕破脸皮反了目：你这泼秃！没了俺老孙，连口水都没得喝，还这般刁难俺，不给点颜色看看，你就不知道俺老孙的狠气！我管你是哪个！一棒子将唐僧打晕在地，扬长而去。丢下了这样一句话：“你这个狠心的泼秃，十分贱我！”&lt;/p&gt;
&lt;h3 id=&quot;二、经过&quot;&gt;&lt;a href=&quot;#二、经过&quot; class=&quot;headerlink&quot; title=&quot;二、经过&quot;&gt;&lt;/a&gt;二、经过&lt;/h3&gt;&lt;p&gt;沙僧来找他算帐，他说没有，绝对没有的事，俺老孙怎会干这样的缺德事呢，你若不信，菩萨可以作证嘛，我这几天一直都在这儿。&lt;br&gt;沙僧当然不信，因为你会架筋斗云，又会分身法。于是，菩萨叫沙僧与悟空同去见个真假。结果，沙僧看到了两个一模一样的孙悟空，长相、声音、本领都是一样的。这些条件是妖怪有可能具备的，可是，最重要的证据金箍棒、紧箍咒也是一样的，而这两个条件是妖怪不可能具备的。这就说明根本没有假的，这明摆着是孙悟空使的分身法嘛！&lt;br&gt;孙悟空上天庭借照妖镜，鉴定结果：两个都是真的。玉帝当然辨不出哪个假。“这大圣呵呵冷笑，那行者也哈哈欢喜”，就说明他正在暗自得意：嘿嘿！你们谁都想不到吧！&lt;br&gt;到阎罗殿去查，谛听是知道真相的，却不敢当面说破，否则，孙悟空不打死他才怪，发起恶来，把阎罗殿都拆了！&lt;br&gt;孙悟空走到哪儿都问的理直气壮：“你们看我两个谁是假的！”都辨不出，因为根本没有假的。他的目的就是要闹得让天、地、神、人、鬼尽知，不是俺老孙打的你这泼秃，而是你这泼秃缺了俺老孙就会碰到妖怪。&lt;/p&gt;
&lt;h3 id=&quot;三、结果&quot;&gt;&lt;a href=&quot;#三、结果&quot; class=&quot;headerlink&quot; title=&quot;三、结果&quot;&gt;&lt;/a&gt;三、结果&lt;/h3&gt;&lt;p&gt;最后闹到雷音寺，孙悟空与如来佛说的话，和在前面别处说的是有区别的，他先说这一路上我这般辛苦，不知费了多少精神，师父却把我赶出来。现在，请佛祖与&lt;em&gt;**&lt;/em&gt;辨明邪正，我才好保唐僧过来把佛经取回东土，帮你永传大教。&lt;br&gt;注意：他说的是辨明邪正，不是辨明真假，而在前面别处他都是说的辨个真假。这个区别是相当大的，真假，是指两个人谁真谁假，邪正，是问我的行为对不对，请如来公断。&lt;br&gt;孙悟空这点分身术的小把戏，又岂能瞒得过如来佛？！在他还没来之前，如来佛就已经对大众说了：“汝等俱是一心，且看他二心斗来。”你们这些人呀，一心要看他谁真谁假，又岂能识破他的二心呢？根本就不是两个人，是二心也，孙猴子生了二心，把老师都打了！你们却以为是妖怪。&lt;br&gt;但是，这能说吗？一说破，就无法收场了，这个经就彻底的取不成了！如来的计划就破产了！所以，大局为重，如来佛也不能说破，不但不能说，反而还要很默契地配合他假戏真做！所以如来才杜撰出一个谁也没听说、没见过、根本就不存在的六耳猕猴来。&lt;br&gt;原著中这样写道：如来正欲道破，忽见…，如来笑道：我观假悟空乃六耳猕猴也。&lt;br&gt;孙悟空没想到如来佛会瞎扯，很是震惊，不知道如来要干什么，如来也没有辨真假，而是直接吓唬猴子：“悟空休动，待我与你擒住他。”悟空生怕被抓住把柄，急变蜂儿飞跑。大众不知，以为走了。如来笑云：“汝等休要再言，妖精未走，在我钵盂之下。”将钵盂揭起，果见一六耳猕猴。&lt;br&gt;孙大圣忍不住，将其打死。“忍不住”这三字用的好啊，悟空的心理素质到底比不上如来佛祖。佛法无边的如来总算帮神通广大的悟空把这个弥天大谎撒团圆了，皆大欢喜。&lt;br&gt;大圣叩头谢道：“上告如来：那师父若不要我，却不又枉劳一番神思！还是放我还俗去罢。”如来道：“你休乱想，切莫放刁，我教观音送你，不怕他不收。好生保护他去，那时功成归极乐，汝亦坐莲台。”&lt;br&gt;经过这一场闹剧，孙悟空明确的被如来内定为预备佛员，这是对他敢打师父的一种肯定，一种奖励！唐僧呢，这个刁酸无能的泼秃领导吃了哑巴亏，白挨了一顿揍。这种人欠揍，揍他一顿，他自然就老实了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;看《西游记》第五十七回，说是“六耳猕猴”化作孙悟空的摸样，伤了唐僧，后又和孙悟空大打出手。。。这位假孙悟空，实力不用多说了吧，和真孙悟空一般无二，大战孙悟空，闹到上天入地下海。在唐僧那：念紧箍咒，两个都喊疼，自然看不出哪个真假；到天宫：拖塔天王拿照妖镜照，也看不出；又到观音
    
    </summary>
    
    
      <category term="西游记" scheme="http://mmrxia.github.io/tags/%E8%A5%BF%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>西天取经路上只有一个妖怪</title>
    <link href="http://mmrxia.github.io/2016/05/14/%E8%A5%BF%E5%A4%A9%E5%8F%96%E7%BB%8F%E8%B7%AF%E4%B8%8A%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%A6%96%E6%80%AA/"/>
    <id>http://mmrxia.github.io/2016/05/14/西天取经路上只有一个妖怪/</id>
    <published>2016-05-14T01:26:48.000Z</published>
    <updated>2016-05-17T07:04:29.535Z</updated>
    
    <content type="html">&lt;h3 id=&quot;白骨精是谁？&quot;&gt;&lt;a href=&quot;#白骨精是谁？&quot; class=&quot;headerlink&quot; title=&quot;白骨精是谁？&quot;&gt;&lt;/a&gt;&lt;strong&gt;白骨精是谁？&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;白骨精是白虎岭上一具女尸的骨架，受天地精华后，变成的妖精。西游记里并没有记载这具女尸到底是什么来历。在明末清初的一些民间小说和故事书中零星有些记载，大致是，白骨精原本是白虎岭上一户普通人家的女儿。长到十七八岁的时候，被当地富户强行掠走。遭到淫虐后，被遗弃荒山，冻饿而死。&lt;/p&gt;
&lt;p&gt;她死的时候恰好是农历七月十五，是天地阴阳相合的日子，所以冤魂没能上天入地，而是在人间游荡。虽是游荡，但一直不肯离开自己的尸体，直至尸体化为白骨。姑娘的游魂吸取天地精华，围绕白骨，化为人形，从此对人恨之入骨，以吸人血为生。由于修炼的年岁太少，她只有一般的变化法力，属于妖界微不足道的小角色。&lt;/p&gt;
&lt;p&gt;妖是什么？其实是天上神仙的奴隶。所有修炼到一定果位的神仙，都会到妖界选一个坐骑，能成为神仙坐骑，是所有妖精最快的上升通道。修炼很苦，只有成为神仙才能上升到贵族阶层，从此不再遭受妖界的痛苦与磨砺。白骨精之所以会选择唐僧下手，是因为她无论如何修炼，都没有机会做神仙。&lt;/p&gt;
&lt;p&gt;你想，哪位神仙会选一堆白骨作坐骑啊？每次神仙来妖界选坐骑，她都会去应聘，但每次都失败。她已经放弃了通过当坐骑上升的门道，而是选择走捷径。当听说吃了唐僧肉便可长生不老，成为神仙时，她毫不犹豫地盯上了唐僧师徒。尽管她知道自己不是孙悟空的对手，但还是选择下手。因为，她已经无路可走。&lt;/p&gt;
&lt;h3 id=&quot;唐僧是谁？&quot;&gt;&lt;a href=&quot;#唐僧是谁？&quot; class=&quot;headerlink&quot; title=&quot;唐僧是谁？&quot;&gt;&lt;/a&gt;&lt;strong&gt;唐僧是谁？&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;为什么白骨精遇到唐僧师徒会有那么强烈的戏剧性？我们先来看下这帮取经人是什么身份。先看唐僧，其实他是如来二弟子金蝉长老转世。他去人间转世投胎的理由很简单——轻慢佛法，被如来打入凡尘。如来真的对他很失望吗？其实没有。他刚被打入凡尘后，如来就后悔了。但是，作为佛界的一把手，他也不能出尔反尔啊。&lt;/p&gt;
&lt;p&gt;如来心里的小九九早被观音菩萨看到了。喜欢察言观色的观音菩萨以宣传佛法为理由，启动了取经工程。这么大的机会，无论给谁都能成佛，获得果位。观音菩萨去人间辛苦选角回来，告诉如来，除了如来朝思暮想的金蝉长老转世的陈玄奘外，没有人能完成这项工程。如来一听很高兴，就让观音菩萨操办去了。&lt;/p&gt;
&lt;p&gt;作为取经形象工程的总策划，观音菩萨办事非常周密。她先找来各路菩萨和神仙，希望大家都能为这项工程出点力。尤其是应该让自家的坐骑妖怪都出来捣捣乱，也显示下取经的难度，同时也在关键时刻露露脸，让如来知道，大家都一心向着中央，一直在帮助金蝉长老过关。各路菩萨走后，观音菩萨找到陈玄奘，告诉他，妖怪都是自家人放出来的，为了显示取经的难度，让如来重用他，也算是好有个台阶下。&lt;/p&gt;
&lt;p&gt;唐僧很聪明，一心想回灵山，所以当然愿意了。不过，所有的事情都没那么简单。天上也有人事关系，天上也有潜规则。观音菩萨张罗了一个这么好的取经工程，谁参与谁都会功成名就，那肯定一帮人惦记着。同时，观音菩萨自己也不会放过这次机会啊。所以他选择的第一个参与项目的人就是孙悟空。&lt;/p&gt;
&lt;h3 id=&quot;孙悟空那些事&quot;&gt;&lt;a href=&quot;#孙悟空那些事&quot; class=&quot;headerlink&quot; title=&quot;孙悟空那些事&quot;&gt;&lt;/a&gt;&lt;strong&gt;孙悟空那些事&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;不要以为观音菩萨选孙悟空是因为他能打能杀，可以保唐僧去取经。其实与这些一点毛关系都没有。孙悟空是谁？其实他是菩提老祖的私生子。小时候，他只可以看到菩提老祖，却看不到妈妈，就很好奇问老祖，他是哪儿来的。菩提老祖告诉他，他是石头缝里变出来的。一向傻乐呵的孙悟空快1千岁的时候才知道自己的真实身世。&lt;/p&gt;
&lt;p&gt;菩提老祖的这个秘密只有观音菩萨知道。观音菩萨为什么会帮菩提老祖保守秘密呢？是因为菩提老祖太牛逼了。他是谁？他是成佛比如来还早的佛陀。由于如来的佛法更高深，年龄与佛龄都高于如来的菩提老祖，甘愿成为如来的追随者。如来让菩提老祖三分，一直另眼相看。菩提老祖在佛教中是须菩提，他与佛祖的对话便是《金刚经》。&lt;/p&gt;
&lt;p&gt;实际上，菩提老祖是儒释道精通的神仙，法力高于如来，但又遵从如来。菩提老祖就孙悟空一个儿子，所以一直很娇惯他。他私下教会了孙悟空很多法力，并禁止孙悟空叫他师傅，也不允许他在任何场合提到自己。孙悟空与菩提老祖闹翻，跑了出去。菩提老祖怕他惹事，便把孙悟空托付给观音菩萨管教。&lt;/p&gt;
&lt;p&gt;观音菩萨哪管得了他，他兴风作浪，干了很多坏事。尤其是把玉皇大帝都给揍了。如来本来要灭了他，结果观音菩萨暗示他不要这样做，如来领会，就把孙悟空压到五行山下五百年。菩提老祖与如来都是大牛，观音菩萨谁都不敢得罪，所以她一直等待机会救出孙悟空，给菩提老祖一个交代。&lt;/p&gt;
&lt;p&gt;这不，唐僧取经的工程资金都批下来了，没什么比随唐僧取经更合适的项目了。一来让如来有台阶下，二来也是给菩提老祖一个面子，算是完成了托付的重任。一开始，唐僧非常讨厌孙悟空，绝对不想和他合作。唐僧心里清楚，所有的妖怪都是观音菩萨阿姨找来的托儿，一旦孙猴子胡乱打，岂不是全给得罪了。&lt;/p&gt;
&lt;h3 id=&quot;其他的关系户&quot;&gt;&lt;a href=&quot;#其他的关系户&quot; class=&quot;headerlink&quot; title=&quot;其他的关系户&quot;&gt;&lt;/a&gt;&lt;strong&gt;其他的关系户&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;不要以为唐僧、悟空外的几个人就清白了。猪八戒是天蓬元帅，掌管天河，所谓天河不过是银河罢了。也就是说，猪八戒是银河系的一把手。实际上他是紫薇大帝手上最亮的一颗星——北斗七星中最亮的一颗。紫薇大帝的坐骑是北斗七星，而猪八戒是最亮的一颗。他被贬下界是因为他把嫦娥给睡了。很多人不知道，玉帝把嫦娥带到天庭原本想娶他为妃，无奈王母娘娘很不高兴，发动自家亲戚的力量，差点毁了玉帝的统治。&lt;/p&gt;
&lt;p&gt;让嫦娥当舞女是玉帝与王母相互妥协的结果。玉帝每天看嫦娥跳舞，却睡不得，这让他很扫兴。嫦娥在广寒宫整天思春，郁闷不乐。猪八戒跑过去陪她聊天，并成功把嫦娥给睡了。这件事让玉帝火冒三丈，于是把猪八戒贬入凡尘。自己最喜欢的坐骑没了，紫薇大帝很不高兴，猪八戒是他最喜欢的坐骑。然而，如来扫平魔界，建立佛国世界时，紫薇大帝一直是所有光明的提供者，照亮如来的路，如来一直无以为报。观音菩萨于是找到凡间流浪的猪八戒，将他编入了取经队伍，算是对紫薇大帝一个交代。&lt;/p&gt;
&lt;p&gt;沙和尚是谁？他是卷帘大将，但真实的身份是玉皇大帝四女儿四仙女的相好。玉帝知道他与女儿相好后，便以打碎了某某东东为由，将他打入凡尘。王母支持四女儿，反抗玉帝，让玉帝很后悔自己的决定。当观音菩萨刚宣布要组织取经工程时，王母娘娘就知道了这件事。为了自己女儿的幸福，她拿一箩筐蟠桃，让观音菩萨把沙悟净也编入了取经队伍。&lt;/p&gt;
&lt;p&gt;小白龙更不用说了。他是西海龙王的三太子，因为纵火烧了玉帝赏赐的明珠而被判斩首。结果观音菩萨求情，免于一死，被压在了山涧里。你可能会奇怪，观音菩萨为什么会为小白龙说情。其实是这样的，观音菩萨又叫南海观音，她常驻的地方在南海。南海是南海龙王的地盘，也就是小白龙叔叔的地盘。&lt;/p&gt;
&lt;p&gt;三太子很小时的时候经常去观音菩萨那里玩，观音菩萨很喜欢他，视若己出。他犯事后，把他压在山涧里加以保护也是观音菩萨的主意。取经工程刚出来消息，西海龙王、南海龙王、东海龙王、北海龙王全都齐聚南海，求观音帮忙。把小白龙安排进来也是顺理成章的事情。&lt;/p&gt;
&lt;h3 id=&quot;为什么不能降妖？&quot;&gt;&lt;a href=&quot;#为什么不能降妖？&quot; class=&quot;headerlink&quot; title=&quot;为什么不能降妖？&quot;&gt;&lt;/a&gt;&lt;strong&gt;为什么不能降妖？&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;唐僧师徒几个，唯有唐僧心里最清楚，路上根本没有什么妖怪，都是自己人当托的。所以吗，见到妖怪不要随便打，一不小心就打到自己的亲戚了。再说，观音菩萨一直背后跟着，真实遇到了妖怪猛兽，观音会保证安全的。&lt;/p&gt;
&lt;p&gt;孙悟空等四个却不知道妖怪的真实身份，再加上他们本来就很暴烈，一上路就烧杀抢掠。为了限制孙悟空，唐僧再三要求观音菩萨要驯服他。菩萨选了折衷的办法，给他戴上了紧箍。尽管如此，孙悟空依然野性不改。打白骨精是唐僧与孙悟空矛盾的最高点。&lt;/p&gt;
&lt;p&gt;白骨精是唐僧取经路上唯一一个真妖怪，她目标明确，就是要吃唐僧肉，成为神仙，逃离魔界的痛苦。白骨精被打死后，唐僧吓死了。如果这个白骨精是某个菩萨手上的人或坐骑，那他的取经工程就有可能被叫停。所以他第一时间念了紧箍咒，把孙猴子赶走了。&lt;/p&gt;
&lt;p&gt;观音菩萨去请孙猴子回来，没跟他说实话，但点拨了他，告诉他，只要发现妖怪，去菩萨们那里问问就好了。孙悟空得到点拨后学精了，一旦遇到妖怪，并不好好打，而是先跑到天上打听一番，是谁家的，谁来管管。结果，一路上很顺利，几乎没遇到任何真正的危险便到了灵山，取了真经。&lt;/p&gt;
&lt;h3 id=&quot;结尾&quot;&gt;&lt;a href=&quot;#结尾&quot; class=&quot;headerlink&quot; title=&quot;结尾&quot;&gt;&lt;/a&gt;&lt;strong&gt;结尾&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;看了上面的分析你是否有种无奈的感觉？&lt;br&gt;白骨精的故事是中国流传数百年的悲剧——屌丝向上爬的道路永远是不通的；没有背景和身份是没法做大事的；一切形象工程都有同样的逻辑。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;白骨精是谁？&quot;&gt;&lt;a href=&quot;#白骨精是谁？&quot; class=&quot;headerlink&quot; title=&quot;白骨精是谁？&quot;&gt;&lt;/a&gt;&lt;strong&gt;白骨精是谁？&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;白骨精是白虎岭上一具女尸的骨架，受天地精华后，变成的妖精。西游记里并没有记
    
    </summary>
    
    
      <category term="西游记" scheme="http://mmrxia.github.io/tags/%E8%A5%BF%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>js浮点数计算精度丢失问题及解决方案</title>
    <link href="http://mmrxia.github.io/2016/05/11/js%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/"/>
    <id>http://mmrxia.github.io/2016/05/11/js浮点数计算精度丢失问题/</id>
    <published>2016-05-11T09:22:45.000Z</published>
    <updated>2016-09-09T02:30:29.348Z</updated>
    
    <content type="html">&lt;p&gt; 本文主要从以下3个方面来说明：&lt;/p&gt;
&lt;p&gt; 1 . js浮点数计算精度丢失常见现象&lt;br&gt; 2 . js浮点数计算精度丢失原因&lt;br&gt; 3 . js浮点数计算精度丢失解决办法&lt;/p&gt;
&lt;h3 id=&quot;一、常见现象&quot;&gt;&lt;a href=&quot;#一、常见现象&quot; class=&quot;headerlink&quot; title=&quot;一、常见现象&quot;&gt;&lt;/a&gt;一、常见现象&lt;/h3&gt;&lt;p&gt; 1 . 两个简单的浮点数相加或相乘&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 0.1 + 0.2 != 0.3 // true  0.30000000000000004
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 又如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 0.29 * 100  // 28.999999999999996
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 2 . 大整数运算&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 9999999999999999 == 10000000000000001 // true  16位和17位数竟然相等...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 又如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; var x = 9007199254740992
 x + 1 == x // true
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;二、原因&quot;&gt;&lt;a href=&quot;#二、原因&quot; class=&quot;headerlink&quot; title=&quot;二、原因&quot;&gt;&lt;/a&gt;二、原因&lt;/h3&gt;&lt;p&gt; &lt;strong&gt;计算机的二进制实现和位数限制有些数无法有限表示。&lt;/strong&gt;&lt;br&gt; 就像一些无理数不能有限表示，如 圆周率 3.1415926…，1.3333… 等。JS 遵循 &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;IEEE 754&lt;/a&gt; 规范，采用双精度存储（double precision），占用 64 bit。如图：&lt;br&gt; &lt;img src=&quot;http://7xth8v.com2.z0.glb.clouddn.com/image/n_64bit.png?imageView2/2/w/800&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt; 图中的意义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1位用来表示符号位&lt;/li&gt;
&lt;li&gt;11位用来表示指数&lt;/li&gt;
&lt;li&gt;52位表示尾数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 浮点数，比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 0.1 &amp;gt;&amp;gt; 0.0001 1001 1001 1001…（1001无限循环）
 0.2 &amp;gt;&amp;gt; 0.0011 0011 0011 0011…（0011无限循环）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 此时只能模仿十进制进行四舍五入了，但是二进制只有 0 和 1 两个，于是变为 0 舍 1 入。这即是计算机中部分浮点数运算时出现误差，丢失精度的根本原因。&lt;br&gt; 大整数的精度丢失和浮点数本质上是一样的，尾数位最大是 52 位，因此 JS 中能精准表示的最大整数是 &lt;code&gt;Math.pow(2, 53)&lt;/code&gt;，十进制即 &lt;code&gt;9007199254740992&lt;/code&gt;。&lt;br&gt; 大于 &lt;code&gt;9007199254740992&lt;/code&gt; 的可能会丢失精度。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 9007199254740992     &amp;gt;&amp;gt; 10000000000000...000 // 共计 53 个 0
 9007199254740992 + 1 &amp;gt;&amp;gt; 10000000000000...001 // 中间 52 个 0
 9007199254740992 + 2 &amp;gt;&amp;gt; 10000000000000...010 // 中间 51 个 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 实际上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 9007199254740992 + 1 // 丢失
 9007199254740992 + 2 // 未丢失
 9007199254740992 + 3 // 丢失
 9007199254740992 + 4 // 未丢失
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 以上，可以知道看似有穷的数字, 在计算机的二进制表示里却是无穷的，由于存储位数限制因此存在“舍去”，精度丢失就发生了。&lt;/p&gt;
&lt;p&gt; 想了解更深入的分析可以看这篇论文：&lt;a href=&quot;http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;What Every Computer Scientist Should Know About Floating-Point Arithmetic&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;三、解决方案&quot;&gt;&lt;a href=&quot;#三、解决方案&quot; class=&quot;headerlink&quot; title=&quot;三、解决方案&quot;&gt;&lt;/a&gt;三、解决方案&lt;/h3&gt;&lt;p&gt; 对于整数，前端出现问题的几率可能比较低，毕竟很少有业务需要需要用到超大整数，只要运算结果不超过 &lt;code&gt;Math.pow(2, 53)&lt;/code&gt; 就不会丢失精度。&lt;br&gt; 对于小数，前端出现问题的几率还是很多的，尤其在一些电商网站涉及到金额等数据。解决方式：把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数），如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; // 0.1 + 0.2
 (0.1*10 + 0.2*10) / 10 == 0.3 // true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 代码实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt; var Calc = function () {
     /*
      * 将浮点数去除小数点，返回整数和倍数。如 3.14 &amp;gt;&amp;gt; 314，倍数是 100
      * @param n {number} 浮点数
      * return {object}
      * {num: 314, times: 100}
      * */
     function toInt(n) {
         var n = +n, res = {num: n, times: 1};
         if (n !== (n | 0)) { //判断浮点数，n===parseInt(n)
             var arr = (&amp;#39;&amp;#39; + n).split(&amp;#39;.&amp;#39;);
             var len = arr[1].length; //小数长度
             res.times = Math.pow(10, len); //需要乘的倍数=&amp;gt;10的指数
             res.num = Math.round(n * res.times); //四舍五入取整
         }
         return res;
     }

     function operation(a, b, op) {
         var result; //最终计算的值
         var o1 = toInt(a), o2 = toInt(b);

         var n1 = o1.num, t1 = o1.times;
         var n2 = o2.num, t2 = o2.times;

         var max = Math.max(t1, t2);

         switch (op) {
             case &amp;#39;add&amp;#39;:
                 if (t1 &amp;gt; t2) {
                     result = n1 + n2 * (t1 / t2);
                 } else {
                     result = n2 + n1 * (t2 / t1);
                 }
                 result = result / max;
                 break;
             case &amp;#39;subtract&amp;#39;:
                 if (t1 &amp;gt; t2) {
                     result = n1 - n2 * (t1 / t2);
                 } else {
                     result = n1 * (t2 / t1) - n2;
                 }
                 result = result / max;
                 break;
             case &amp;#39;multiply&amp;#39;:
                 result = (n1 * n2) / (t1 * t2);
                 return result;
                 break;
             case &amp;#39;divide&amp;#39;:
                 result = (n1 / n2) * (t2 / t1);
                 return result;
                 break;

         }
         return result;
     }

     /*加*/
     function add(a, b) {
         return operation(a, b, &amp;#39;add&amp;#39;);
     }

     /*减*/
     function subtract(a, b) {
         return operation(a, b, &amp;#39;subtract&amp;#39;);
     }

     /*乘*/
     function multiply(a, b) {
         return operation(a, b, &amp;#39;multiply&amp;#39;);
     }

     /*除*/
     function divide(a, b) {
         return operation(a, b, &amp;#39;divide&amp;#39;);
     }

     //exports
     return {
         add: add,
         subtract: subtract,
         multiply: multiply,
         divide: divide
     }
 }();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;p&gt; &lt;a href=&quot;http://0.30000000000000004.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://0.30000000000000004.com&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt; 本文主要从以下3个方面来说明：&lt;/p&gt;
&lt;p&gt; 1 . js浮点数计算精度丢失常见现象&lt;br&gt; 2 . js浮点数计算精度丢失原因&lt;br&gt; 3 . js浮点数计算精度丢失解决办法&lt;/p&gt;
&lt;h3 id=&quot;一、常见现象&quot;&gt;&lt;a href=&quot;#一、常见现象&quot; class=&quot;h
    
    </summary>
    
    
      <category term="js" scheme="http://mmrxia.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>跨域的几种方式</title>
    <link href="http://mmrxia.github.io/2016/05/09/%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://mmrxia.github.io/2016/05/09/跨域的几种方式/</id>
    <published>2016-05-09T07:37:30.000Z</published>
    <updated>2016-05-09T08:06:05.872Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;跨域，怎么处理跨域问题？无论是在面试中，还是在工作当中，总是会经常被问到，所以在这里总结下跨域的几种处理方式好了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-jsonp方式&quot;&gt;&lt;a href=&quot;#1-jsonp方式&quot; class=&quot;headerlink&quot; title=&quot;1 . jsonp方式&quot;&gt;&lt;/a&gt;1 . jsonp方式&lt;/h3&gt;&lt;p&gt;在js中，我们直接用&lt;code&gt;XMLHttpRequest&lt;/code&gt;请求不同域上的数据是不可以的，而在html中，能够实现跨域的就几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;link属性（css）&lt;/li&gt;
&lt;li&gt;href属性（a标签）&lt;/li&gt;
&lt;li&gt;src（img标签、script标签）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了解决跨域的问题，结合script能够发起跨域请求的原理，产生了jsonp，即：动态的创建script标签，跨域的地址加上需要传送的数据和回调函数为script标签的src地址，执行完之后再动态的删除之前创建的script.&lt;/p&gt;
&lt;p&gt;理解了原理之后，就很容易明白jsonp的缺点了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只能用get方式请求，因为是使用src来传送数据&lt;/li&gt;
&lt;li&gt;数据中出现中文需要编码。因为通过url传参数，可以在浏览器输入地址并带上中文参数试试&lt;/li&gt;
&lt;li&gt;src对请求的地址没有限制，会出现安全性的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-document-domain&quot;&gt;&lt;a href=&quot;#2-document-domain&quot; class=&quot;headerlink&quot; title=&quot;2 . document.domain&quot;&gt;&lt;/a&gt;2 . document.domain&lt;/h3&gt;&lt;p&gt;看到这个跨域方式，可能有些同学会觉得陌生，其实这个也很常用。&lt;br&gt;每次遇到有需要使用登录之类的项目，在开发的时候都需要将地址改成163的域名，为啥？在控制台打印一下&lt;code&gt;document.domain&lt;/code&gt;试试,这篇文章的控制台输出的是&lt;code&gt;feg.netease.com&lt;/code&gt;，而在有使用到163登录的项目中，输出的都是&lt;code&gt;163.com&lt;/code&gt;。登录组件限制在163域名下才能用，但是163的域名有很多，避免不同域名之间出现通信问题，使用&lt;code&gt;document.domain&lt;/code&gt;的方式将页面的主域名改成了&lt;code&gt;163.com&lt;/code&gt;。这种方式主要用在主域名能设置成相同的页面之间的通信。如&lt;code&gt;http://xyq.163.com/&lt;/code&gt;，它的主域名可以是&lt;code&gt;xyq.163.com&lt;/code&gt;或&lt;code&gt;163.com&lt;/code&gt;；&lt;code&gt;http://xsd.163.com&lt;/code&gt;，它的主域名可以是&lt;code&gt;xsd.163.com&lt;/code&gt;或&lt;code&gt;163.com&lt;/code&gt;，所以这两个站点下的页面能够将主域名设置成163.com。&lt;/p&gt;
&lt;h3 id=&quot;3-使用iframe&quot;&gt;&lt;a href=&quot;#3-使用iframe&quot; class=&quot;headerlink&quot; title=&quot;3 . 使用iframe&quot;&gt;&lt;/a&gt;3 . 使用iframe&lt;/h3&gt;&lt;p&gt;这种方式利用了window对象name属性的特征：在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。&lt;/p&gt;
&lt;h3 id=&quot;4-Access-Control-Allow-Origin&quot;&gt;&lt;a href=&quot;#4-Access-Control-Allow-Origin&quot; class=&quot;headerlink&quot; title=&quot;4 . Access-Control-Allow-Origin&quot;&gt;&lt;/a&gt;4 . Access-Control-Allow-Origin&lt;/h3&gt;&lt;p&gt;正常情况下我们的接口都是jsonp的格式，可是万一遇到其它格式的接口怎么办？比如json格式，这个时候可以通过&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;来实现跨域。这种方式主要是后台同学配置，接口使用&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;设置对应项目的域名，前端同学这边像平常调用接口一样，不需要再做其他处理。如下面的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;   $.ajax({
       url: &amp;quot;http://api.ypw.163.com/api/app&amp;quot;,
       type: &amp;quot;POST&amp;quot;,
       data: JSON.stringify(postData),
       dataType: &amp;quot;application/json&amp;quot;,
       headers: {&amp;quot;X-Ypw-Token&amp;quot;: user_token, &amp;quot;Content-Type&amp;quot;: &amp;quot;application/json&amp;quot;},
       success: function(result) {
           renderPage(result);
       }
   });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data为需要传输的数据，dataType是接口的格式。比平常接口调用多了的headers部分，是这个接口考虑到安全性的问题，接口开发同学需要我添加一个key，并且把user_token用base64加密之后传输给他，并不是跨域需要设置的东西，即这种方式跟平常调用接口一样。&lt;br&gt;好像这种方式挺好用的。确实，可是最大的问题是ie7、8、9都还不支持，所以目前也就能用在移动端了。&lt;/p&gt;
&lt;h3 id=&quot;5-Chrome-–disable-web-security-快捷方式&quot;&gt;&lt;a href=&quot;#5-Chrome-–disable-web-security-快捷方式&quot; class=&quot;headerlink&quot; title=&quot;5 . Chrome –disable-web-security 快捷方式&quot;&gt;&lt;/a&gt;5 . Chrome –disable-web-security 快捷方式&lt;/h3&gt;&lt;p&gt;这种方式适用于Chrome浏览器，使浏览器支持跨域请求。在快捷方式的属性中配置&lt;code&gt;--args --disable-web-security --user-data-dir&lt;/code&gt;参数，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xth8v.com2.z0.glb.clouddn.com/image/n_chrome_prop.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;跨域，怎么处理跨域问题？无论是在面试中，还是在工作当中，总是会经常被问到，所以在这里总结下跨域的几种处理方式好了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-jsonp方式&quot;&gt;&lt;a href=&quot;#1-jsonp方式&quot; class=&quot;h
    
    </summary>
    
    
      <category term="跨域" scheme="http://mmrxia.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>git 常用命令速查表</title>
    <link href="http://mmrxia.github.io/2016/05/09/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
    <id>http://mmrxia.github.io/2016/05/09/git-常用命令速查表/</id>
    <published>2016-05-09T07:17:43.000Z</published>
    <updated>2016-05-09T07:34:05.237Z</updated>
    
    <content type="html">&lt;p&gt;git作为代码管理工具的好处，这里就不多说了，目前也有很多git操作的可视化工具，如：TortoiseGit、SourceTree等。&lt;br&gt;相比可视化工具，笔者还是更喜欢使用原始命令来进行操作，下面附一张git常用命令速查表，以备不时之需。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xth8v.com2.z0.glb.qiniucdn.com/image/git_common_order.jpg&quot; alt=&quot;git常用命令&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;git作为代码管理工具的好处，这里就不多说了，目前也有很多git操作的可视化工具，如：TortoiseGit、SourceTree等。&lt;br&gt;相比可视化工具，笔者还是更喜欢使用原始命令来进行操作，下面附一张git常用命令速查表，以备不时之需。&lt;/p&gt;
&lt;p&gt;&lt;img src
    
    </summary>
    
    
      <category term="git" scheme="http://mmrxia.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>SKU算法总结分享</title>
    <link href="http://mmrxia.github.io/2016/04/26/SKU%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E5%88%86%E4%BA%AB/"/>
    <id>http://mmrxia.github.io/2016/04/26/SKU算法总结分享/</id>
    <published>2016-04-26T08:28:49.000Z</published>
    <updated>2016-11-14T08:22:29.646Z</updated>
    
    <content type="html">&lt;h4 id=&quot;1-SKU简介&quot;&gt;&lt;a href=&quot;#1-SKU简介&quot; class=&quot;headerlink&quot; title=&quot;1. SKU简介&quot;&gt;&lt;/a&gt;1. SKU简介&lt;/h4&gt;&lt;p&gt;下面是SKU来自维基百科的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;最小存货单位&lt;/strong&gt;（Stock Keeping Unit, SKU）是一个会计学名词，定义为保存库存控制的最小可用单位，例如纺织品中一个SKU通常表示规格、颜色、款式，而在连锁零售门店中有时称单品为一个SKU。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;直观一点的实际应用，可以参考淘宝的商品SKU选择界面，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xth8v.com2.z0.glb.qiniucdn.com/image/sku.png&quot; alt=&quot;&quot;&gt;              &lt;/p&gt;
&lt;h4 id=&quot;2-基础数据&quot;&gt;&lt;a href=&quot;#2-基础数据&quot; class=&quot;headerlink&quot; title=&quot;2. 基础数据&quot;&gt;&lt;/a&gt;2. 基础数据&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;    //属性集
    var keys = [
        [&amp;#39;10&amp;#39;],  //iPhone7s
        [&amp;#39;20&amp;#39;,&amp;#39;21&amp;#39;,&amp;#39;22&amp;#39;,&amp;#39;23&amp;#39;,&amp;#39;24&amp;#39;],  //土豪金,白色,黑色,灰色,粉色
        [&amp;#39;30&amp;#39;,&amp;#39;31&amp;#39;,&amp;#39;32&amp;#39;,&amp;#39;33&amp;#39;,&amp;#39;34&amp;#39;,&amp;#39;35&amp;#39;,&amp;#39;36&amp;#39;,&amp;#39;37&amp;#39;,&amp;#39;38&amp;#39;],  //港版，大陆行货，亚太版，美版，韩版，日版，意大利版，俄罗斯版，欧版
        [&amp;#39;40&amp;#39;] //4.7寸
    ];
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;    //后台读取结果集
    var data = {
        &amp;quot;10;24;31;40&amp;quot;:{&amp;quot;price&amp;quot;:366,&amp;quot;count&amp;quot;:46},
        &amp;quot;10;24;33;40&amp;quot;:{&amp;quot;price&amp;quot;:416,&amp;quot;count&amp;quot;:77},
        &amp;quot;10;24;34;40&amp;quot;:{&amp;quot;price&amp;quot;:456,&amp;quot;count&amp;quot;:9},
        &amp;quot;10;24;35;40&amp;quot;:{&amp;quot;price&amp;quot;:371,&amp;quot;count&amp;quot;:33},
        &amp;quot;10;24;36;40&amp;quot;:{&amp;quot;price&amp;quot;:411,&amp;quot;count&amp;quot;:79},
        &amp;quot;10;24;37;40&amp;quot;:{&amp;quot;price&amp;quot;:421,&amp;quot;count&amp;quot;:87},
        &amp;quot;10;24;38;40&amp;quot;:{&amp;quot;price&amp;quot;:461,&amp;quot;count&amp;quot;:9},
        &amp;quot;10;23;32;40&amp;quot;:{&amp;quot;price&amp;quot;:406,&amp;quot;count&amp;quot;:9},
        &amp;quot;10;23;33;40&amp;quot;:{&amp;quot;price&amp;quot;:416,&amp;quot;count&amp;quot;:90},
        &amp;quot;10;23;36;40&amp;quot;:{&amp;quot;price&amp;quot;:411,&amp;quot;count&amp;quot;:90},
        &amp;quot;10;23;37;40&amp;quot;:{&amp;quot;price&amp;quot;:421,&amp;quot;count&amp;quot;:10},
        &amp;quot;10;23;38;40&amp;quot;:{&amp;quot;price&amp;quot;:461,&amp;quot;count&amp;quot;:9},
        &amp;quot;10;22;35;40&amp;quot;:{&amp;quot;price&amp;quot;:361,&amp;quot;count&amp;quot;:25},
        &amp;quot;10;21;33;40&amp;quot;:{&amp;quot;price&amp;quot;:416,&amp;quot;count&amp;quot;:10},
        &amp;quot;10;21;38;40&amp;quot;:{&amp;quot;price&amp;quot;:461,&amp;quot;count&amp;quot;:80},
        &amp;quot;10;21;30;40&amp;quot;:{&amp;quot;price&amp;quot;:356,&amp;quot;count&amp;quot;:43},
        &amp;quot;10;20;31;40&amp;quot;:{&amp;quot;price&amp;quot;:356,&amp;quot;count&amp;quot;:46},
        &amp;quot;10;20;32;40&amp;quot;:{&amp;quot;price&amp;quot;:396,&amp;quot;count&amp;quot;:49},
        &amp;quot;10;20;35;40&amp;quot;:{&amp;quot;price&amp;quot;:361,&amp;quot;count&amp;quot;:34},
        &amp;quot;10;20;36;40&amp;quot;:{&amp;quot;price&amp;quot;:401,&amp;quot;count&amp;quot;:41},
        &amp;quot;10;20;30;40&amp;quot;:{&amp;quot;price&amp;quot;:346,&amp;quot;count&amp;quot;:3}
    };
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;3-算法分析&quot;&gt;&lt;a href=&quot;#3-算法分析&quot; class=&quot;headerlink&quot; title=&quot;3. 算法分析&quot;&gt;&lt;/a&gt;3. 算法分析&lt;/h4&gt;&lt;p&gt;重点在于排列组合出所有的属性集，和后台读取的结果集进行比对；&lt;/p&gt;
&lt;h4 id=&quot;4-代码实现&quot;&gt;&lt;a href=&quot;#4-代码实现&quot; class=&quot;headerlink&quot; title=&quot;4. 代码实现&quot;&gt;&lt;/a&gt;4. 代码实现&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/*
 * sku算法
 * by xqs 16.08.11
 * */

define(function (require, exports, module) {

    &amp;#39;use strict&amp;#39;;

    //按钮样式class
    var className = {
        sku: &amp;#39;sku-key&amp;#39;,
        active: &amp;#39;active&amp;#39;,
        disabled: &amp;#39;ban&amp;#39;
    };

    //sku对象
    var sku = {
        delimiter: &amp;#39;b&amp;#39;      //分隔符
    };


    //初始化，组合新的结果集
    sku.init = function (container) {

        console.time(&amp;#39;skuInit time&amp;#39;);

        sku.container = $(container);  //存储skuData的外容器

        var data = $(container).data(&amp;#39;sku-map&amp;#39;);
        if (!data || sku.container.data(&amp;#39;initialized&amp;#39;)) return;
        //console.log(JSON.stringify(data))

        var skuMap = sku.skuMap = {};  //sku结果集

        //拿到已有skuMap中所有的sku组合key
        var skuKeys = $.map(data, function (val, key) {
            if (!val.count) val.count = 0;
            return key;
        });
        //console.log(skuKeys, skuMap)

        //转换成数组后，排列组合计算出所有的可能，存储在skuMap中
        $.each(skuKeys, function (i, v) {
            var keyArr = v.split(sku.delimiter).sort(function (a, b) {
                    return parseInt(a) - parseInt(b);
                }),
                combArr = sku.combineArr(keyArr);
            //console.log(JSON.stringify(combArr))

            var skuInfo = data[v];
            $.each(combArr, function (j, k) {
                if (skuMap[k]) {
                    skuMap[k].count += skuInfo.count;
                    skuMap[k].prices.push(skuInfo.price);
                    $.unique(skuMap[k].prices);  //数组去重
                } else {
                    skuMap[k] = {
                        count: skuInfo.count,
                        prices: [skuInfo.price]
                    }
                }
            });

            //已有的skuMap中的信息存储到skuMap中,替换原有的key
            skuMap[keyArr.join(sku.delimiter)] = $.extend(null, {
                count: skuInfo.count,
                prices: [skuInfo.price]
            }, skuInfo);

        });

        sku.container.data(&amp;#39;initialized&amp;#39;, true);

        //打印一下sku字典拼装花费的时间
        console.timeEnd(&amp;#39;skuInit time&amp;#39;);

        console.info(JSON.stringify(skuMap));


        //点击sku选项
        var showPrice, showPic, skuDesc,
            defaultPrice = $(&amp;#39;.sku-price&amp;#39;).text(),
            defaultPic = $(&amp;#39;.sku-pic&amp;#39;).attr(&amp;#39;src&amp;#39;),
            defaultDesc = &amp;#39;请选择&amp;#39; + $.map(sku.container.find(&amp;#39;dl dt&amp;#39;), function (item) {
                    return $(item).text();
                }).join(&amp;#39;,&amp;#39;);

        //初始化渲染
        $(&amp;#39;.sku-desc&amp;#39;).html(defaultDesc);

        //未选择之前，先检查一下状态
        sku.container.find(&amp;#39;.&amp;#39; + className.sku).each(function () {
            //先初始化一下，看看是否所有的按钮都可选
            var $this = $(this);
            if (!skuMap[$this.data(&amp;#39;value&amp;#39;)]) {
                $this.addClass(className.disabled).removeClass(className.active);
            } else {
                $this.removeClass(className.disabled);
            }
        }).end().off(&amp;#39;click&amp;#39;).on(&amp;#39;click&amp;#39;, &amp;#39;.&amp;#39; + className.sku, function () {
            //添加click事件
            var $this = $(this);

            if ($this.hasClass(className.disabled)) return false;

            //选中自己，取消兄弟元素选中状态
            $this.toggleClass(className.active).siblings().removeClass(className.active);

            //已选择的sku按钮信息
            var skuSelected = sku.selected();
            if (skuSelected.keys.length) {
                var skuSelectedKey = skuSelected.keys.join(sku.delimiter);
                //console.info(&amp;#39;skuKey==&amp;#39;, skuSelectedKey);

                //显示价格区间及sku描述等信息
                var minPrice = Math.min.apply(null, skuMap[skuSelectedKey].prices),
                    maxPrice = Math.max.apply(null, skuMap[skuSelectedKey].prices);

                showPrice = minPrice === maxPrice ? [&amp;#39;￥&amp;#39;, maxPrice].join(&amp;#39;&amp;#39;) : [&amp;#39;￥&amp;#39;, minPrice, &amp;#39;-&amp;#39;, maxPrice].join(&amp;#39;&amp;#39;);
                skuMap[skuSelectedKey].itemPic &amp;amp;&amp;amp; (showPic = skuMap[skuSelectedKey].itemPic);
                skuDesc = $.map(skuSelected.desc, function (v, i) {
                    return &amp;#39;&amp;lt;span&amp;gt;&amp;#39; + v + &amp;#39;&amp;lt;/span&amp;gt;&amp;#39;;
                }).join(&amp;#39;&amp;#39;);

                //限购数量
                var limitCount = skuSelected.detail &amp;amp;&amp;amp; skuSelected.detail.limit ? skuSelected.detail.limit : null;
                sku.container.siblings(&amp;#39;.quantity&amp;#39;).find(&amp;#39;.number&amp;#39;).data(&amp;#39;max&amp;#39;, limitCount).spinner();  //改变数量控制;

                //验证其他sku按钮
                var $skuOthers = $(&amp;#39;.&amp;#39; + className.sku).not(&amp;#39;.&amp;#39; + className.active).not($this);
                $.each($skuOthers, function () {
                    var $that = $(this), $sibSelected = $that.siblings(&amp;#39;.&amp;#39; + className.active);
                    var othersArr = [];
                    if ($sibSelected[0]) {
                        //同级别的sku已有选择，则在新数组中取出
                        othersArr = $.grep(skuSelected.keys, function (v, i) {
                            return v != $sibSelected.data(&amp;#39;value&amp;#39;);
                        });
                    } else {
                        othersArr = skuSelected.keys.concat();
                    }
                    othersArr = othersArr.concat($that.data(&amp;#39;value&amp;#39;)).sort(function (a, b) {
                        return parseInt(a) - parseInt(b);
                    });

                    //console.info(&amp;#39;othersArr==&amp;#39;, othersArr.join(sku.delimiter));

                    if (!skuMap[othersArr.join(sku.delimiter)]) {
                        $that.addClass(className.disabled);
                    } else {
                        $that.removeClass(className.disabled);
                    }

                });

            } else {
                //设置默认价格、描述
                showPrice = defaultPrice;
                showPic = defaultPic;
                skuDesc = defaultDesc;
                $.each($(&amp;#39;.&amp;#39; + className.sku), function () {
                    var $this = $(this);
                    if (!skuMap[$this.data(&amp;#39;value&amp;#39;)]) {
                        $this.addClass(className.disabled).removeClass(className.active);
                    } else {
                        $this.removeClass(className.disabled);
                    }
                })
            }

            //显示价格和图片等信息
            $(&amp;#39;.sku-price&amp;#39;).text(showPrice);
            $(&amp;#39;.sku-pic&amp;#39;).attr(&amp;#39;src&amp;#39;, showPic);
            $(&amp;#39;.sku-desc&amp;#39;).html(skuDesc);

        });

        //只有一组sku的话，直接选中
        if ($.map(data, function (v, k) {
                return k;
            }).length === 1) {
            sku.container.find(&amp;#39;.&amp;#39; + className.sku).trigger(&amp;#39;click&amp;#39;);
        }

    };

    //数组排列组合算法
    sku.combineArr = function (arr) {
        //console.log(&amp;#39;arr&amp;#39;, arr)
        var len = arr.length, result = [];
        combine();
        function combine(item, index) {
            item = item || &amp;#39;&amp;#39;;
            index = index || 0;
            if (index == len)return;
            for (var i = index; i &amp;lt; len; i++) {
                var newItem = (item ? [item, sku.delimiter, arr[i]] : [item, arr[i]]).join(&amp;#39;&amp;#39;);
                result.push(newItem);
                combine(newItem, ++index);
            }
        }

        return result;
    };


    //获取已选中的sku信息
    sku.selected = function () {
        var skuMap = sku.skuMap;
        var $skuSelected = $(&amp;#39;.&amp;#39; + className.sku + &amp;#39;.&amp;#39; + className.active);
        var result = {
            keys: []
        };
        if ($skuSelected[0]) {
            result.keys = $.map($skuSelected, function (v, i) {
                return $(v).data(&amp;#39;value&amp;#39;);
            }).sort(function (a, b) {
                return parseInt(a) - parseInt(b);
            });

            result.desc = $.map($skuSelected, function (v, i) {
                return $(v).text();
            });

            if (skuMap[result.keys.join(sku.delimiter)].itemId) {
                result.detail = skuMap[result.keys.join(sku.delimiter)];
                result.itemId = result.detail.itemId;
            }

        }

        return result;
    };


    module.exports = sku;


});
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;5-demo演示&quot;&gt;&lt;a href=&quot;#5-demo演示&quot; class=&quot;headerlink&quot; title=&quot;5. demo演示&quot;&gt;&lt;/a&gt;5. demo演示&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7xth8v.com2.z0.glb.qiniucdn.com/image/sku_02.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-SKU简介&quot;&gt;&lt;a href=&quot;#1-SKU简介&quot; class=&quot;headerlink&quot; title=&quot;1. SKU简介&quot;&gt;&lt;/a&gt;1. SKU简介&lt;/h4&gt;&lt;p&gt;下面是SKU来自维基百科的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;最小存
    
    </summary>
    
    
      <category term="sku" scheme="http://mmrxia.github.io/tags/sku/"/>
    
      <category term="算法" scheme="http://mmrxia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="随笔" scheme="http://mmrxia.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
