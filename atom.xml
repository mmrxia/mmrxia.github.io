<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>芥子园 | xiaqingsong&#39;s blog</title>
  <subtitle>须弥藏芥子，芥子纳须弥</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mmrxia.github.io/"/>
  <updated>2018-04-20T03:21:27.003Z</updated>
  <id>http://mmrxia.github.io/</id>
  
  <author>
    <name>芥子园</name>
    <email>this.xqs@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git工作流</title>
    <link href="http://mmrxia.github.io/2018/04/20/git%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <id>http://mmrxia.github.io/2018/04/20/git工作流/</id>
    <published>2018-04-20T03:20:06.000Z</published>
    <updated>2018-04-20T03:21:27.003Z</updated>
    
    <content type="html">&lt;h1 id=&quot;说明：&quot;&gt;&lt;a href=&quot;#说明：&quot; class=&quot;headerlink&quot; title=&quot;说明：&quot;&gt;&lt;/a&gt;说明：&lt;/h1&gt;&lt;p&gt;个人在学习&lt;code&gt;Git&lt;/code&gt;工作流的过程中，从原有的 SVN 模式很难完全理解&lt;code&gt;Git&lt;/code&gt;的协作模式，直到有一天我看到了下面的文章，好多遗留在心中的困惑迎刃而解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们以使用SVN的工作流来使用&lt;code&gt;Git&lt;/code&gt;有什么不妥？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Git&lt;/code&gt;方便的branch在哪里，团队多人如何协作？冲突了怎么办？如何进行发布控制？&lt;/li&gt;
&lt;li&gt;经典的master-发布、develop-主开发、hotfix-bug修复如何避免代码不经过验证上线？&lt;/li&gt;
&lt;li&gt;如何在&lt;code&gt;GitHub&lt;/code&gt;上面与他人一起协作，star-fork-pull request是怎样的流程？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我个人很感激这篇文章，所以进行了整理，希望能帮到更多的人。整篇文章由 &lt;a href=&quot;https://github.com/xirong&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;xirong&lt;/a&gt; 整理自 &lt;a href=&quot;https://github.com/oldratlee&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;oldratlee&lt;/a&gt; 的&lt;code&gt;GitHub&lt;/code&gt;，方便统一的学习回顾，在此感谢下面两位的贡献。&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.atlassian.com/git/workflows&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Git Workflows and Tutorials&lt;/a&gt;&lt;br&gt;简体中文：由 &lt;a href=&quot;https://github.com/oldratlee&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;oldratlee&lt;/a&gt; 翻译在 &lt;code&gt;GitHub&lt;/code&gt; 上 &lt;a href=&quot;https://github.com/oldratlee/translations/blob/master/git-workflows-and-tutorials/README.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;Git&lt;/code&gt;工作流指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在第三部分 &lt;a href=&quot;#三企业日常开发模式探索&quot;&gt;企业日常开发模式探索&lt;/a&gt;，xirong 结合自己所在公司使用git的版本分支开发过程，进行了总结，欢迎大家提出更好的建议。&lt;/p&gt;
&lt;p&gt;在第四部分 &lt;a href=&quot;#开发工作流的讨论&quot;&gt;开发工作流的讨论&lt;/a&gt; 中，引用了几篇文章，包括 Github 的开发流程以及 Thoughtworkers 工程师发表的「Gitflow 有害论」，旨在表名流程并不是唯一的，适合自己当前团队的才是最好的。&lt;/p&gt;
&lt;hr&gt;
&lt;p data-anchor-id=&quot;bd8d&quot;&gt;&lt;div class=&quot;toc&quot;&gt;&lt;br&gt;&lt;ul&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#一译序&quot;&gt;一、译序&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#二git工作流指南&quot;&gt;二、Git工作流指南&lt;/a&gt;&lt;ul&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#21-集中式工作流&quot;&gt;2.1 集中式工作流&lt;/a&gt;&lt;ul&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#211-工作方式&quot;&gt;2.1.1 工作方式&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#212-冲突解决&quot;&gt;2.1.2 冲突解决&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#213-示例&quot;&gt;2.1.3 示例&lt;/a&gt;&lt;ul&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#有人先初始化好中央仓库&quot;&gt;有人先初始化好中央仓库&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#所有人克隆中央仓库&quot;&gt;所有人克隆中央仓库&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#小明开发功能&quot;&gt;小明开发功能&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#小红开发功能&quot;&gt;小红开发功能&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#小明发布功能&quot;&gt;小明发布功能&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#小红试着发布功能&quot;&gt;小红试着发布功能&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#小红在小明的提交之上rebase&quot;&gt;小红在小明的提交之上rebase&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#小红解决合并冲突&quot;&gt;小红解决合并冲突&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#小红成功发布功能&quot;&gt;小红成功发布功能&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;&lt;br&gt;&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;&lt;br&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#22-功能分支工作流&quot;&gt;2.2 功能分支工作流&lt;/a&gt;&lt;ul&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#221-工作方式&quot;&gt;2.2.1 工作方式&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#222-pull-requests&quot;&gt;2.2.2 Pull Requests&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#223-示例&quot;&gt;2.2.3 示例&lt;/a&gt;&lt;ul&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#小红开始开发一个新功能&quot;&gt;小红开始开发一个新功能&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#小红要去吃个午饭&quot;&gt;小红要去吃个午饭&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#小红完成功能开发&quot;&gt;小红完成功能开发&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#小黑收到pull-request&quot;&gt;小黑收到Pull Request&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#小红再做修改&quot;&gt;小红再做修改&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#小红发布她的功能&quot;&gt;小红发布她的功能&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#与此同时小明在做和小红一样的事&quot;&gt;与此同时，小明在做和小红一样的事&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;&lt;br&gt;&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;&lt;br&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#23-gitflow工作流&quot;&gt;2.3 Gitflow工作流&lt;/a&gt;&lt;ul&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#231-工作方式&quot;&gt;2.3.1 工作方式&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#232-历史分支&quot;&gt;2.3.2 历史分支&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#233-功能分支&quot;&gt;2.3.3 功能分支&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#234-发布分支&quot;&gt;2.3.4 发布分支&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#235-维护分支&quot;&gt;2.3.5 维护分支&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#236-示例&quot;&gt;2.3.6 示例&lt;/a&gt;&lt;ul&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#创建开发分支&quot;&gt;创建开发分支&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#小红和小明开始开发新功能&quot;&gt;小红和小明开始开发新功能&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#小红完成功能开发-1&quot;&gt;小红完成功能开发&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#小红开始准备发布&quot;&gt;小红开始准备发布&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#小红完成发布&quot;&gt;小红完成发布&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#最终用户发现bug&quot;&gt;最终用户发现Bug&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;&lt;br&gt;&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;&lt;br&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#24-forking工作流&quot;&gt;2.4 Forking工作流&lt;/a&gt;&lt;ul&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#241-工作方式&quot;&gt;2.4.1 工作方式&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#242-正式仓库&quot;&gt;2.4.2 正式仓库&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#243-forking工作流的分支使用方式&quot;&gt;2.4.3 Forking工作流的分支使用方式&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#244-示例&quot;&gt;2.4.4 示例&lt;/a&gt;&lt;ul&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#项目维护者初始化正式仓库&quot;&gt;项目维护者初始化正式仓库&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#开发者fork正式仓库&quot;&gt;开发者fork正式仓库&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#开发者克隆自己fork出来的仓库&quot;&gt;开发者克隆自己fork出来的仓库&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#开发者开发自己的功能&quot;&gt;开发者开发自己的功能&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#开发者发布自己的功能&quot;&gt;开发者发布自己的功能&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#项目维护者集成开发者的功能&quot;&gt;项目维护者集成开发者的功能&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#开发者和正式仓库做同步&quot;&gt;开发者和正式仓库做同步&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;&lt;br&gt;&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;&lt;br&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#25-pull-requests&quot;&gt;2.5 Pull Requests&lt;/a&gt;&lt;ul&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#251-解析pull-request&quot;&gt;2.5.1 解析Pull Request&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#252-工作方式&quot;&gt;2.5.2 工作方式&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#253-在功能分支工作流中使用pull-request&quot;&gt;2.5.3 在功能分支工作流中使用Pull Request&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#254-在gitflow工作流中使用pull-request&quot;&gt;2.5.4 在Gitflow工作流中使用Pull Request&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#255-在forking工作流中使用pull-request&quot;&gt;2.5.5 在Forking工作流中使用Pull Request&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#256-示例&quot;&gt;2.5.6 示例&lt;/a&gt;&lt;ul&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#小红fork正式项目&quot;&gt;小红fork正式项目&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#小红克隆她的bitbucket仓库&quot;&gt;小红克隆她的Bitbucket仓库&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#小红开发新功能&quot;&gt;小红开发新功能&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#小红push功能到她的bitbucket仓库中&quot;&gt;小红push功能到她的Bitbucket仓库中&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#小红发起pull-request&quot;&gt;小红发起Pull Request&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#小明review-pull-request&quot;&gt;小明review Pull Request&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#小红补加提交&quot;&gt;小红补加提交&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#小明接受pull-request&quot;&gt;小明接受Pull Request&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;&lt;br&gt;&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;&lt;br&gt;&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;&lt;br&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;&lt;a href=&quot;#三企业日常开发模式探索&quot;&gt;三、企业日常开发模式探索&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;&lt;br&gt;&lt;/div&gt;&lt;br&gt;&lt;/p&gt;


&lt;h1 id=&quot;一、译序&quot;&gt;&lt;a href=&quot;#一、译序&quot; class=&quot;headerlink&quot; title=&quot;一、译序&quot;&gt;&lt;/a&gt;一、译序&lt;/h1&gt;&lt;p&gt;这篇指南以大家在&lt;code&gt;SVN&lt;/code&gt;中已经广为熟悉使用的集中式工作流作为起点，循序渐进地演进到其它高效的分布式工作流，还介绍了如何配合使用便利的&lt;code&gt;Pull Request&lt;/code&gt;功能，系统地讲解了各种工作流的应用。&lt;br&gt;如果你&lt;code&gt;Git&lt;/code&gt;用的还不多，可以从前面的讲的工作流开始操练。在操作过程中去感受指南的讲解：解决什么问题、如何解决问题，这样理解就深了，也方便活用。&lt;/p&gt;
&lt;p&gt;行文中实践原则和操作示例并重，对于&lt;code&gt;Git&lt;/code&gt;的资深玩家可以梳理思考提升，而新接触的同学，也可以跟着step-by-step操练学习并在实际工作中上手使用。&lt;/p&gt;
&lt;p&gt;工作流其实不是一个初级主题，背后的本质问题是 有效的项目流程管理 和 高效的开发协同约定，而不仅仅是&lt;code&gt;Git&lt;/code&gt;或&lt;code&gt;SVN&lt;/code&gt;等&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;VCS&lt;/code&gt;&lt;/a&gt;或&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;SCM&lt;/code&gt;&lt;/a&gt;工具的使用。&lt;/p&gt;
&lt;p&gt;关于&lt;code&gt;Git&lt;/code&gt;工作流主题，网上体系的中文资料不多，主要是零散的操作说明，希望这篇文章能让你更深入理解并在工作中灵活有效地使用起来。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Gitflow&lt;/code&gt;工作流是经典模型，处于核心位置，体现了工作流的经验和精髓。随着项目过程复杂化，你会感受到这个工作流中的深思熟虑和威力！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Forking&lt;/code&gt;工作流是分布式协作的（&lt;code&gt;GitHub&lt;/code&gt;风格）可以先看看&lt;code&gt;GitHub&lt;/code&gt;的Help：&lt;a href=&quot;https://help.github.com/articles/fork-a-repo/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Fork A Repo&lt;/a&gt;和&lt;a href=&quot;https://help.github.com/articles/using-pull-requests/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Using pull requests&lt;/a&gt; 。照着操作，给一个&lt;code&gt;GitHub&lt;/code&gt;项目贡献你的提交，有操作经验再看指南容易意会。指南中给了&lt;a href=&quot;https://github.com/oldratlee/translations/blob/master/git-workflows-and-tutorials/workflow-forking.md#%E5%BC%80%E5%8F%91%E8%80%85fork%E6%AD%A3%E5%BC%8F%E4%BB%93%E5%BA%93&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;自己实现&lt;code&gt;Fork&lt;/code&gt;的方法&lt;/a&gt;：&lt;code&gt;Fork&lt;/code&gt;就是服务端的克隆。在指南的操练中使用代码托管服务（如&lt;code&gt;GitHub&lt;/code&gt;、&lt;code&gt;Bitbucket&lt;/code&gt;），可以点一下按钮就让开发者完成仓库的&lt;code&gt;fork&lt;/code&gt;操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;PS&lt;/em&gt;&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;文中&lt;code&gt;Pull Request&lt;/code&gt;的介绍用的是&lt;code&gt;Bitbucket&lt;/code&gt;代码托管服务，由于和&lt;code&gt;GitHub&lt;/code&gt;基本一样，如果你用的是&lt;code&gt;GitHub&lt;/code&gt;（我自己也主要使用&lt;code&gt;GitHub&lt;/code&gt;托管代码），不影响理解和操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;PPS&lt;/em&gt;&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;更多&lt;code&gt;Git&lt;/code&gt;学习资料参见&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/xirong/my-git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;Git&lt;/code&gt;的资料整理&lt;/a&gt; by &lt;a href=&quot;https://github.com/xirong&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@xirong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;自己整理的分享PPT &lt;a href=&quot;https://github.com/oldratlee/software-practice-miscellany/blob/master/git/git-gitlab-usage.pptx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;Git&lt;/code&gt;使用与实践&lt;/a&gt; @ &lt;a href=&quot;https://github.com/oldratlee/software-practice-miscellany/tree/master/git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;个人整理一些&lt;code&gt;Git&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;:see_no_evil: &lt;a href=&quot;http://weibo.com/oldratlee&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;自己&lt;/a&gt;理解粗浅，翻译中不足和不对之处，欢迎 :clap:&lt;ul&gt;
&lt;li&gt;建议，&lt;a href=&quot;https://github.com/oldratlee/translations/issues/new&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;提交&lt;code&gt;Issue&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;指正，&lt;a href=&quot;https://github.com/oldratlee/translations/fork&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;Fork&lt;/code&gt;后提通过&lt;code&gt;Pull Requst&lt;/code&gt;贡献修改&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如有文章理解上有疑问 或是 使用过程中碰到些疑惑，请随时:raised_hands:&lt;a href=&quot;https://github.com/oldratlee/translations/issues/new&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;提交&lt;code&gt;Issue&lt;/code&gt;&lt;/a&gt; ，一起交流学习讨论！&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&quot;二、Git工作流指南&quot;&gt;&lt;a href=&quot;#二、Git工作流指南&quot; class=&quot;headerlink&quot; title=&quot;二、Git工作流指南&quot;&gt;&lt;/a&gt;二、&lt;code&gt;Git&lt;/code&gt;工作流指南&lt;/h1&gt;&lt;p&gt;:point_right: 工作流有各式各样的用法，但也正因此使得在实际工作中如何上手使用变得很头大。这篇指南通过总览公司团队中最常用的几种&lt;code&gt;Git&lt;/code&gt;工作流让大家可以上手使用。&lt;/p&gt;
&lt;p&gt;在阅读的过程中请记住，本文中的几种工作流是作为方案指导而不是条例规定。在展示了各种工作流可能的用法后，你可以从不同的工作流中挑选或揉合出一个满足你自己需求的工作流。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/git_workflow.png&quot; alt=&quot;Git Workflows&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-1-集中式工作流&quot;&gt;&lt;a href=&quot;#2-1-集中式工作流&quot; class=&quot;headerlink&quot; title=&quot;2.1 集中式工作流&quot;&gt;&lt;/a&gt;2.1 集中式工作流&lt;/h2&gt;&lt;p&gt;如果你的开发团队成员已经很熟悉&lt;code&gt;Subversion&lt;/code&gt;，集中式工作流让你无需去适应一个全新流程就可以体验&lt;code&gt;Git&lt;/code&gt;带来的收益。这个工作流也可以作为向更&lt;code&gt;Git&lt;/code&gt;风格工作流迁移的友好过渡。&lt;br&gt;&lt;img src=&quot;images/git-workflow-svn.png&quot; alt=&quot;Git Workflows: SVN-style&quot;&gt;&lt;/p&gt;
&lt;p&gt;转到分布式版本控制系统看起来像个令人生畏的任务，但不改变已用的工作流，你也可以用上&lt;code&gt;Git&lt;/code&gt;带来的收益。团队可以用和&lt;code&gt;Subversion&lt;/code&gt;完全不变的方式来开发项目。&lt;/p&gt;
&lt;p&gt;但使用&lt;code&gt;Git&lt;/code&gt;加强开发的工作流，相比&lt;code&gt;SVN&lt;/code&gt;，&lt;code&gt;Git&lt;/code&gt;有以下两个优势:&lt;br&gt;首先，每个开发者可以有属于自己的整个工程的本地拷贝。隔离的环境让各个开发者的工作和项目的其他部分修改独立开来 ——&lt;br&gt;即自由地提交到自己的本地仓库，先完全忽略上游的开发，直到方便的时候再把修改反馈上去。&lt;/p&gt;
&lt;p&gt;其次，&lt;code&gt;Git&lt;/code&gt;提供了强壮的分支和合并模型。不像&lt;code&gt;SVN&lt;/code&gt;，&lt;code&gt;Git&lt;/code&gt;的分支设计成可以做为一种用来在仓库之间集成代码和分享修改的『失败安全』的机制。&lt;/p&gt;
&lt;h3 id=&quot;2-1-1-工作方式&quot;&gt;&lt;a href=&quot;#2-1-1-工作方式&quot; class=&quot;headerlink&quot; title=&quot;2.1.1 工作方式&quot;&gt;&lt;/a&gt;2.1.1 工作方式&lt;/h3&gt;&lt;p&gt;像&lt;code&gt;Subversion&lt;/code&gt;一样，集中式工作流以中央仓库作为项目所有修改的单点实体。相比&lt;code&gt;SVN&lt;/code&gt;缺省的开发分支&lt;code&gt;trunk&lt;/code&gt;，&lt;code&gt;Git&lt;/code&gt;叫做&lt;code&gt;master&lt;/code&gt;，所有修改提交到这个分支上。本工作流只用到&lt;code&gt;master&lt;/code&gt;这一个分支。&lt;/p&gt;
&lt;p&gt;首先，开发者克隆中央仓库。在自己的项目拷贝中，像&lt;code&gt;SVN&lt;/code&gt;一样的编辑文件和提交修改；但修改是存在本地的，和中央仓库是完全隔离的。开发者可以把和上游的同步延后到一个方便时间点。&lt;/p&gt;
&lt;p&gt;然后，开发者发布修改到正式项目中，开发者要把本地&lt;code&gt;master&lt;/code&gt;分支的修改『推』到中央仓库中。这相当于&lt;code&gt;svn commit&lt;/code&gt;操作，但&lt;code&gt;push&lt;/code&gt;操作会把所有还不在中央仓库的本地提交都推上去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/git-workflow-svn-push-local.png&quot; alt=&quot;git-workflow-svn-push-local&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-1-2-冲突解决&quot;&gt;&lt;a href=&quot;#2-1-2-冲突解决&quot; class=&quot;headerlink&quot; title=&quot;2.1.2 冲突解决&quot;&gt;&lt;/a&gt;2.1.2 冲突解决&lt;/h3&gt;&lt;p&gt;中央仓库代表了正式项目，所以提交历史应该被尊重且是稳定不变的。如果开发者本地的提交历史和中央仓库有分歧，&lt;code&gt;Git&lt;/code&gt;会拒绝&lt;code&gt;push&lt;/code&gt;提交否则会覆盖已经在中央库的正式提交。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/git-workflow-svn-managingconflicts.png&quot; alt=&quot;git-workflow-svn-managingconflicts&quot;&gt;&lt;/p&gt;
&lt;p&gt;在开发者提交自己功能修改到中央库前，需要先&lt;code&gt;fetch&lt;/code&gt;在中央库的新增提交，&lt;code&gt;rebase&lt;/code&gt;自己提交到中央库提交历史之上。&lt;br&gt;这样做的意思是在说，『我要把自己的修改加到别人已经完成的修改上。』最终的结果是一个完美的线性历史，就像以前的&lt;code&gt;SVN&lt;/code&gt;的工作流中一样。&lt;/p&gt;
&lt;p&gt;如果本地修改和上游提交有冲突，&lt;code&gt;Git&lt;/code&gt;会暂停&lt;code&gt;rebase&lt;/code&gt;过程，给你手动解决冲突的机会。&lt;code&gt;Git&lt;/code&gt;解决合并冲突，用和生成提交一样的&lt;a href=&quot;https://www.atlassian.com/git/tutorial/git-basics#!status&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;git status&lt;/code&gt;&lt;/a&gt;和&lt;a href=&quot;https://www.atlassian.com/git/tutorial/git-basics#!add&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;git add&lt;/code&gt;&lt;/a&gt;命令，很一致方便。还有一点，如果解决冲突时遇到麻烦，&lt;code&gt;Git&lt;/code&gt;可以很简单中止整个&lt;code&gt;rebase&lt;/code&gt;操作，重来一次（或者让别人来帮助解决）。&lt;/p&gt;
&lt;h3 id=&quot;2-1-3-示例&quot;&gt;&lt;a href=&quot;#2-1-3-示例&quot; class=&quot;headerlink&quot; title=&quot;2.1.3 示例&quot;&gt;&lt;/a&gt;2.1.3 示例&lt;/h3&gt;&lt;p&gt;让我们一起逐步分解来看看一个常见的小团队如何用这个工作流来协作的。有两个开发者小明和小红，看他们是如何开发自己的功能并提交到中央仓库上的。&lt;/p&gt;
&lt;h4 id=&quot;有人先初始化好中央仓库&quot;&gt;&lt;a href=&quot;#有人先初始化好中央仓库&quot; class=&quot;headerlink&quot; title=&quot;有人先初始化好中央仓库&quot;&gt;&lt;/a&gt;有人先初始化好中央仓库&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflow-svn-initialize.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;第一步，有人在服务器上创建好中央仓库。如果是新项目，你可以初始化一个空仓库；否则你要导入已有的&lt;code&gt;Git&lt;/code&gt;或&lt;code&gt;SVN&lt;/code&gt;仓库。&lt;/p&gt;
&lt;p&gt;中央仓库应该是个裸仓库（&lt;code&gt;bare repository&lt;/code&gt;），即没有工作目录（&lt;code&gt;working directory&lt;/code&gt;）的仓库。可以用下面的命令创建：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;ssh user@host
git init --bare /path/to/repo.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;确保写上有效的&lt;code&gt;user&lt;/code&gt;（&lt;code&gt;SSH&lt;/code&gt;的用户名），&lt;code&gt;host&lt;/code&gt;（服务器的域名或IP地址），&lt;code&gt;/path/to/repo.git&lt;/code&gt;（你想存放仓库的位置）。&lt;br&gt;注意，为了表示是一个裸仓库，按照约定加上&lt;code&gt;.git&lt;/code&gt;扩展名到仓库名上。&lt;/p&gt;
&lt;h4 id=&quot;所有人克隆中央仓库&quot;&gt;&lt;a href=&quot;#所有人克隆中央仓库&quot; class=&quot;headerlink&quot; title=&quot;所有人克隆中央仓库&quot;&gt;&lt;/a&gt;所有人克隆中央仓库&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflow-svn-clone.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;下一步，各个开发者创建整个项目的本地拷贝。通过&lt;a href=&quot;https://www.atlassian.com/git/tutorial/git-basics#!clone&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;git clone&lt;/code&gt;&lt;/a&gt;命令完成：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git clone ssh://user@host/path/to/repo.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;基于你后续会持续和克隆的仓库做交互的假设，克隆仓库时&lt;code&gt;Git&lt;/code&gt;会自动添加远程别名&lt;code&gt;origin&lt;/code&gt;指回『父』仓库。&lt;/p&gt;
&lt;h4 id=&quot;小明开发功能&quot;&gt;&lt;a href=&quot;#小明开发功能&quot; class=&quot;headerlink&quot; title=&quot;小明开发功能&quot;&gt;&lt;/a&gt;小明开发功能&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflow-svn-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在小明的本地仓库中，他使用标准的&lt;code&gt;Git&lt;/code&gt;过程开发功能：编辑、暂存（&lt;code&gt;Stage&lt;/code&gt;）和提交。&lt;br&gt;如果你不熟悉暂存区（&lt;code&gt;Staging Area&lt;/code&gt;），这里说明一下：&lt;strong&gt;暂存区&lt;/strong&gt;用来准备一个提交，但可以不用把工作目录中所有的修改内容都包含进来。&lt;br&gt;这样你可以创建一个高度聚焦的提交，尽管你本地修改很多内容。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git status # 查看本地仓库的修改状态
git add # 暂存文件
git commit # 提交文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请记住，因为这些命令生成的是本地提交，小明可以按自己需求反复操作多次，而不用担心中央仓库上有了什么操作。&lt;br&gt;对需要多个更简单更原子分块的大功能，这个做法是很有用的。&lt;/p&gt;
&lt;h4 id=&quot;小红开发功能&quot;&gt;&lt;a href=&quot;#小红开发功能&quot; class=&quot;headerlink&quot; title=&quot;小红开发功能&quot;&gt;&lt;/a&gt;小红开发功能&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflow-svn-2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;与此同时，小红在自己的本地仓库中用相同的编辑、暂存和提交过程开发功能。和小明一样，她也不关心中央仓库有没有新提交；&lt;br&gt;当然更不关心小明在他的本地仓库中的操作，因为所有本地仓库都是私有的。&lt;/p&gt;
&lt;h4 id=&quot;小明发布功能&quot;&gt;&lt;a href=&quot;#小明发布功能&quot; class=&quot;headerlink&quot; title=&quot;小明发布功能&quot;&gt;&lt;/a&gt;小明发布功能&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflow-svn-3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;一旦小明完成了他的功能开发，会发布他的本地提交到中央仓库中，这样其它团队成员可以看到他的修改。他可以用下面的&lt;a href=&quot;https://www.atlassian.com/git/tutorial/remote-repositories#!push&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;git push&lt;/code&gt;命令&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git push origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，&lt;code&gt;origin&lt;/code&gt;是在小明克隆仓库时&lt;code&gt;Git&lt;/code&gt;创建的远程中央仓库别名。&lt;code&gt;master&lt;/code&gt;参数告诉&lt;code&gt;Git&lt;/code&gt;推送的分支。&lt;br&gt;由于中央仓库自从小明克隆以来还没有被更新过，所以&lt;code&gt;push&lt;/code&gt;操作不会有冲突，成功完成。&lt;/p&gt;
&lt;h4 id=&quot;小红试着发布功能&quot;&gt;&lt;a href=&quot;#小红试着发布功能&quot; class=&quot;headerlink&quot; title=&quot;小红试着发布功能&quot;&gt;&lt;/a&gt;小红试着发布功能&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflow-svn-4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;一起来看看在小明发布修改后，小红&lt;code&gt;push&lt;/code&gt;修改会怎么样？她使用完全一样的&lt;code&gt;push&lt;/code&gt;命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git push origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但她的本地历史已经和中央仓库有分岐了，&lt;code&gt;Git&lt;/code&gt;拒绝操作并给出下面很长的出错消息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error: failed to push some refs to &amp;#39;/path/to/repo.git&amp;#39;
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Merge the remote changes (e.g. &amp;#39;git pull&amp;#39;)
hint: before pushing again.
hint: See the &amp;#39;Note about fast-forwards&amp;#39; in &amp;#39;git push --help&amp;#39; for details.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这避免了小红覆写正式的提交。她要先&lt;code&gt;pull&lt;/code&gt;小明的更新到她的本地仓库合并上她的本地修改后，再重试。&lt;/p&gt;
&lt;h4 id=&quot;小红在小明的提交之上rebase&quot;&gt;&lt;a href=&quot;#小红在小明的提交之上rebase&quot; class=&quot;headerlink&quot; title=&quot;小红在小明的提交之上rebase&quot;&gt;&lt;/a&gt;小红在小明的提交之上&lt;code&gt;rebase&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflow-svn-5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;小红用&lt;a href=&quot;https://www.atlassian.com/git/tutorial/remote-repositories#!pull&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;git pull&lt;/code&gt;&lt;/a&gt;合并上游的修改到自己的仓库中。&lt;br&gt;这条命令类似&lt;code&gt;svn update&lt;/code&gt;——拉取所有上游提交命令到小红的本地仓库，并尝试和她的本地修改合并：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git pull --rebase origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;--rebase&lt;/code&gt;选项告诉&lt;code&gt;Git&lt;/code&gt;把小红的提交移到同步了中央仓库修改后的&lt;code&gt;master&lt;/code&gt;分支的顶部，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/git-workflow-svn-6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你忘加了这个选项，&lt;code&gt;pull&lt;/code&gt;操作仍然可以完成，但每次&lt;code&gt;pull&lt;/code&gt;操作要同步中央仓库中别人修改时，提交历史会以一个多余的『合并提交』结尾。&lt;br&gt;对于集中式工作流，最好是使用&lt;code&gt;rebase&lt;/code&gt;而不是生成一个合并提交。&lt;/p&gt;
&lt;h4 id=&quot;小红解决合并冲突&quot;&gt;&lt;a href=&quot;#小红解决合并冲突&quot; class=&quot;headerlink&quot; title=&quot;小红解决合并冲突&quot;&gt;&lt;/a&gt;小红解决合并冲突&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflow-svn-7.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rebase&lt;/code&gt;操作过程是把本地提交一次一个地迁移到更新了的中央仓库&lt;code&gt;master&lt;/code&gt;分支之上。&lt;br&gt;这意味着可能要解决在迁移某个提交时出现的合并冲突，而不是解决包含了所有提交的大型合并时所出现的冲突。&lt;br&gt;这样的方式让你尽可能保持每个提交的聚焦和项目历史的整洁。反过来，简化了哪里引入&lt;code&gt;Bug&lt;/code&gt;的分析，如果有必要，回滚修改也可以做到对项目影响最小。&lt;/p&gt;
&lt;p&gt;如果小红和小明的功能是不相关的，不大可能在&lt;code&gt;rebase&lt;/code&gt;过程中有冲突。如果有，&lt;code&gt;Git&lt;/code&gt;在合并有冲突的提交处暂停&lt;code&gt;rebase&lt;/code&gt;过程，输出下面的信息并带上相关的指令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CONFLICT (content): Merge conflict in &amp;lt;some-file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflow-svn-8.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Git&lt;/code&gt;很赞的一点是，任何人可以解决他自己的冲突。在这个例子中，小红可以简单的运行&lt;a href=&quot;https://www.atlassian.com/git/tutorial/git-basics#!status&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;git status&lt;/code&gt;&lt;/a&gt;命令来查看哪里有问题。&lt;br&gt;冲突文件列在&lt;code&gt;Unmerged paths&lt;/code&gt;（未合并路径）一节中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Unmerged paths:
# (use &amp;quot;git reset HEAD &amp;lt;some-file&amp;gt;...&amp;quot; to unstage)
# (use &amp;quot;git add/rm &amp;lt;some-file&amp;gt;...&amp;quot; as appropriate to mark resolution)
#
# both modified: &amp;lt;some-file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接着小红编辑这些文件。修改完成后，用老套路暂存这些文件，并让&lt;a href=&quot;https://www.atlassian.com/git/tutorial/rewriting-git-history#!rebase&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;git rebase&lt;/code&gt;&lt;/a&gt;完成剩下的事：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git add &amp;lt;some-file&amp;gt; 
git rebase --continue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要做的就这些了。&lt;code&gt;Git&lt;/code&gt;会继续一个一个地合并后面的提交，如其它的提交有冲突就重复这个过程。&lt;/p&gt;
&lt;p&gt;如果你碰到了冲突，但发现搞不定，不要惊慌。只要执行下面这条命令，就可以回到你执行&lt;a href=&quot;https://www.atlassian.com/git/tutorial/remote-repositories#!pull&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;git pull --rebase&lt;/code&gt;&lt;/a&gt;命令前的样子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git rebase --abort
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;小红成功发布功能&quot;&gt;&lt;a href=&quot;#小红成功发布功能&quot; class=&quot;headerlink&quot; title=&quot;小红成功发布功能&quot;&gt;&lt;/a&gt;小红成功发布功能&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflow-svn-9.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;小红完成和中央仓库的同步后，就能成功发布她的修改了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git push origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如你所见，仅使用几个&lt;code&gt;Git&lt;/code&gt;命令我们就可以模拟出传统&lt;code&gt;Subversion&lt;/code&gt;开发环境。对于要从&lt;code&gt;SVN&lt;/code&gt;迁移过来的团队来说这太好了，但没有发挥出&lt;code&gt;Git&lt;/code&gt;分布式本质的优势。&lt;/p&gt;
&lt;p&gt;如果你的团队适应了集中式工作流，但想要更流畅的协作效果，绝对值得探索一下 &lt;code&gt;功能分支工作流&lt;/code&gt; 的收益。&lt;br&gt;通过为一个功能分配一个专门的分支，能够做到一个新增功能集成到正式项目之前对新功能进行深入讨论。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;2-2-功能分支工作流&quot;&gt;&lt;a href=&quot;#2-2-功能分支工作流&quot; class=&quot;headerlink&quot; title=&quot;2.2 功能分支工作流&quot;&gt;&lt;/a&gt;2.2 功能分支工作流&lt;/h2&gt;&lt;p&gt;功能分支工作流以集中式工作流为基础，不同的是为各个新功能分配一个专门的分支来开发。这样可以在把新功能集成到正式项目前，用&lt;code&gt;Pull Requests&lt;/code&gt;的方式讨论变更。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/git-workflow-feature_branch.png&quot; alt=&quot;Git Workflows: Feature Branch&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/git-workflow-feature-branch-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;一旦你玩转了&lt;a href=&quot;workflow-centralized.md&quot;&gt;集中式工作流&lt;/a&gt;，在开发过程中可以很简单地加上功能分支，用来鼓励开发者之间协作和简化交流。&lt;/p&gt;
&lt;p&gt;功能分支工作流背后的核心思路是所有的功能开发应该在一个专门的分支，而不是在&lt;code&gt;master&lt;/code&gt;分支上。&lt;br&gt;这个隔离可以方便多个开发者在各自的功能上开发而不会弄乱主干代码。&lt;br&gt;另外，也保证了&lt;code&gt;master&lt;/code&gt;分支的代码一定不会是有问题的，极大有利于集成环境。&lt;/p&gt;
&lt;p&gt;功能开发隔离也让&lt;a href=&quot;pull-request.md&quot;&gt;&lt;code&gt;pull requests&lt;/code&gt;工作流&lt;/a&gt;成功可能，&lt;br&gt;&lt;code&gt;pull requests&lt;/code&gt;工作流能为每个分支发起一个讨论，在分支合入正式项目之前，给其它开发者有表示赞同的机会。&lt;br&gt;另外，如果你在功能开发中有问题卡住了，可以开一个&lt;code&gt;pull requests&lt;/code&gt;来向同学们征求建议。&lt;br&gt;这些做法的重点就是，&lt;code&gt;pull requests&lt;/code&gt;让团队成员之间互相评论工作变成非常方便！&lt;/p&gt;
&lt;h3 id=&quot;2-2-1-工作方式&quot;&gt;&lt;a href=&quot;#2-2-1-工作方式&quot; class=&quot;headerlink&quot; title=&quot;2.2.1 工作方式&quot;&gt;&lt;/a&gt;2.2.1 工作方式&lt;/h3&gt;&lt;p&gt;功能分支工作流仍然用中央仓库，并且&lt;code&gt;master&lt;/code&gt;分支还是代表了正式项目的历史。&lt;br&gt;但不是直接提交本地历史到各自的本地&lt;code&gt;master&lt;/code&gt;分支，开发者每次在开始新功能前先创建一个新分支。&lt;br&gt;功能分支应该有个有描述性的名字，比如&lt;code&gt;animated-menu-items&lt;/code&gt;或&lt;code&gt;issue-#1061&lt;/code&gt;，这样可以让分支有个清楚且高聚焦的用途。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;master&lt;/code&gt;分支和功能分支，&lt;code&gt;Git&lt;/code&gt;是没有技术上的区别，所以开发者可以用和集中式工作流中完全一样的方式编辑、暂存和提交修改到功能分支上。&lt;/p&gt;
&lt;p&gt;另外，功能分支也可以（且应该）&lt;code&gt;push&lt;/code&gt;到中央仓库中。这样不修改正式代码就可以和其它开发者分享提交的功能。&lt;br&gt;由于&lt;code&gt;master&lt;/code&gt;是仅有的一个『特殊』分支，在中央仓库上存多个功能分支不会有任何问题。当然，这样做也可以很方便地备份各自的本地提交。&lt;/p&gt;
&lt;h3 id=&quot;2-2-2-Pull-Requests&quot;&gt;&lt;a href=&quot;#2-2-2-Pull-Requests&quot; class=&quot;headerlink&quot; title=&quot;2.2.2 Pull Requests&quot;&gt;&lt;/a&gt;2.2.2 &lt;code&gt;Pull Requests&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;功能分支除了可以隔离功能的开发，也使得通过&lt;a href=&quot;pull-request.md&quot;&gt;&lt;code&gt;Pull Requests&lt;/code&gt;&lt;/a&gt;讨论变更成为可能。&lt;br&gt;一旦某个开发者完成一个功能，不是立即合并到&lt;code&gt;master&lt;/code&gt;，而是&lt;code&gt;push&lt;/code&gt;到中央仓库的功能分支上并发起一个&lt;code&gt;Pull Request&lt;/code&gt;请求，将修改合并到&lt;code&gt;master&lt;/code&gt;。&lt;br&gt;在修改成为主干代码前，这让其它的开发者有机会先去&lt;code&gt;Review&lt;/code&gt;变更。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Code Review&lt;/code&gt;是&lt;code&gt;Pull Requests&lt;/code&gt;的一个重要的收益，而&lt;code&gt;Pull Requests&lt;/code&gt;则是讨论代码的一个通用方式。&lt;br&gt;你可以把&lt;code&gt;Pull Requests&lt;/code&gt;作为专门给某个分支的讨论。这意味着可以在更早的开发过程中就可以进行&lt;code&gt;Code Review&lt;/code&gt;。&lt;br&gt;比如，一个开发者开发功能需要帮助时，要做的就是发起一个&lt;code&gt;Pull Request&lt;/code&gt;，相关的人就会自动收到通知，在相关的提交旁边能看到需要帮助解决的问题。&lt;/p&gt;
&lt;p&gt;一旦&lt;code&gt;Pull Request&lt;/code&gt;被接受了，发布功能要做的就和集中式工作流就很像了。&lt;br&gt;首先，确定本地的&lt;code&gt;master&lt;/code&gt;分支和上游的&lt;code&gt;master&lt;/code&gt;分支是同步的。然后合并功能分支到本地&lt;code&gt;master&lt;/code&gt;分支并&lt;code&gt;push&lt;/code&gt;已经更新的本地&lt;code&gt;master&lt;/code&gt;分支到中央仓库。&lt;/p&gt;
&lt;p&gt;仓库管理的产品解决方案像&lt;a href=&quot;http://bitbucket.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;Bitbucket&lt;/code&gt;&lt;/a&gt;或&lt;a href=&quot;http://www.atlassian.com/stash&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;Stash&lt;/code&gt;&lt;/a&gt;，可以良好地支持&lt;code&gt;Pull Requests&lt;/code&gt;。可以看看&lt;code&gt;Stash&lt;/code&gt;的&lt;a href=&quot;https://confluence.atlassian.com/display/STASH/Using+pull+requests+in+Stash&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;Pull Requests&lt;/code&gt;文档&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;2-2-3-示例&quot;&gt;&lt;a href=&quot;#2-2-3-示例&quot; class=&quot;headerlink&quot; title=&quot;2.2.3 示例&quot;&gt;&lt;/a&gt;2.2.3 示例&lt;/h3&gt;&lt;p&gt;下面的示例演示了如何把&lt;code&gt;Pull Requests&lt;/code&gt;作为&lt;code&gt;Code Review&lt;/code&gt;的方式，但注意&lt;code&gt;Pull Requests&lt;/code&gt;可以用于很多其它的目的。&lt;/p&gt;
&lt;h4 id=&quot;小红开始开发一个新功能&quot;&gt;&lt;a href=&quot;#小红开始开发一个新功能&quot; class=&quot;headerlink&quot; title=&quot;小红开始开发一个新功能&quot;&gt;&lt;/a&gt;小红开始开发一个新功能&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflow-feature-branch-2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在开始开发功能前，小红需要一个独立的分支。使用下面的命令&lt;a href=&quot;https://www.atlassian.com/git/tutorial/git-branches#!checkout&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;新建一个分支&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git checkout -b marys-feature master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令检出一个基于&lt;code&gt;master&lt;/code&gt;名为&lt;code&gt;marys-feature&lt;/code&gt;的分支，&lt;code&gt;Git&lt;/code&gt;的&lt;code&gt;-b&lt;/code&gt;选项表示如果分支还不存在则新建分支。&lt;br&gt;这个新分支上，小红按老套路编辑、暂存和提交修改，按需要提交以实现功能：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git status
git add &amp;lt;some-file&amp;gt;
git commit
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;小红要去吃个午饭&quot;&gt;&lt;a href=&quot;#小红要去吃个午饭&quot; class=&quot;headerlink&quot; title=&quot;小红要去吃个午饭&quot;&gt;&lt;/a&gt;小红要去吃个午饭&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflow-feature-branch-3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;早上小红为新功能添加一些提交。&lt;br&gt;去吃午饭前，&lt;code&gt;push&lt;/code&gt;功能分支到中央仓库是很好的做法，这样可以方便地备份，如果和其它开发协作，也让他们可以看到小红的提交。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git push -u origin marys-feature
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这条命令&lt;code&gt;push&lt;/code&gt; &lt;code&gt;marys-feature&lt;/code&gt;分支到中央仓库（&lt;code&gt;origin&lt;/code&gt;），&lt;code&gt;-u&lt;/code&gt;选项设置本地分支去跟踪远程对应的分支。&lt;br&gt;设置好跟踪的分支后，小红就可以使用&lt;code&gt;git push&lt;/code&gt;命令省去指定推送分支的参数。&lt;/p&gt;
&lt;h4 id=&quot;小红完成功能开发&quot;&gt;&lt;a href=&quot;#小红完成功能开发&quot; class=&quot;headerlink&quot; title=&quot;小红完成功能开发&quot;&gt;&lt;/a&gt;小红完成功能开发&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflow-feature-branch-4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;小红吃完午饭回来，完成整个功能的开发。&lt;a href=&quot;https://www.atlassian.com/git/tutorial/git-branches#!merge&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在合并到&lt;code&gt;master&lt;/code&gt;之前&lt;/a&gt;，&lt;br&gt;她发起一个&lt;code&gt;Pull Request&lt;/code&gt;让团队的其它人知道功能已经完成。但首先，她要确认中央仓库中已经有她最近的提交：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git push
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，在她的&lt;code&gt;Git&lt;/code&gt; &lt;code&gt;GUI&lt;/code&gt;客户端中发起&lt;code&gt;Pull Request&lt;/code&gt;，请求合并&lt;code&gt;marys-feature&lt;/code&gt;到&lt;code&gt;master&lt;/code&gt;，团队成员会自动收到通知。&lt;br&gt;&lt;code&gt;Pull Request&lt;/code&gt;很酷的是可以在相关的提交旁边显示评注，所以你可以对某个变更集提问。&lt;/p&gt;
&lt;h4 id=&quot;小黑收到Pull-Request&quot;&gt;&lt;a href=&quot;#小黑收到Pull-Request&quot; class=&quot;headerlink&quot; title=&quot;小黑收到Pull Request&quot;&gt;&lt;/a&gt;小黑收到&lt;code&gt;Pull Request&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflow-feature-branch-5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;小黑收到了&lt;code&gt;Pull Request&lt;/code&gt;后会查看&lt;code&gt;marys-feature&lt;/code&gt;的修改。决定在合并到正式项目前是否要做些修改，且通过&lt;code&gt;Pull Request&lt;/code&gt;和小红来回地讨论。&lt;/p&gt;
&lt;h4 id=&quot;小红再做修改&quot;&gt;&lt;a href=&quot;#小红再做修改&quot; class=&quot;headerlink&quot; title=&quot;小红再做修改&quot;&gt;&lt;/a&gt;小红再做修改&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflow-feature-branch-6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;要再做修改，小红用和功能第一个迭代完全一样的过程。编辑、暂存、提交并&lt;code&gt;push&lt;/code&gt;更新到中央仓库。小红这些活动都会显示在&lt;code&gt;Pull Request&lt;/code&gt;上，小黑可以断续做评注。&lt;/p&gt;
&lt;p&gt;如果小黑有需要，也可以把&lt;code&gt;marys-feature&lt;/code&gt;分支拉到本地，自己来修改，他加的提交也会一样显示在&lt;code&gt;Pull Request&lt;/code&gt;上。&lt;/p&gt;
&lt;h4 id=&quot;小红发布她的功能&quot;&gt;&lt;a href=&quot;#小红发布她的功能&quot; class=&quot;headerlink&quot; title=&quot;小红发布她的功能&quot;&gt;&lt;/a&gt;小红发布她的功能&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflow-feature-branch-7.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;一旦小黑可以的接受&lt;code&gt;Pull Request&lt;/code&gt;，就可以合并功能到稳定项目代码中（可以由小黑或是小红来做这个操作）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git checkout master
git pull
git pull origin marys-feature
git push
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;无论谁来做合并，首先要检出&lt;code&gt;master&lt;/code&gt;分支并确认是它是最新的。然后执行&lt;code&gt;git pull origin marys-feature&lt;/code&gt;合并&lt;code&gt;marys-feature&lt;/code&gt;分支到和已经和远程一致的本地&lt;code&gt;master&lt;/code&gt;分支。&lt;br&gt;你可以使用简单&lt;code&gt;git merge marys-feature&lt;/code&gt;命令，但前面的命令可以保证总是最新的新功能分支。&lt;br&gt;最后更新的&lt;code&gt;master&lt;/code&gt;分支要重新&lt;code&gt;push&lt;/code&gt;回到&lt;code&gt;origin&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个过程常常会生成一个合并提交。有些开发者喜欢有合并提交，因为它像一个新功能和原来代码基线的连通符。&lt;br&gt;但如果你偏爱线性的提交历史，可以在执行合并时&lt;code&gt;rebase&lt;/code&gt;新功能到&lt;code&gt;master&lt;/code&gt;分支的顶部，这样生成一个快进（&lt;code&gt;fast-forward&lt;/code&gt;）的合并。&lt;/p&gt;
&lt;p&gt;一些&lt;code&gt;GUI&lt;/code&gt;客户端可以只要点一下『接受』按钮执行好上面的命令来自动化&lt;code&gt;Pull Request&lt;/code&gt;接受过程。&lt;br&gt;如果你的不能这样，至少在功能合并到&lt;code&gt;master&lt;/code&gt;分支后能自动关闭&lt;code&gt;Pull Request&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;与此同时，小明在做和小红一样的事&quot;&gt;&lt;a href=&quot;#与此同时，小明在做和小红一样的事&quot; class=&quot;headerlink&quot; title=&quot;与此同时，小明在做和小红一样的事&quot;&gt;&lt;/a&gt;与此同时，小明在做和小红一样的事&lt;/h4&gt;&lt;p&gt;当小红和小黑在&lt;code&gt;marys-feature&lt;/code&gt;上工作并讨论她的&lt;code&gt;Pull Request&lt;/code&gt;的时候，小明在自己的功能分支上做完全一样的事。&lt;/p&gt;
&lt;p&gt;通过隔离功能到独立的分支上，每个人都可以自主的工作，当然必要的时候在开发者之间分享变更还是比较繁琐的。&lt;/p&gt;
&lt;p&gt;到了这里，但愿你发现了功能分支可以很直接地在 &lt;code&gt;集中式工作流&lt;/code&gt; 的仅有的&lt;code&gt;master&lt;/code&gt;分支上完成多功能的开发。&lt;br&gt;另外，功能分支还使用了&lt;code&gt;Pull Request&lt;/code&gt;，使得可以在你的版本控制&lt;code&gt;GUI&lt;/code&gt;客户端中讨论某个提交。&lt;/p&gt;
&lt;p&gt;功能分支工作流是开发项目异常灵活的方式。问题是，有时候太灵活了。对于大型团队，常常需要给不同分支分配一个更具体的角色。&lt;br&gt;&lt;code&gt;Gitflow&lt;/code&gt;工作流是管理功能开发、发布准备和维护的常用模式。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;2-3-Gitflow工作流&quot;&gt;&lt;a href=&quot;#2-3-Gitflow工作流&quot; class=&quot;headerlink&quot; title=&quot;2.3 Gitflow工作流&quot;&gt;&lt;/a&gt;2.3 &lt;code&gt;Gitflow&lt;/code&gt;工作流&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Gitflow&lt;/code&gt;工作流通过为功能开发、发布准备和维护分配独立的分支，让发布迭代过程更流畅。严格的分支模型也为大型项目提供了一些非常必要的结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/git-workflows-gitflow.png&quot; alt=&quot;Git Workflows: Gitflow Cycle&quot;&gt;&lt;/p&gt;
&lt;p&gt;这节介绍的&lt;a href=&quot;http://nvie.com/posts/a-successful-git-branching-model/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;Gitflow&lt;/code&gt;工作流&lt;/a&gt;借鉴自在&lt;a href=&quot;http://nvie.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;nvie&lt;/a&gt;的&lt;em&gt;Vincent Driessen&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Gitflow&lt;/code&gt;工作流定义了一个围绕项目发布的严格分支模型。虽然比&lt;a href=&quot;workflow-feature-branch.md&quot;&gt;功能分支工作流&lt;/a&gt;复杂几分，但提供了用于一个健壮的用于管理大型项目的框架。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Gitflow&lt;/code&gt;工作流没有用超出功能分支工作流的概念和命令，而是为不同的分支分配一个明确的角色，并定义分支之间如何和什么时候进行交互。&lt;br&gt;除了使用功能分支，在做准备、维护和记录发布时，也定义了各自的分支。&lt;br&gt;当然你可以用上功能分支工作流所有的好处：&lt;code&gt;Pull Requests&lt;/code&gt;、隔离实验性开发和更高效的协作。&lt;/p&gt;
&lt;h3 id=&quot;2-3-1-工作方式&quot;&gt;&lt;a href=&quot;#2-3-1-工作方式&quot; class=&quot;headerlink&quot; title=&quot;2.3.1 工作方式&quot;&gt;&lt;/a&gt;2.3.1 工作方式&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Gitflow&lt;/code&gt;工作流仍然用中央仓库作为所有开发者的交互中心。和其它的工作流一样，开发者在本地工作并&lt;code&gt;push&lt;/code&gt;分支到要中央仓库中。&lt;/p&gt;
&lt;h3 id=&quot;2-3-2-历史分支&quot;&gt;&lt;a href=&quot;#2-3-2-历史分支&quot; class=&quot;headerlink&quot; title=&quot;2.3.2 历史分支&quot;&gt;&lt;/a&gt;2.3.2 历史分支&lt;/h3&gt;&lt;p&gt;相对于使用仅有的一个&lt;code&gt;master&lt;/code&gt;分支，&lt;code&gt;Gitflow&lt;/code&gt;工作流使用两个分支来记录项目的历史。&lt;code&gt;master&lt;/code&gt;分支存储了正式发布的历史，而&lt;code&gt;develop&lt;/code&gt;分支作为功能的集成分支。&lt;br&gt;这样也方便&lt;code&gt;master&lt;/code&gt;分支上的所有提交分配一个版本号。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/git-workflow-release-cycle-1historical.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;剩下要说明的问题围绕着这2个分支的区别展开。&lt;/p&gt;
&lt;h3 id=&quot;2-3-3-功能分支&quot;&gt;&lt;a href=&quot;#2-3-3-功能分支&quot; class=&quot;headerlink&quot; title=&quot;2.3.3 功能分支&quot;&gt;&lt;/a&gt;2.3.3 功能分支&lt;/h3&gt;&lt;p&gt;每个新功能位于一个自己的分支，这样可以&lt;a href=&quot;https://www.atlassian.com/git/tutorial/remote-repositories#!push&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;push&lt;/code&gt;到中央仓库以备份和协作&lt;/a&gt;。&lt;br&gt;但功能分支不是从&lt;code&gt;master&lt;/code&gt;分支上拉出新分支，而是使用&lt;code&gt;develop&lt;/code&gt;分支作为父分支。当新功能完成时，&lt;a href=&quot;https://www.atlassian.com/git/tutorial/git-branches#!merge&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;合并回&lt;code&gt;develop&lt;/code&gt;分支&lt;/a&gt;。&lt;br&gt;新功能提交应该从不直接与&lt;code&gt;master&lt;/code&gt;分支交互。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/git-workflow-release-cycle-2feature.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;注意，从各种含义和目的上来看，功能分支加上&lt;code&gt;develop&lt;/code&gt;分支就是功能分支工作流的用法。但&lt;code&gt;Gitflow&lt;/code&gt;工作流没有在这里止步。&lt;/p&gt;
&lt;h3 id=&quot;2-3-4-发布分支&quot;&gt;&lt;a href=&quot;#2-3-4-发布分支&quot; class=&quot;headerlink&quot; title=&quot;2.3.4 发布分支&quot;&gt;&lt;/a&gt;2.3.4 发布分支&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflow-release-cycle-3release.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;一旦&lt;code&gt;develop&lt;/code&gt;分支上有了做一次发布（或者说快到了既定的发布日）的足够功能，就从&lt;code&gt;develop&lt;/code&gt;分支上&lt;code&gt;checkout&lt;/code&gt;一个发布分支。&lt;br&gt;新建的分支用于开始发布循环，所以从这个时间点开始之后新的功能不能再加到这个分支上——&lt;br&gt;这个分支只应该做&lt;code&gt;Bug&lt;/code&gt;修复、文档生成和其它面向发布任务。&lt;br&gt;一旦对外发布的工作都完成了，发布分支合并到&lt;code&gt;master&lt;/code&gt;分支并分配一个版本号打好&lt;code&gt;Tag&lt;/code&gt;。&lt;br&gt;另外，这些从新建发布分支以来的做的修改要合并回&lt;code&gt;develop&lt;/code&gt;分支。&lt;/p&gt;
&lt;p&gt;使用一个用于发布准备的专门分支，使得一个团队可以在完善当前的发布版本的同时，另一个团队可以继续开发下个版本的功能。&lt;br&gt;这也打造定义良好的开发阶段（比如，可以很轻松地说，『这周我们要做准备发布版本4.0』，并且在仓库的目录结构中可以实际看到）。&lt;/p&gt;
&lt;p&gt;常用的分支约定：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;用于新建发布分支的分支: develop
用于合并的分支: master
分支命名: release-* 或 release/*
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-3-5-维护分支&quot;&gt;&lt;a href=&quot;#2-3-5-维护分支&quot; class=&quot;headerlink&quot; title=&quot;2.3.5 维护分支&quot;&gt;&lt;/a&gt;2.3.5 维护分支&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflow-release-cycle-4maintenance.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;维护分支或说是热修复（&lt;code&gt;hotfix&lt;/code&gt;）分支用于给产品发布版本（&lt;code&gt;production releases&lt;/code&gt;）快速生成补丁，这是唯一可以直接从&lt;code&gt;master&lt;/code&gt;分支&lt;code&gt;fork&lt;/code&gt;出来的分支。&lt;br&gt;修复完成，修改应该马上合并回&lt;code&gt;master&lt;/code&gt;分支和&lt;code&gt;develop&lt;/code&gt;分支（当前的发布分支），&lt;code&gt;master&lt;/code&gt;分支应该用新的版本号打好&lt;code&gt;Tag&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;为&lt;code&gt;Bug&lt;/code&gt;修复使用专门分支，让团队可以处理掉问题而不用打断其它工作或是等待下一个发布循环。&lt;br&gt;你可以把维护分支想成是一个直接在&lt;code&gt;master&lt;/code&gt;分支上处理的临时发布。&lt;/p&gt;
&lt;h3 id=&quot;2-3-6-示例&quot;&gt;&lt;a href=&quot;#2-3-6-示例&quot; class=&quot;headerlink&quot; title=&quot;2.3.6 示例&quot;&gt;&lt;/a&gt;2.3.6 示例&lt;/h3&gt;&lt;p&gt;下面的示例演示本工作流如何用于管理单个发布循环。假设你已经创建了一个中央仓库。&lt;/p&gt;
&lt;h4 id=&quot;创建开发分支&quot;&gt;&lt;a href=&quot;#创建开发分支&quot; class=&quot;headerlink&quot; title=&quot;创建开发分支&quot;&gt;&lt;/a&gt;创建开发分支&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflow-release-cycle-5createdev.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;第一步为&lt;code&gt;master&lt;/code&gt;分支配套一个&lt;code&gt;develop&lt;/code&gt;分支。简单来做可以&lt;a href=&quot;https://www.atlassian.com/git/tutorial/git-branches#!branch&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;本地创建一个空的&lt;code&gt;develop&lt;/code&gt;分支&lt;/a&gt;，&lt;code&gt;push&lt;/code&gt;到服务器上：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git branch develop
git push -u origin develop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以后这个分支将会包含了项目的全部历史，而&lt;code&gt;master&lt;/code&gt;分支将只包含了部分历史。其它开发者这时应该&lt;a href=&quot;https://www.atlassian.com/git/tutorial/git-basics#!clone&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;克隆中央仓库&lt;/a&gt;，建好&lt;code&gt;develop&lt;/code&gt;分支的跟踪分支：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git clone ssh://user@host/path/to/repo.git
git checkout -b develop origin/develop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在每个开发都有了这些历史分支的本地拷贝。&lt;/p&gt;
&lt;h4 id=&quot;小红和小明开始开发新功能&quot;&gt;&lt;a href=&quot;#小红和小明开始开发新功能&quot; class=&quot;headerlink&quot; title=&quot;小红和小明开始开发新功能&quot;&gt;&lt;/a&gt;小红和小明开始开发新功能&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflow-release-cycle-6maryjohnbeginnew.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个示例中，小红和小明开始各自的功能开发。他们需要为各自的功能创建相应的分支。新分支不是基于&lt;code&gt;master&lt;/code&gt;分支，而是应该&lt;a href=&quot;https://www.atlassian.com/git/tutorial/git-branches#!checkout&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;基于&lt;code&gt;develop&lt;/code&gt;分支&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git checkout -b some-feature develop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;他们用老套路添加提交到各自功能分支上：编辑、暂存、提交：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git status
git add &amp;lt;some-file&amp;gt;
git commit
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;小红完成功能开发-1&quot;&gt;&lt;a href=&quot;#小红完成功能开发-1&quot; class=&quot;headerlink&quot; title=&quot;小红完成功能开发&quot;&gt;&lt;/a&gt;小红完成功能开发&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflow-release-cycle-7maryfinishes.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;添加了提交后，小红觉得她的功能OK了。如果团队使用&lt;code&gt;Pull Requests&lt;/code&gt;，这时候可以发起一个用于合并到&lt;code&gt;develop&lt;/code&gt;分支。&lt;br&gt;否则她可以直接合并到她本地的&lt;code&gt;develop&lt;/code&gt;分支后&lt;code&gt;push&lt;/code&gt;到中央仓库：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git pull origin develop
git checkout develop
git merge some-feature
git push
git branch -d some-feature
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一条命令在合并功能前确保&lt;code&gt;develop&lt;/code&gt;分支是最新的。注意，功能决不应该直接合并到&lt;code&gt;master&lt;/code&gt;分支。&lt;br&gt;冲突解决方法和&lt;a href=&quot;workflow-centralized.md&quot;&gt;集中式工作流&lt;/a&gt;一样。&lt;/p&gt;
&lt;h4 id=&quot;小红开始准备发布&quot;&gt;&lt;a href=&quot;#小红开始准备发布&quot; class=&quot;headerlink&quot; title=&quot;小红开始准备发布&quot;&gt;&lt;/a&gt;小红开始准备发布&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflow-release-cycle-8maryprepsrelease.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个时候小明正在实现他的功能，小红开始准备她的第一个项目正式发布。&lt;br&gt;像功能开发一样，她用一个新的分支来做发布准备。这一步也确定了发布的版本号：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git checkout -b release-0.1 develop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个分支是清理发布、执行所有测试、更新文档和其它为下个发布做准备操作的地方，像是一个专门用于改善发布的功能分支。&lt;/p&gt;
&lt;p&gt;只要小红创建这个分支并&lt;code&gt;push&lt;/code&gt;到中央仓库，这个发布就是功能冻结的。任何不在&lt;code&gt;develop&lt;/code&gt;分支中的新功能都推到下个发布循环中。&lt;/p&gt;
&lt;h4 id=&quot;小红完成发布&quot;&gt;&lt;a href=&quot;#小红完成发布&quot; class=&quot;headerlink&quot; title=&quot;小红完成发布&quot;&gt;&lt;/a&gt;小红完成发布&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflow-release-cycle-9maryfinishes.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;一旦准备好了对外发布，小红合并修改到&lt;code&gt;master&lt;/code&gt;分支和&lt;code&gt;develop&lt;/code&gt;分支上，删除发布分支。合并回&lt;code&gt;develop&lt;/code&gt;分支很重要，因为在发布分支中已经提交的更新需要在后面的新功能中也要是可用的。&lt;br&gt;另外，如果小红的团队要求&lt;code&gt;Code Review&lt;/code&gt;，这是一个发起&lt;code&gt;Pull Request&lt;/code&gt;的理想时机。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git checkout master
git merge release-0.1
git push
git checkout develop
git merge release-0.1
git push
git branch -d release-0.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发布分支是作为功能开发（&lt;code&gt;develop&lt;/code&gt;分支）和对外发布（&lt;code&gt;master&lt;/code&gt;分支）间的缓冲。只要有合并到&lt;code&gt;master&lt;/code&gt;分支，就应该打好&lt;code&gt;Tag&lt;/code&gt;以方便跟踪。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git tag -a 0.1 -m &amp;quot;Initial public release&amp;quot; master
git push --tags
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Git&lt;/code&gt;有提供各种勾子（&lt;code&gt;hook&lt;/code&gt;），即仓库有事件发生时触发执行的脚本。&lt;br&gt;可以配置一个勾子，在你&lt;code&gt;push&lt;/code&gt;中央仓库的&lt;code&gt;master&lt;/code&gt;分支时，自动构建好版本，并对外发布。&lt;/p&gt;
&lt;h4 id=&quot;最终用户发现Bug&quot;&gt;&lt;a href=&quot;#最终用户发现Bug&quot; class=&quot;headerlink&quot; title=&quot;最终用户发现Bug&quot;&gt;&lt;/a&gt;最终用户发现&lt;code&gt;Bug&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflow-gitflow-enduserbug.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;对外版本发布后，小红小明一起开发下一版本的新功能，直到有最终用户开了一个&lt;code&gt;Ticket&lt;/code&gt;抱怨当前版本的一个&lt;code&gt;Bug&lt;/code&gt;。&lt;br&gt;为了处理&lt;code&gt;Bug&lt;/code&gt;，小红（或小明）从&lt;code&gt;master&lt;/code&gt;分支上拉出了一个维护分支，提交修改以解决问题，然后直接合并回&lt;code&gt;master&lt;/code&gt;分支：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git checkout -b issue-#001 master
# Fix the bug
git checkout master
git merge issue-#001
git push
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就像发布分支，维护分支中新加这些重要修改需要包含到&lt;code&gt;develop&lt;/code&gt;分支中，所以小红要执行一个合并操作。然后就可以安全地&lt;a href=&quot;https://www.atlassian.com/git/tutorial/git-branches#!branch&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;删除这个分支&lt;/a&gt;了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git checkout develop
git merge issue-#001
git push
git branch -d issue-#001
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到了这里，但愿你对&lt;a href=&quot;workflow-centralized.md&quot;&gt;集中式工作流&lt;/a&gt;、&lt;a href=&quot;workflow-feature-branch.md&quot;&gt;功能分支工作流&lt;/a&gt;和&lt;code&gt;Gitflow&lt;/code&gt;工作流已经感觉很舒适了。&lt;br&gt;你应该也牢固的掌握了本地仓库的潜能，&lt;code&gt;push&lt;/code&gt;/&lt;code&gt;pull&lt;/code&gt;模式和&lt;code&gt;Git&lt;/code&gt;健壮的分支和合并模型。&lt;/p&gt;
&lt;p&gt;记住，这里演示的工作流只是可能用法的例子，而不是在实际工作中使用&lt;code&gt;Git&lt;/code&gt;不可违逆的条例。&lt;br&gt;所以不要畏惧按自己需要对工作流的用法做取舍。不变的目标就是让&lt;code&gt;Git&lt;/code&gt;为你所用。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;2-4-Forking工作流&quot;&gt;&lt;a href=&quot;#2-4-Forking工作流&quot; class=&quot;headerlink&quot; title=&quot;2.4 Forking工作流&quot;&gt;&lt;/a&gt;2.4 &lt;code&gt;Forking&lt;/code&gt;工作流&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Forking&lt;/code&gt;工作流是分布式工作流，充分利用了&lt;code&gt;Git&lt;/code&gt;在分支和克隆上的优势。可以安全可靠地管理大团队的开发者（&lt;code&gt;developer&lt;/code&gt;），并能接受不信任贡献者（&lt;code&gt;contributor&lt;/code&gt;）的提交。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Forking&lt;/code&gt;工作流和前面讨论的几种工作流有根本的不同，这种工作流不是使用单个服务端仓库作为『中央』代码基线，而让各个开发者都有一个服务端仓库。这意味着各个代码贡献者有2个&lt;code&gt;Git&lt;/code&gt;仓库而不是1个：一个本地私有的，另一个服务端公开的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/git-workflows-forking.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Forking&lt;/code&gt;工作流的一个主要优势是，贡献的代码可以被集成，而不需要所有人都能&lt;code&gt;push&lt;/code&gt;代码到仅有的中央仓库中。&lt;br&gt;开发者&lt;code&gt;push&lt;/code&gt;到自己的服务端仓库，而只有项目维护者才能&lt;code&gt;push&lt;/code&gt;到正式仓库。&lt;br&gt;这样项目维护者可以接受任何开发者的提交，但无需给他正式代码库的写权限。&lt;/p&gt;
&lt;p&gt;效果就是一个分布式的工作流，能为大型、自发性的团队（包括了不受信的第三方）提供灵活的方式来安全的协作。&lt;br&gt;也让这个工作流成为开源项目的理想工作流。&lt;/p&gt;
&lt;h3 id=&quot;2-4-1-工作方式&quot;&gt;&lt;a href=&quot;#2-4-1-工作方式&quot; class=&quot;headerlink&quot; title=&quot;2.4.1 工作方式&quot;&gt;&lt;/a&gt;2.4.1 工作方式&lt;/h3&gt;&lt;p&gt;和其它的&lt;code&gt;Git&lt;/code&gt;工作流一样，&lt;code&gt;Forking&lt;/code&gt;工作流要先有一个公开的正式仓库存储在服务器上。&lt;br&gt;但一个新的开发者想要在项目上工作时，不是直接从正式仓库克隆，而是&lt;code&gt;fork&lt;/code&gt;正式项目在服务器上创建一个拷贝。&lt;/p&gt;
&lt;p&gt;这个仓库拷贝作为他个人公开仓库 ——&lt;br&gt;其它开发者不允许&lt;code&gt;push&lt;/code&gt;到这个仓库，但可以&lt;code&gt;pull&lt;/code&gt;到修改（后面我们很快就会看这点很重要）。&lt;br&gt;在创建了自己服务端拷贝之后，和之前的工作流一样，开发者执行&lt;a href=&quot;https://www.atlassian.com/git/tutorial/git-basics#!clone&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;git clone&lt;/code&gt;命令&lt;/a&gt;克隆仓库到本地机器上，作为私有的开发环境。&lt;/p&gt;
&lt;p&gt;要提交本地修改时，&lt;code&gt;push&lt;/code&gt;提交到自己公开仓库中 —— 而不是正式仓库中。&lt;br&gt;然后，给正式仓库发起一个&lt;code&gt;pull request&lt;/code&gt;，让项目维护者知道有更新已经准备好可以集成了。&lt;br&gt;对于贡献的代码，&lt;code&gt;pull request&lt;/code&gt;也可以很方便地作为一个讨论的地方。&lt;/p&gt;
&lt;p&gt;为了集成功能到正式代码库，维护者&lt;code&gt;pull&lt;/code&gt;贡献者的变更到自己的本地仓库中，检查变更以确保不会让项目出错，&lt;br&gt;&lt;a href=&quot;https://www.atlassian.com/git/tutorial/git-branches#!merge&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;合并变更到自己本地的&lt;code&gt;master&lt;/code&gt;分支&lt;/a&gt;，&lt;br&gt;然后&lt;a href=&quot;https://www.atlassian.com/git/tutorial/remote-repositories#!push&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt;&lt;code&gt;master&lt;/code&gt;分支到服务器的正式仓库中。&lt;br&gt;到此，贡献的提交成为了项目的一部分，其它的开发者应该执行&lt;code&gt;pull&lt;/code&gt;操作与正式仓库同步自己本地仓库。&lt;/p&gt;
&lt;h3 id=&quot;2-4-2-正式仓库&quot;&gt;&lt;a href=&quot;#2-4-2-正式仓库&quot; class=&quot;headerlink&quot; title=&quot;2.4.2 正式仓库&quot;&gt;&lt;/a&gt;2.4.2 正式仓库&lt;/h3&gt;&lt;p&gt;在&lt;code&gt;Forking&lt;/code&gt;工作流中，『官方』仓库的叫法只是一个约定，理解这点很重要。&lt;br&gt;从技术上来看，各个开发者仓库和正式仓库在&lt;code&gt;Git&lt;/code&gt;看来没有任何区别。&lt;br&gt;事实上，让正式仓库之所以正式的唯一原因是它是项目维护者的公开仓库。&lt;/p&gt;
&lt;h3 id=&quot;2-4-3-Forking工作流的分支使用方式&quot;&gt;&lt;a href=&quot;#2-4-3-Forking工作流的分支使用方式&quot; class=&quot;headerlink&quot; title=&quot;2.4.3 Forking工作流的分支使用方式&quot;&gt;&lt;/a&gt;2.4.3 &lt;code&gt;Forking&lt;/code&gt;工作流的分支使用方式&lt;/h3&gt;&lt;p&gt;所有的个人公开仓库实际上只是为了方便和其它的开发者共享分支。&lt;br&gt;各个开发者应该用分支隔离各个功能，就像在&lt;a href=&quot;workflow-feature-branch.md&quot;&gt;功能分支工作流&lt;/a&gt;和&lt;a href=&quot;workflow-forking.md&quot;&gt;&lt;code&gt;Gitflow&lt;/code&gt;工作流&lt;/a&gt;一样。&lt;br&gt;唯一的区别是这些分支被共享了。在&lt;code&gt;Forking&lt;/code&gt;工作流中这些分支会被&lt;code&gt;pull&lt;/code&gt;到另一个开发者的本地仓库中，而在功能分支工作流和&lt;code&gt;Gitflow&lt;/code&gt;工作流中是直接被&lt;code&gt;push&lt;/code&gt;到正式仓库中。&lt;/p&gt;
&lt;h3 id=&quot;2-4-4-示例&quot;&gt;&lt;a href=&quot;#2-4-4-示例&quot; class=&quot;headerlink&quot; title=&quot;2.4.4 示例&quot;&gt;&lt;/a&gt;2.4.4 示例&lt;/h3&gt;&lt;h4 id=&quot;项目维护者初始化正式仓库&quot;&gt;&lt;a href=&quot;#项目维护者初始化正式仓库&quot; class=&quot;headerlink&quot; title=&quot;项目维护者初始化正式仓库&quot;&gt;&lt;/a&gt;项目维护者初始化正式仓库&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflows-forking-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;和任何使用&lt;code&gt;Git&lt;/code&gt;项目一样，第一步是创建在服务器上一个正式仓库，让所有团队成员都可以访问到。&lt;br&gt;通常这个仓库也会作为项目维护者的公开仓库。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.atlassian.com/git/tutorial/git-basics#!init&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;公开仓库应该是裸仓库&lt;/a&gt;，不管是不是正式代码库。&lt;br&gt;所以项目维护者会运行像下面的命令来搭建正式仓库：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;ssh user@host
git init --bare /path/to/repo.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Bitbucket&lt;/code&gt;和&lt;code&gt;Stash&lt;/code&gt;提供了一个方便的&lt;code&gt;GUI&lt;/code&gt;客户端以完成上面命令行做的事。&lt;br&gt;这个搭建中央仓库的过程和前面提到的工作流完全一样。&lt;br&gt;如果有现存的代码库，维护者也要&lt;code&gt;push&lt;/code&gt;到这个仓库中。&lt;/p&gt;
&lt;h4 id=&quot;开发者fork正式仓库&quot;&gt;&lt;a href=&quot;#开发者fork正式仓库&quot; class=&quot;headerlink&quot; title=&quot;开发者fork正式仓库&quot;&gt;&lt;/a&gt;开发者&lt;code&gt;fork&lt;/code&gt;正式仓库&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflows-forking-2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其它所有的开发需要&lt;code&gt;fork&lt;/code&gt;正式仓库。&lt;br&gt;可以用&lt;code&gt;git clone&lt;/code&gt;命令&lt;a href=&quot;https://confluence.atlassian.com/display/BITBUCKET/Set+up+SSH+for+Git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;用&lt;code&gt;SSH&lt;/code&gt;协议连通到服务器&lt;/a&gt;，&lt;br&gt;拷贝仓库到服务器另一个位置 —— 是的，&lt;code&gt;fork&lt;/code&gt;操作基本上就只是一个服务端的克隆。&lt;br&gt;&lt;code&gt;Bitbucket&lt;/code&gt;和&lt;code&gt;Stash&lt;/code&gt;上可以点一下按钮就让开发者完成仓库的&lt;code&gt;fork&lt;/code&gt;操作。&lt;/p&gt;
&lt;p&gt;这一步完成后，每个开发都在服务端有一个自己的仓库。和正式仓库一样，这些仓库应该是裸仓库。&lt;/p&gt;
&lt;h4 id=&quot;开发者克隆自己fork出来的仓库&quot;&gt;&lt;a href=&quot;#开发者克隆自己fork出来的仓库&quot; class=&quot;headerlink&quot; title=&quot;开发者克隆自己fork出来的仓库&quot;&gt;&lt;/a&gt;开发者克隆自己&lt;code&gt;fork&lt;/code&gt;出来的仓库&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflows-forking-3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;下一步，各个开发者要克隆自己的公开仓库，用熟悉的&lt;code&gt;git clone&lt;/code&gt;命令。&lt;/p&gt;
&lt;p&gt;在这个示例中，假定用&lt;code&gt;Bitbucket&lt;/code&gt;托管了仓库。记住，如果这样的话各个开发者需要有各自的&lt;code&gt;Bitbucket&lt;/code&gt;账号，&lt;br&gt;使用下面命令克隆服务端自己的仓库：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git clone https://user@bitbucket.org/user/repo.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相比前面介绍的工作流只用了一个&lt;code&gt;origin&lt;/code&gt;远程别名指向中央仓库，&lt;code&gt;Forking&lt;/code&gt;工作流需要2个远程别名 ——&lt;br&gt;一个指向正式仓库，另一个指向开发者自己的服务端仓库。别名的名字可以任意命名，常见的约定是使用&lt;code&gt;origin&lt;/code&gt;作为远程克隆的仓库的别名&lt;br&gt;（这个别名会在运行&lt;code&gt;git clone&lt;/code&gt;自动创建），&lt;code&gt;upstream&lt;/code&gt;（上游）作为正式仓库的别名。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git remote add upstream https://bitbucket.org/maintainer/repo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要自己用上面的命令创建&lt;code&gt;upstream&lt;/code&gt;别名。这样可以简单地保持本地仓库和正式仓库的同步更新。&lt;br&gt;注意，如果上游仓库需要认证（比如不是开源的），你需要提供用户：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git remote add upstream https://user@bitbucket.org/maintainer/repo.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时在克隆和&lt;code&gt;pull&lt;/code&gt;正式仓库时，需要提供用户的密码。&lt;/p&gt;
&lt;h4 id=&quot;开发者开发自己的功能&quot;&gt;&lt;a href=&quot;#开发者开发自己的功能&quot; class=&quot;headerlink&quot; title=&quot;开发者开发自己的功能&quot;&gt;&lt;/a&gt;开发者开发自己的功能&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflows-forking-4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在刚克隆的本地仓库中，开发者可以像其它工作流一样的编辑代码、&lt;a href=&quot;https://www.atlassian.com/git/tutorial/git-basics#!commit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;提交修改&lt;/a&gt;和&lt;a href=&quot;https://www.atlassian.com/git/tutorial/git-branches#!branch&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;新建分支&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git checkout -b some-feature
# Edit some code
git commit -a -m &amp;quot;Add first draft of some feature&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有的修改都是私有的直到&lt;code&gt;push&lt;/code&gt;到自己公开仓库中。如果正式项目已经往前走了，可以用&lt;a href=&quot;https://www.atlassian.com/git/tutorial/remote-repositories#!pull&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;git pull&lt;/code&gt;命令&lt;/a&gt;获得新的提交：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git pull upstream master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于开发者应该都在专门的功能分支上工作，&lt;code&gt;pull&lt;/code&gt;操作结果会都是&lt;a href=&quot;https://www.atlassian.com/git/tutorial/git-branches#!merge&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;快进合并&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;开发者发布自己的功能&quot;&gt;&lt;a href=&quot;#开发者发布自己的功能&quot; class=&quot;headerlink&quot; title=&quot;开发者发布自己的功能&quot;&gt;&lt;/a&gt;开发者发布自己的功能&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflows-forking-5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;一旦开发者准备好了分享新功能，需要做二件事。&lt;br&gt;首先，通过&lt;code&gt;push&lt;/code&gt;他的贡献代码到自己的公开仓库中，让其它的开发者都可以访问到。&lt;br&gt;他的&lt;code&gt;origin&lt;/code&gt;远程别名应该已经有了，所以要做的就是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git push origin feature-branch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里和之前的工作流的差异是，&lt;code&gt;origin&lt;/code&gt;远程别名指向开发者自己的服务端仓库，而不是正式仓库。&lt;/p&gt;
&lt;p&gt;第二件事，开发者要通知项目维护者，想要合并他的新功能到正式库中。&lt;br&gt;&lt;code&gt;Bitbucket&lt;/code&gt;和&lt;code&gt;Stash&lt;/code&gt;提供了&lt;a href=&quot;https://confluence.atlassian.com/display/STASH/Using+pull+requests+in+Stash&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;Pull Request&lt;/code&gt;&lt;/a&gt;按钮，弹出表单让你指定哪个分支要合并到正式仓库。&lt;br&gt;一般你会想集成你的功能分支到上游远程仓库的&lt;code&gt;master&lt;/code&gt;分支中。&lt;/p&gt;
&lt;h4 id=&quot;项目维护者集成开发者的功能&quot;&gt;&lt;a href=&quot;#项目维护者集成开发者的功能&quot; class=&quot;headerlink&quot; title=&quot;项目维护者集成开发者的功能&quot;&gt;&lt;/a&gt;项目维护者集成开发者的功能&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflows-forking-6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当项目维护者收到&lt;code&gt;pull request&lt;/code&gt;，他要做的是决定是否集成它到正式代码库中。有二种方式来做：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;直接在&lt;code&gt;pull request&lt;/code&gt;中查看代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pull&lt;/code&gt;代码到他自己的本地仓库，再手动合并&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一种做法更简单，维护者可以在&lt;code&gt;GUI&lt;/code&gt;中查看变更的差异，做评注和执行合并。&lt;br&gt;但如果出现了合并冲突，需要第二种做法来解决。这种情况下，维护者需要从开发者的服务端仓库中&lt;a href=&quot;https://www.atlassian.com/git/tutorial/remote-repositories#!fetch&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;fetch&lt;/code&gt;&lt;/a&gt;功能分支，&lt;br&gt;合并到他本地的&lt;code&gt;master&lt;/code&gt;分支，解决冲突：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git fetch https://bitbucket.org/user/repo feature-branch
# 查看变更
git checkout master
git merge FETCH_HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变更集成到本地的&lt;code&gt;master&lt;/code&gt;分支后，维护者要&lt;code&gt;push&lt;/code&gt;变更到服务器上的正式仓库，这样其它的开发者都能访问到：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git push origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，维护者的&lt;code&gt;origin&lt;/code&gt;是指向他自己公开仓库的，即是项目的正式代码库。到此，开发者的贡献完全集成到了项目中。&lt;/p&gt;
&lt;h4 id=&quot;开发者和正式仓库做同步&quot;&gt;&lt;a href=&quot;#开发者和正式仓库做同步&quot; class=&quot;headerlink&quot; title=&quot;开发者和正式仓库做同步&quot;&gt;&lt;/a&gt;开发者和正式仓库做同步&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/git-workflows-forking-7.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;由于正式代码库往前走了，其它的开发需要和正式仓库做同步：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git pull upstream master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你之前是使用&lt;code&gt;SVN&lt;/code&gt;，&lt;code&gt;Forking&lt;/code&gt;工作流可能看起来像是一个激进的范式切换（paradigm shift）。&lt;br&gt;但不要害怕，这个工作流实际上就是在&lt;a href=&quot;workflow-feature-branch.md&quot;&gt;功能分支工作流&lt;/a&gt;之上引入另一个抽象层。&lt;br&gt;不是直接通过单个中央仓库来分享分支，而是把贡献代码发布到开发者自己的服务端仓库中。&lt;/p&gt;
&lt;p&gt;示例中解释了，一个贡献如何从一个开发者流到正式的&lt;code&gt;master&lt;/code&gt;分支中，但同样的方法可以把贡献集成到任一个仓库中。&lt;br&gt;比如，如果团队的几个人协作实现一个功能，可以在开发之间用相同的方法分享变更，完全不涉及正式仓库。&lt;/p&gt;
&lt;p&gt;这使得&lt;code&gt;Forking&lt;/code&gt;工作流对于松散组织的团队来说是个非常强大的工具。任一开发者可以方便地和另一开发者分享变更，任何分支都能有效地合并到正式代码库中。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;2-5-Pull-Requests&quot;&gt;&lt;a href=&quot;#2-5-Pull-Requests&quot; class=&quot;headerlink&quot; title=&quot;2.5 Pull Requests&quot;&gt;&lt;/a&gt;2.5 &lt;code&gt;Pull Requests&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Pull requests&lt;/code&gt;是&lt;code&gt;Bitbucket&lt;/code&gt;提供的让开发者更方便地进行协作的功能，提供了友好的&lt;code&gt;Web&lt;/code&gt;界面可以在提议的修改合并到正式项目之前对修改进行讨论。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/pull-request-bitbucket.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;开发者向团队成员通知功能开发已经完成，&lt;code&gt;Pull Requests&lt;/code&gt;是最简单的用法。&lt;br&gt;开发者完成功能开发后，通过&lt;code&gt;Bitbucket&lt;/code&gt;账号发起一个&lt;code&gt;Pull Request&lt;/code&gt;。&lt;br&gt;这样让涉及这个功能的所有人知道要去做&lt;code&gt;Code Review&lt;/code&gt;和合并到&lt;code&gt;master&lt;/code&gt;分支。&lt;/p&gt;
&lt;p&gt;但是，&lt;code&gt;Pull Request&lt;/code&gt;远不止一个简单的通知，而是为讨论提交的功能的一个专门论坛。&lt;br&gt;如果变更有任何问题，团队成员反馈在&lt;code&gt;Pull Request&lt;/code&gt;中，甚至&lt;code&gt;push&lt;/code&gt;新的提交微调功能。&lt;br&gt;所有的这些活动都直接跟踪在&lt;code&gt;Pull Request&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/pull-request-overview.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;相比其它的协作模型，这种分享提交的形式有助于打造一个更流畅的工作流。&lt;br&gt;&lt;code&gt;SVN&lt;/code&gt;和&lt;code&gt;Git&lt;/code&gt;都能通过一个简单的脚本收到通知邮件；但是，讨论变更时，开发者通常只能去回复邮件。&lt;br&gt;这样做会变得杂乱，尤其还要涉及后面的几个提交时。&lt;br&gt;&lt;code&gt;Pull Requests&lt;/code&gt;把所有相关功能整合到一个和&lt;code&gt;Bitbucket&lt;/code&gt;仓库界面集成的用户友好&lt;code&gt;Web&lt;/code&gt;界面中。&lt;/p&gt;
&lt;h3 id=&quot;2-5-1-解析Pull-Request&quot;&gt;&lt;a href=&quot;#2-5-1-解析Pull-Request&quot; class=&quot;headerlink&quot; title=&quot;2.5.1 解析Pull Request&quot;&gt;&lt;/a&gt;2.5.1 解析&lt;code&gt;Pull Request&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;当要发起一个&lt;code&gt;Pull Request&lt;/code&gt;，你所要做的就是请求（&lt;code&gt;Request&lt;/code&gt;）另一个开发者（比如项目的维护者）&lt;br&gt;来&lt;code&gt;pull&lt;/code&gt;你仓库中一个分支到他的仓库中。这意味着你要提供4个信息以发起&lt;code&gt;Pull Request&lt;/code&gt;：&lt;br&gt;源仓库、源分支、目的仓库、目的分支。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/pull-request-anatomy.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这几值多数&lt;code&gt;Bitbucket&lt;/code&gt;都会设置上合适的缺省值。但取决你用的协作工作流，你的团队可能会要指定不同的值。&lt;br&gt;上图显示了一个&lt;code&gt;Pull Request&lt;/code&gt;请求合并一个功能分支到正式的&lt;code&gt;master&lt;/code&gt;分支上，但可以有多种不同的&lt;code&gt;Pull Request&lt;/code&gt;用法。&lt;/p&gt;
&lt;h3 id=&quot;2-5-2-工作方式&quot;&gt;&lt;a href=&quot;#2-5-2-工作方式&quot; class=&quot;headerlink&quot; title=&quot;2.5.2 工作方式&quot;&gt;&lt;/a&gt;2.5.2 工作方式&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Pull Request&lt;/code&gt;可以和&lt;a href=&quot;workflow-feature-branch.md&quot;&gt;功能分支工作流&lt;/a&gt;、&lt;a href=&quot;workflow-gitflow.md&quot;&gt;&lt;code&gt;Gitflow&lt;/code&gt;工作流&lt;/a&gt;或&lt;a href=&quot;workflow-forking.md&quot;&gt;&lt;code&gt;Forking&lt;/code&gt;工作流&lt;/a&gt;一起使用。&lt;br&gt;但一个&lt;code&gt;Pull Request&lt;/code&gt;要求要么分支不同要么仓库不同，所以不能用于&lt;a href=&quot;workflow-centralized.md&quot;&gt;集中式工作流&lt;/a&gt;。&lt;br&gt;在不同的工作流中使用&lt;code&gt;Pull Request&lt;/code&gt;会有一些不同，但基本的过程是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开发者在本地仓库中新建一个专门的分支开发功能。&lt;/li&gt;
&lt;li&gt;开发者&lt;code&gt;push&lt;/code&gt;分支修改到公开的&lt;code&gt;Bitbucket&lt;/code&gt;仓库中。&lt;/li&gt;
&lt;li&gt;开发者通过&lt;code&gt;Bitbucket&lt;/code&gt;发起一个&lt;code&gt;Pull Request&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;团队的其它成员&lt;code&gt;review&lt;/code&gt; &lt;code&gt;code&lt;/code&gt;，讨论并修改。&lt;/li&gt;
&lt;li&gt;项目维护者合并功能到官方仓库中并关闭&lt;code&gt;Pull Request&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文后面内容说明，&lt;code&gt;Pull Request&lt;/code&gt;在不同协作工作流中如何应用。&lt;/p&gt;
&lt;h3 id=&quot;2-5-3-在功能分支工作流中使用Pull-Request&quot;&gt;&lt;a href=&quot;#2-5-3-在功能分支工作流中使用Pull-Request&quot; class=&quot;headerlink&quot; title=&quot;2.5.3 在功能分支工作流中使用Pull Request&quot;&gt;&lt;/a&gt;2.5.3 在功能分支工作流中使用&lt;code&gt;Pull Request&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;功能分支工作流用一个共享的&lt;code&gt;Bitbucket&lt;/code&gt;仓库来管理协作，开发者在专门的分支上开发功能。&lt;br&gt;但不是立即合并到&lt;code&gt;master&lt;/code&gt;分支上，而是在合并到主代码库之前开发者应该开一个&lt;code&gt;Pull Request&lt;/code&gt;发起功能的讨论。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/pull-request-feature-branch.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;功能分支工作流只有一个公开的仓库，所以&lt;code&gt;Pull Request&lt;/code&gt;的目的仓库和源仓库总是同一个。&lt;br&gt;通常开发者会指定他的功能分支作为源分支，&lt;code&gt;master&lt;/code&gt;分支作为目的分支。&lt;/p&gt;
&lt;p&gt;收到&lt;code&gt;Pull Request&lt;/code&gt;后，项目维护者要决定如何做。如果功能没问题，就简单地合并到&lt;code&gt;master&lt;/code&gt;分支，关闭&lt;code&gt;Pull Request&lt;/code&gt;。&lt;br&gt;但如果提交的变更有问题，他可以在&lt;code&gt;Pull Request&lt;/code&gt;中反馈。之后新加的提交也会评论之后接着显示出来。&lt;/p&gt;
&lt;p&gt;在功能还没有完全开发完的时候，也可能发起一个&lt;code&gt;Pull Request&lt;/code&gt;。&lt;br&gt;比如开发者在实现某个需求时碰到了麻烦，他可以发一个包含正在进行中工作的&lt;code&gt;Pull Request&lt;/code&gt;。&lt;br&gt;其它的开发者可以在&lt;code&gt;Pull Request&lt;/code&gt;提供建议，或者甚至直接添加提交来解决问题。&lt;/p&gt;
&lt;h3 id=&quot;2-5-4-在Gitflow工作流中使用Pull-Request&quot;&gt;&lt;a href=&quot;#2-5-4-在Gitflow工作流中使用Pull-Request&quot; class=&quot;headerlink&quot; title=&quot;2.5.4 在Gitflow工作流中使用Pull Request&quot;&gt;&lt;/a&gt;2.5.4 在&lt;code&gt;Gitflow&lt;/code&gt;工作流中使用&lt;code&gt;Pull Request&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Gitflow&lt;/code&gt;工作流和功能分支工作流类似，但围绕项目发布定义一个严格的分支模型。&lt;br&gt;在&lt;code&gt;Gitflow&lt;/code&gt;工作流中使用&lt;code&gt;Pull Request&lt;/code&gt;让开发者在发布分支或是维护分支上工作时，&lt;br&gt;可以有个方便的地方对关于发布分支或是维护分支的问题进行交流。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/gitflow-workflow-pull-request.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Gitflow&lt;/code&gt;工作流中&lt;code&gt;Pull Request&lt;/code&gt;的使用过程和上一节中完全一致：&lt;br&gt;当一个功能、发布或是热修复分支需要&lt;code&gt;Review&lt;/code&gt;时，开发者简单发起一个&lt;code&gt;Pull Request&lt;/code&gt;，&lt;br&gt;团队的其它成员会通过&lt;code&gt;Bitbucket&lt;/code&gt;收到通知。&lt;/p&gt;
&lt;p&gt;新功能一般合并到&lt;code&gt;develop&lt;/code&gt;分支，而发布和热修复则要同时合并到&lt;code&gt;develop&lt;/code&gt;分支和&lt;code&gt;master&lt;/code&gt;分支上。&lt;br&gt;&lt;code&gt;Pull Request&lt;/code&gt;可能用做所有合并的正式管理。&lt;/p&gt;
&lt;h3 id=&quot;2-5-5-在Forking工作流中使用Pull-Request&quot;&gt;&lt;a href=&quot;#2-5-5-在Forking工作流中使用Pull-Request&quot; class=&quot;headerlink&quot; title=&quot;2.5.5 在Forking工作流中使用Pull Request&quot;&gt;&lt;/a&gt;2.5.5 在&lt;code&gt;Forking&lt;/code&gt;工作流中使用&lt;code&gt;Pull Request&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;在&lt;code&gt;Forking&lt;/code&gt;工作流中，开发者&lt;code&gt;push&lt;/code&gt;完成的功能到他自己的仓库中，而不是共享仓库。&lt;br&gt;然后，他发起一个&lt;code&gt;Pull Request&lt;/code&gt;，让项目维护者知道他的功能已经可以&lt;code&gt;Review&lt;/code&gt;了。&lt;/p&gt;
&lt;p&gt;在这个工作流，&lt;code&gt;Pull Request&lt;/code&gt;的通知功能非常有用，&lt;br&gt;因为项目维护者不可能知道其它开发者在他们自己的仓库添加了提交。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/pull-request-forking-workflow-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;由于各个开发有自己的公开仓库，&lt;code&gt;Pull Request&lt;/code&gt;的源仓库和目标仓库不是同一个。&lt;br&gt;源仓库是开发者的公开仓库，源分支是包含了修改的分支。&lt;br&gt;如果开发者要合并修改到正式代码库中，那么目标仓库是正式仓库，目标分支是&lt;code&gt;master&lt;/code&gt;分支。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Pull Request&lt;/code&gt;也可以用于正式项目之外的其它开发者之间的协作。&lt;br&gt;比如，如果一个开发者和一个团队成员一起开发一个功能，他们可以发起一个&lt;code&gt;Pull Request&lt;/code&gt;，&lt;br&gt;用团队成员的&lt;code&gt;Bitbucket&lt;/code&gt;仓库作为目标，而不是正式项目的仓库。&lt;br&gt;然后使用相同的功能分支作为源和目标分支。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/pull-request-forking-workflow-2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2个开发者之间可以在&lt;code&gt;Pull Request&lt;/code&gt;中讨论和开发功能。&lt;br&gt;完成开发后，他们可以发起另一个&lt;code&gt;Pull Request&lt;/code&gt;，请求合并功能到正式的&lt;code&gt;master&lt;/code&gt;分支。&lt;br&gt;在&lt;code&gt;Forking&lt;/code&gt;工作流中，这样的灵活性让&lt;code&gt;Pull Request&lt;/code&gt;成为一个强有力的协作工具。&lt;/p&gt;
&lt;h3 id=&quot;2-5-6-示例&quot;&gt;&lt;a href=&quot;#2-5-6-示例&quot; class=&quot;headerlink&quot; title=&quot;2.5.6 示例&quot;&gt;&lt;/a&gt;2.5.6 示例&lt;/h3&gt;&lt;p&gt;下面的示例演示了&lt;code&gt;Pull Request&lt;/code&gt;如何在在&lt;code&gt;Forking&lt;/code&gt;工作流中使用。&lt;br&gt;也同样适用于小团队的开发协作和第三方开发者向开源项目的贡献。&lt;/p&gt;
&lt;p&gt;在示例中，小红是个开发，小明是项目维护者。他们各自有一个公开的&lt;code&gt;Bitbucket&lt;/code&gt;仓库，而小明的仓库包含了正式工程。&lt;/p&gt;
&lt;h4 id=&quot;小红fork正式项目&quot;&gt;&lt;a href=&quot;#小红fork正式项目&quot; class=&quot;headerlink&quot; title=&quot;小红fork正式项目&quot;&gt;&lt;/a&gt;小红&lt;code&gt;fork&lt;/code&gt;正式项目&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/pull-request-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;小红先要&lt;code&gt;fork&lt;/code&gt;小明的&lt;code&gt;Bitbucket&lt;/code&gt;仓库，开始项目的开发。她登陆&lt;code&gt;Bitbucket&lt;/code&gt;，浏览到小明的仓库页面，&lt;br&gt;点&lt;code&gt;Fork&lt;/code&gt;按钮。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/pull-request-2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后为&lt;code&gt;fork&lt;/code&gt;出来的仓库填写名字和描述，这样小红就有了服务端的项目拷贝了。&lt;/p&gt;
&lt;h4 id=&quot;小红克隆她的Bitbucket仓库&quot;&gt;&lt;a href=&quot;#小红克隆她的Bitbucket仓库&quot; class=&quot;headerlink&quot; title=&quot;小红克隆她的Bitbucket仓库&quot;&gt;&lt;/a&gt;小红克隆她的&lt;code&gt;Bitbucket&lt;/code&gt;仓库&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/pull-request-3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;下一步，小红克隆自己刚才&lt;code&gt;fork&lt;/code&gt;出来的&lt;code&gt;Bitbucket&lt;/code&gt;仓库，以在本机上准备出工作拷贝。命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git clone https://user@bitbucket.org/user/repo.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请记住，&lt;code&gt;git clone&lt;/code&gt;会自动创建&lt;code&gt;origin&lt;/code&gt;远程别名，是指向小红&lt;code&gt;fork&lt;/code&gt;出来的仓库。&lt;/p&gt;
&lt;h4 id=&quot;小红开发新功能&quot;&gt;&lt;a href=&quot;#小红开发新功能&quot; class=&quot;headerlink&quot; title=&quot;小红开发新功能&quot;&gt;&lt;/a&gt;小红开发新功能&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/pull-request-4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在开始改代码前，小红要为新功能先新建一个新分支。她会用这个分支作为&lt;code&gt;Pull Request&lt;/code&gt;的源分支。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git checkout -b some-feature
# 编辑代码
git commit -a -m &amp;quot;Add first draft of some feature&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在新功能分支上，小红按需要添加提交。甚至如果小红觉得功能分支上的提交历史太乱了，她可以用&lt;a href=&quot;https://www.atlassian.com/git/tutorial/rewriting-git-history#!rebase-i&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;交互式&lt;code&gt;rebase&lt;/code&gt;&lt;/a&gt;来删除或压制提交。&lt;br&gt;对于大型项目，整理功能分支的历史可以让项目维护者更容易看出在&lt;code&gt;Pull Request&lt;/code&gt;中做了什么内容。&lt;/p&gt;
&lt;h4 id=&quot;小红push功能到她的Bitbucket仓库中&quot;&gt;&lt;a href=&quot;#小红push功能到她的Bitbucket仓库中&quot; class=&quot;headerlink&quot; title=&quot;小红push功能到她的Bitbucket仓库中&quot;&gt;&lt;/a&gt;小红&lt;code&gt;push&lt;/code&gt;功能到她的&lt;code&gt;Bitbucket&lt;/code&gt;仓库中&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/pull-request-5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;小红完成了功能后，&lt;code&gt;push&lt;/code&gt;功能到她自己的&lt;code&gt;Bitbucket&lt;/code&gt;仓库中（不是正式仓库），用下面简单的命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git push origin some-branch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时她的变更可以让项目维护者看到了（或者任何想要看的协作者）。&lt;/p&gt;
&lt;h4 id=&quot;小红发起Pull-Request&quot;&gt;&lt;a href=&quot;#小红发起Pull-Request&quot; class=&quot;headerlink&quot; title=&quot;小红发起Pull Request&quot;&gt;&lt;/a&gt;小红发起&lt;code&gt;Pull Request&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/example-6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Bitbucket&lt;/code&gt;上有了她的功能分支后，小红可以用她的&lt;code&gt;Bitbucket&lt;/code&gt;账号浏览到她的&lt;code&gt;fork&lt;/code&gt;出来的仓库页面，&lt;br&gt;点右上角的【&lt;code&gt;Pull Request&lt;/code&gt;】按钮，发起一个&lt;code&gt;Pull Request&lt;/code&gt;。&lt;br&gt;弹出的表单自动设置小红的仓库为源仓库，询问小红以指定源分支、目标仓库和目标分支。&lt;/p&gt;
&lt;p&gt;小红想要合并功能到正式仓库，所以源分支是她的功能分支，目标仓库是小明的公开仓库，&lt;br&gt;而目标分支是&lt;code&gt;master&lt;/code&gt;分支。另外，小红需要提供&lt;code&gt;Pull Request&lt;/code&gt;的标题和描述信息。&lt;br&gt;如果需要小明以外的人审核批准代码，她可以把这些人填在【Reviewers】文本框中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/pull-request-7.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;创建好了&lt;code&gt;Pull Request&lt;/code&gt;，通知会通过&lt;code&gt;Bitbucket&lt;/code&gt;系统消息或邮件（可选）发给小明。&lt;/p&gt;
&lt;h4 id=&quot;小明review-Pull-Request&quot;&gt;&lt;a href=&quot;#小明review-Pull-Request&quot; class=&quot;headerlink&quot; title=&quot;小明review Pull Request&quot;&gt;&lt;/a&gt;小明review &lt;code&gt;Pull Request&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;images/pull-request-8.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在小明的&lt;code&gt;Bitbucket&lt;/code&gt;仓库页面的【&lt;code&gt;Pull Request&lt;/code&gt;】Tab可以看到所有人发起的&lt;code&gt;Pull Request&lt;/code&gt;。&lt;br&gt;点击小红的&lt;code&gt;Pull Request&lt;/code&gt;会显示出&lt;code&gt;Pull Request&lt;/code&gt;的描述、功能的提交历史和每个变更的差异（&lt;code&gt;diff&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;如果小明想要合并到项目中，只要点一下【&lt;code&gt;Merge&lt;/code&gt;】按钮，就可以同意&lt;code&gt;Pull Request&lt;/code&gt;并合并到&lt;code&gt;master&lt;/code&gt;分支。&lt;/p&gt;
&lt;p&gt;但如果像这个示例中一样小明发现了在小红的代码中的一个小&lt;code&gt;Bug&lt;/code&gt;，要小红在合并前修复。&lt;br&gt;小明可以在整个&lt;code&gt;Pull Request&lt;/code&gt;上加上评注，或是选择历史中的某个提交加上评注。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/pull-request-9.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;小红补加提交&quot;&gt;&lt;a href=&quot;#小红补加提交&quot; class=&quot;headerlink&quot; title=&quot;小红补加提交&quot;&gt;&lt;/a&gt;小红补加提交&lt;/h4&gt;&lt;p&gt;如果小红对反馈有任何疑问，可以在&lt;code&gt;Pull Request&lt;/code&gt;中响应，把&lt;code&gt;Pull Request&lt;/code&gt;当作是她功能讨论的论坛。&lt;/p&gt;
&lt;p&gt;小红在她的功能分支新加提交以解决代码问题，并&lt;code&gt;push&lt;/code&gt;到她的&lt;code&gt;Bitbucket&lt;/code&gt;仓库中，就像前一轮中的做法一样。&lt;br&gt;这些提交会进入的&lt;code&gt;Pull Request&lt;/code&gt;，小明在原来的评注旁边可以再次&lt;code&gt;review&lt;/code&gt;变更。&lt;/p&gt;
&lt;h4 id=&quot;小明接受Pull-Request&quot;&gt;&lt;a href=&quot;#小明接受Pull-Request&quot; class=&quot;headerlink&quot; title=&quot;小明接受Pull Request&quot;&gt;&lt;/a&gt;小明接受&lt;code&gt;Pull Request&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;最终，小明接受变更，合并功能分支到&lt;code&gt;Master&lt;/code&gt;分支，并关闭&lt;code&gt;Pull Request&lt;/code&gt;。&lt;br&gt;至此，功能集成到项目中，其它的项目开发者可以用标准的&lt;code&gt;git pull&lt;/code&gt;命令&lt;code&gt;pull&lt;/code&gt;这些变更到自己的本地仓库中。&lt;/p&gt;
&lt;p&gt;到了这里，你应该有了所有需要的工具来集成&lt;code&gt;Pull Request&lt;/code&gt;到你自己的工作流。&lt;br&gt;请记住，&lt;code&gt;Pull Request&lt;/code&gt;并不是为了替代任何 &lt;code&gt;基于&lt;/code&gt;Git&lt;code&gt;的协作工作流&lt;/code&gt;，&lt;br&gt;而是它们的一个便利的补充，让团队成员间的协作更轻松方便。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;三、企业日常开发模式探索&quot;&gt;&lt;a href=&quot;#三、企业日常开发模式探索&quot; class=&quot;headerlink&quot; title=&quot;三、企业日常开发模式探索&quot;&gt;&lt;/a&gt;三、企业日常开发模式探索&lt;/h1&gt;&lt;p&gt;在看这部分前，请先回顾阅读业界认可的成功的 Git Branch Work Flow 模型 &lt;a href=&quot;http://nvie.com/posts/a-successful-git-branching-model/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;A Successful Git Branching Model&lt;/a&gt; ，了解日常开发中的场景，有助于熟悉下面的使用过程。&lt;/p&gt;
&lt;p&gt;在企业开发中，使用 Git 作为版本控制软件最看重的还是结合公司自己搭建的 &lt;a href=&quot;https://about.gitlab.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Gitlab&lt;/a&gt;，将 Code Review 加入打包部署持续集成的流程中，这样，代码开发完成，提交测试前，便可以对开发人员提交的代码进行 Review，发现潜在的问题，及时指导，对于新人来讲，也能更快更好的学习。&lt;/p&gt;
&lt;p&gt;解决的需求场景如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能支持日常迭代开发、紧急线上bug修复、多功能并行开发&lt;/li&gt;
&lt;li&gt;大概50人左右的团队，平日迭代项目较多，且周期短（1~2周一个迭代）&lt;/li&gt;
&lt;li&gt;能够通过tag重建整个系统&lt;/li&gt;
&lt;li&gt;支持code review&lt;/li&gt;
&lt;li&gt;所有上线的代码必须都是经过测试保证，且能自动同步到下一次的迭代中&lt;/li&gt;
&lt;li&gt;能和公司的项目管理/持续集成系统整合&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;images/branch_module.png&quot; alt=&quot;图片&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图就是 xirong 团队在日常开发中总结出来的适合企业开发的模式，下面进行简单的介绍，方便大家学习了解，欢迎提交 Issue 进行讨论。（本模式适合敏捷开发流程，小迭代上线，传统的瀑布开发模型并没有进行测试）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;迭代需求会、冲刺会后确定本次迭代的目标后，将迭代内容视为一个项目，在 Gitlab 上创建一个 Repository，初始化工程代码结构，根据上线日期，比如20150730上线，开出分支 release20150730、dev20150730 两个分支，dev 分支作为日常开发主干分支，release 分支作为提测打包、Code Review 的分支。&lt;/li&gt;
&lt;li&gt;迭代开始，日常开发进行中，开发人员在 dev 分支上进行 Commit、Push 代码，并且解决掉日常协同开发中的冲突等问题，等到达到提测条件的时候，提测者，首先 Merge Master 分支上的最新代码 &lt;code&gt;git merge --no-ff  origin/master&lt;/code&gt; ，使得 Master 分支上的变更更新到迭代开发分支dev上面，之后，在 Gitlab 上面发起 &lt;code&gt;pull request&lt;/code&gt; 请求，并指定 Code Review 人，请求的分支选择本次上线的 release 分支，即 release20150730。&lt;/li&gt;
&lt;li&gt;被指定 Code Review 的人，对发起者的代码 Review 后，决定是否可以提交测试，若有问题，评论注释代码后，提交者对代码进行进行修改，重复步骤2，直到代码 Review 者认为 Ok。之后便可以借助自己公司的打包部署，对这些代码发布到测试环境验证。&lt;/li&gt;
&lt;li&gt;步骤2-3重复多次后，就会达到一个稳定可发布的版本，即上线版本，上线后，将 release 版本上面最后的提交（图中0.2.4上线对应处）合并到 Master 分支上面，并打 Tag0.3。至此，一次完整的迭代开发完成。&lt;/li&gt;
&lt;li&gt;若此次上线后，不久发现生产环境有 Bug 需要修复，则从 Tag 处新开分支 release_bugfix_20150731、dev_bugfix_20150731 ，开发人员从 dev_bugfix_20150731分支上进行开发，提测code review在 release_bugfix_20150731 分支上，具体步骤参考2-3，测试环境验证通过后，发布到线上，验证OK，合并到 Master 分支，并打 Tag0.2.3，此次 Bug 修复完毕，专为解 Bug 而生的这两个分支可以退伍了，删除release_bugfix_20150731、dev_bugfix_20150731两分支即可。（所有的历史 Commit 信息均已经提交到了 Master 分支上，不用担心丢失）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样经过上面的1-5步骤，企业日常迭代开发中的代码版本控制基本上就 Ok 了，有问题欢迎 Issue 讨论。&lt;/p&gt;
&lt;p&gt;2016-11月 更新 &lt;strong&gt;Git 分支开发部署模型&lt;/strong&gt; 的一些使用原则如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./_image/2016-09-22-20-57-27.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;master：master永远是线上代码，最稳定的分支，存放的是随时可供在生产环境中部署的代码，当开发活动告一段落，产生了一份新的可供部署的代码时，发布成功之后，代码才会由 aone2 提交到 master，master 分支上的代码会被更新。应用上 aone2 后禁掉所有人的 master的写权限&lt;/li&gt;
&lt;li&gt;develop：保存当前最新开发成果的分支。通常这个分支上的代码也是可进行每日夜间发布的代码，只对开发负责人开放develop权限。&lt;/li&gt;
&lt;li&gt;feature: 功能特性分支，每个功能特性一个 feature/ 分支，开发完成自测通过后合并入 develop 分支。可以从 master 或者develop 中拉出来。&lt;/li&gt;
&lt;li&gt;hotfix: 紧急bug分支修复分支。修复上线后，可以直接合并入master。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./_image/2016-07-19 19-58-15.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Git-Develop 分支模式是基于 Git 代码库设计的一种需要严格控制发布质量和发布节奏的开发模式。develop 作为固定的持续集成和发布分支，并且分支上的代码必须经过 CodeReview 后才可以提交到 Develop 分支。它的基本流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每一个需求/变更都单独从Master上创建一条Branch分支；&lt;/li&gt;
&lt;li&gt;用户在这个Branch分支上进行Codeing活动；&lt;/li&gt;
&lt;li&gt;代码达到发布准入条件后aone上提交Codereview，Codereview通过后代码自动合并到Develop分支；&lt;/li&gt;
&lt;li&gt;待所有计划发布的变更分支代码都合并到Develop后，系统再 rebase master 代码到Develop 分支，然后自行构建，打包，部署等动作。&lt;/li&gt;
&lt;li&gt;应用发布成功后Aone会基于Develop分支的发布版本打一个“当前线上版本Tag”基线；&lt;/li&gt;
&lt;li&gt;应用发布成功后Aone会自动把Develop分支的发布版本合并回master；&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;四、开发工作流的讨论&quot;&gt;&lt;a href=&quot;#四、开发工作流的讨论&quot; class=&quot;headerlink&quot; title=&quot;四、开发工作流的讨论&quot;&gt;&lt;/a&gt;四、开发工作流的讨论&lt;/h1&gt;&lt;p&gt;几篇业界的讨论文章 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://insights.thoughtworkers.org/gitflow-consider-harmful/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Gitflow 有害论&lt;/a&gt; 作者对 Gitflow 流程的使用过程中的吐槽，文章留言引起了强烈的讨论，可以关注下。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://scottchacon.com/2011/08/31/github-flow.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub Flow&lt;/a&gt; scottchacon 讲述在 GitHub 工作中日常流程以及对每一点进行详细的介绍。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/07/google-monolithic-source-repository.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;谷歌的代码管理&lt;/a&gt; 谷歌和 Facebook 都只有一个代码仓库，全公司的代码都放在这个库里，这里是阮一峰老师写的文章。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://cacm.acm.org/magazines/2016/7/204032-why-google-stores-billions-of-lines-of-code-in-a-single-repository/fulltext&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Why Google Stores Billions of Lines of Code in a Single Repository&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;说明：&quot;&gt;&lt;a href=&quot;#说明：&quot; class=&quot;headerlink&quot; title=&quot;说明：&quot;&gt;&lt;/a&gt;说明：&lt;/h1&gt;&lt;p&gt;个人在学习&lt;code&gt;Git&lt;/code&gt;工作流的过程中，从原有的 SVN 模式很难完全理解&lt;code&gt;Git&lt;/code&gt;的协作模
    
    </summary>
    
    
      <category term="git" scheme="http://mmrxia.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>You have not concluded your merge</title>
    <link href="http://mmrxia.github.io/2018/04/19/You-have-not-concluded-your-merge/"/>
    <id>http://mmrxia.github.io/2018/04/19/You-have-not-concluded-your-merge/</id>
    <published>2018-04-19T12:19:28.000Z</published>
    <updated>2018-04-19T12:32:40.388Z</updated>
    
    <content type="html">&lt;p&gt;我们在使用&lt;code&gt;git&lt;/code&gt;拉取远程服务器代码时，可能会遇到下面的报错信息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You have not concluded your merge (MERGE_HEAD exists).&lt;br&gt;  Please, commit your changes before you can merge.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;遇到上面的问题，先不要慌，我们来看一下&lt;code&gt;Git fetch&lt;/code&gt;和&lt;code&gt;git pull&lt;/code&gt;的异同:   &lt;/p&gt;
&lt;p&gt;相同点：都可以从远程获取最新版本到本地。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Git fetch&lt;/code&gt;:只是从远程获取最新版本到本地,不会&lt;code&gt;merge&lt;/code&gt;(合并)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;git&quot;&gt;git fetch origin master   //从远程的origin的master主分支上获取最新版本到origin/master分支上   
git log -p master..origin/master //比较本地的master分支和origin/master分支的区别   
git merge origin/master          //合并
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Git pull&lt;/code&gt;:从远程获取最新版本并&lt;code&gt;merge&lt;/code&gt;(合并)到本地&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;git&quot;&gt;git pull origin master  //相当于进行了 git fetch 和 git merge两部操作
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际工作中,可能git fetch更好一些, 因为在merge前,可以根据实际情况决定是否merge。&lt;br&gt;再说导致报错:&lt;code&gt;error: You have not concluded your merge (MERGE_HEAD exists)&lt;/code&gt;.&lt;br&gt;原因可能是在以前pull下来的代码自动合并失败。&lt;/p&gt;
&lt;p&gt;对于此我们有两种解决办法。&lt;br&gt;解决办法一:保留本地的更改,中止合并-&amp;gt;重新合并-&amp;gt;重新拉取  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;git&quot;&gt;git merge --abort
git reset --merge
git pull
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解决办法二:舍弃本地代码,远端版本覆盖本地版本(慎重)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;git&quot;&gt;git fetch --all
git reset --hard origin/master
git fetch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考链接: &lt;a href=&quot;http://stackoverflow.com/questions/11646107/you-have-not-concluded-your-merge-merge-head-exists&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stackoverflow&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我们在使用&lt;code&gt;git&lt;/code&gt;拉取远程服务器代码时，可能会遇到下面的报错信息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You have not concluded your merge (MERGE_HEAD exists).&lt;br&gt;  Please, com
    
    </summary>
    
    
      <category term="git" scheme="http://mmrxia.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>weex踩坑实践记录</title>
    <link href="http://mmrxia.github.io/2017/12/15/weex%E8%B8%A9%E5%9D%91%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/"/>
    <id>http://mmrxia.github.io/2017/12/15/weex踩坑实践记录/</id>
    <published>2017-12-15T02:45:44.000Z</published>
    <updated>2017-12-15T03:27:30.654Z</updated>
    
    <content type="html">&lt;h3 id=&quot;技术概述&quot;&gt;&lt;a href=&quot;#技术概述&quot; class=&quot;headerlink&quot; title=&quot;技术概述&quot;&gt;&lt;/a&gt;技术概述&lt;/h3&gt;&lt;p&gt;&lt;code&gt;weex&lt;/code&gt;是阿里开源的一套构建高性能移动界面的原生跨平台技术框架，它的上层由&lt;code&gt;Vue&lt;/code&gt;，&lt;code&gt;Rax&lt;/code&gt;（非常类似React的开发框架）实现数据驱动，底层由&lt;code&gt;iOS&lt;/code&gt;，&lt;code&gt;Android&lt;/code&gt;实现&lt;code&gt;render engine&lt;/code&gt;来驱动界面的最终落地。类比&lt;code&gt;React Native&lt;/code&gt;它的优势在于难得的一次编写，多端运行，是的，它也很好的支持着移动Web端。&lt;/p&gt;
&lt;h3 id=&quot;构建-build&quot;&gt;&lt;a href=&quot;#构建-build&quot; class=&quot;headerlink&quot; title=&quot;构建-build&quot;&gt;&lt;/a&gt;构建-build&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Native&lt;/code&gt;使用&lt;code&gt;weex-loader&lt;/code&gt;，&lt;code&gt;Web&lt;/code&gt;则需要使用&lt;code&gt;vue-loader&lt;/code&gt;，在Web端上&lt;code&gt;vue-loader&lt;/code&gt;目前仅支持&lt;code&gt;^11.3.3&lt;/code&gt;版本，以及&lt;code&gt;weex-vue-render&lt;/code&gt;需要&lt;code&gt;&amp;gt;= 0.11.50&lt;/code&gt;，并且&lt;code&gt;vue-loader&lt;/code&gt;的配置做如下修改：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;webpack 1.x&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;module: {
  loaders: [
    {
      test: /\.vue(\?[^?]+)?$/,
      loaders: [&amp;#39;vue-loader&amp;#39;]
    }
  ]
},
vue: {
  /**
   * important! should use postTransformNode to add $processStyle for
   * inline style normalization.
   */
  compilerModules: [
    {
      postTransformNode: el =&amp;gt; {
        el.staticStyle = `$processStyle(${el.staticStyle})`
        el.styleBinding = `$processStyle(${el.styleBinding})`
      }
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;webpack 2.x&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;module: {
    rules: [
      {
        test: /\.vue$/,
        loader: &amp;#39;vue-loader&amp;#39;,
        options: {
          compilerModules: [
            {
              postTransformNode: el =&amp;gt; {
                el.staticStyle = `$processStyle(${el.staticStyle})`
                el.styleBinding = `$processStyle(${el.styleBinding})`
              }
            }
          ]
        }
      }
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最佳的实践是推荐你使用目前为止我们内部评价最高的一份脚手架工程（支持三端一致，意味着处理了降级。）：&lt;a href=&quot;https://github.com/dingtalk-templates/webpack&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;dingtalk-templates/webpack&lt;/a&gt;，你可以直接下载它，自行修改&lt;code&gt;package.json&lt;/code&gt;文件中的配置，或者安装 &lt;a href=&quot;https://github.com/open-dingtalk/weex-dingtalk-cli&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;open-dingtalk/weex-dingtalk-cli&lt;/a&gt; 这个命令行工具来玩转脚手架，这个命令行工具就像你使用&lt;code&gt;vue-cli&lt;/code&gt;一样的简单：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ npm install -g weex-dingtalk-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;样式-style&quot;&gt;&lt;a href=&quot;#样式-style&quot; class=&quot;headerlink&quot; title=&quot;样式-style&quot;&gt;&lt;/a&gt;样式-style&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;weex&lt;/code&gt;支持的样式属于&lt;code&gt;css&lt;/code&gt;子集&lt;/li&gt;
&lt;li&gt;必须写完整，如&lt;code&gt;background:#000&lt;/code&gt;需要写成&lt;code&gt;background-color:#000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;样式不允许提取文件，必须写在&lt;code&gt;Vue&lt;/code&gt;的单组件中&lt;/li&gt;
&lt;li&gt;原则上不推荐使用预处理器，因为无法预期转译出来的样式符合&lt;code&gt;weex&lt;/code&gt;的&lt;code&gt;css&lt;/code&gt;子集&lt;/li&gt;
&lt;li&gt;布局只能使用&lt;code&gt;Flexbox&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果要显示文本必须使用&lt;code&gt;text&lt;/code&gt;组件，并且你想改变字体大小必须写在&lt;code&gt;text&lt;/code&gt;组件上&lt;/li&gt;
&lt;li&gt;只支持&lt;code&gt;class&lt;/code&gt;，不允许继承&lt;/li&gt;
&lt;li&gt;单位只支持&lt;code&gt;`px&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不支持背景图片&lt;/li&gt;
&lt;li&gt;基于&lt;code&gt;750px&lt;/code&gt;进行缩放，会有浮点级别的误差&lt;/li&gt;
&lt;li&gt;样式需要声明 &lt;code&gt;scoped&lt;/code&gt; 属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Android&lt;/code&gt;上处理圆角，必须在外层&lt;code&gt;div&lt;/code&gt;中设置&lt;code&gt;border-radius&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果你想动态的替换&lt;code&gt;class&lt;/code&gt;，只能使用数组表达式，&lt;code&gt;&amp;lt;div :class=[&amp;#39;name&amp;#39;, a? &amp;#39;b&amp;#39;: &amp;#39;c&amp;#39;]&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你想使用预处理器（只是不推荐），可以如下配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    test: /\.vue$/,
    loader: &amp;#39;vue-loader&amp;#39;,
    options: {
        loaders: {
          scss: &amp;#39;vue-style-loader!css-loader!sass-loader&amp;#39;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;style lang=&amp;quot;sass&amp;quot;&amp;gt;
    @import &amp;#39;./common.scss&amp;#39;
    // ...
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你想使用更精准的适配（无法忍受浮点级别的误差），可以获取&lt;code&gt;scale&lt;/code&gt;、&lt;code&gt;deviceWidth&lt;/code&gt;自行进行适配，推荐在loader阶段去处理（自行开发转换工具）。&lt;/p&gt;
&lt;h3 id=&quot;JavaScript与内存管理-JavaScript-and-memory-manage&quot;&gt;&lt;a href=&quot;#JavaScript与内存管理-JavaScript-and-memory-manage&quot; class=&quot;headerlink&quot; title=&quot;JavaScript与内存管理-JavaScript and memory manage&quot;&gt;&lt;/a&gt;JavaScript与内存管理-JavaScript and memory manage&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;由于JS运行在&lt;code&gt;JavaScriptCore/V8&lt;/code&gt;中，此与Web有较大差异。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;query&lt;/code&gt;，&lt;code&gt;axios&lt;/code&gt; 之类的原来Web开发领域的库都不可以使用&lt;/li&gt;
&lt;li&gt;不支持DOM操作&lt;/li&gt;
&lt;li&gt;虽然提供了&lt;code&gt;Native DOM&lt;/code&gt;可以操作界面的渲染，原则上不推荐使用，方法与DOM操作类似&lt;/li&gt;
&lt;li&gt;既然不支持DOM操作，更改界面的方式应该使用数据驱动&lt;/li&gt;
&lt;li&gt;仅支持部分事件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;weex SDK &amp;gt;= 0.10.0&lt;/code&gt; 的才支持事件冒泡&lt;/li&gt;
&lt;li&gt;没有&lt;code&gt;window&lt;/code&gt;，&lt;code&gt;document&lt;/code&gt;，&lt;code&gt;location&lt;/code&gt;，&lt;code&gt;history&lt;/code&gt;等对象&lt;/li&gt;
&lt;li&gt;runtime是一个“全局环境”，不允许往全局环境中挂载对象，因为无法释放且所有&lt;code&gt;weex&lt;/code&gt;页面共享&lt;/li&gt;
&lt;li&gt;只有&lt;code&gt;scroller&lt;/code&gt;和&lt;code&gt;list&lt;/code&gt;组件可以滚动&lt;/li&gt;
&lt;li&gt;不允许在&lt;code&gt;Vue&lt;/code&gt;中操作&lt;code&gt;style&lt;/code&gt;，遍历是很耗性能的&lt;/li&gt;
&lt;li&gt;Vue中的&lt;code&gt;v-show&lt;/code&gt;等原来操作Dom的指令或Api都不可以使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vue-router&lt;/code&gt; 只允许使用 &lt;code&gt;abstract&lt;/code&gt; 模式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vuex&lt;/code&gt;必须在初始化之前使用&lt;code&gt;Vue.use&lt;/code&gt;注入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;native&lt;/code&gt;端只能使用网络图片，解决的方式是在最后上线时统一替换成&lt;code&gt;CDN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;热更新以及增量更新的方式都可以参考&lt;code&gt;React Native&lt;/code&gt;目前成熟的方案&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;iOS由于使用了同一套&lt;code&gt;URL System&lt;/code&gt;，&lt;code&gt;UIWebView&lt;/code&gt;的&lt;code&gt;cookie&lt;/code&gt;是会共享到&lt;code&gt;weex&lt;/code&gt;中的，同理&lt;code&gt;weex&lt;/code&gt;中的&lt;code&gt;cookie&lt;/code&gt;也是会共享的，只有&lt;code&gt;WKWebView&lt;/code&gt;不会。原则上，你不应该使用&lt;code&gt;cookie&lt;/code&gt;来处理用户体系的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;weex native 与 weex web 之间的差异较大，那么怎么办？   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们提供了一套抹平一些常见差异的库，你也可以在weex环境中使用，&lt;a href=&quot;https://github.com/open-dingtalk/weex-dingtalk-journey&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/open-dingtalk/weex-dingtalk-journey&lt;/a&gt;。   &lt;/p&gt;
&lt;p&gt;在说内存（memory）之前，大家先来看一副图，weex的内存分布：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://segmentfault.com/img/remote/1460000010023505?w=916&amp;amp;h=958&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;正常情况下，&lt;code&gt;Native memory&lt;/code&gt; 业务开发人员是无法处理的，而运行在&lt;code&gt;js core&lt;/code&gt; 中的内存，我们知道如果不断开引用，js是无法回收释放内存的。   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不允许往 runtime 里去挂载对象&lt;/li&gt;
&lt;li&gt;业务代码中的一些引用在beforeDestroy 中断开设置为null&lt;/li&gt;
&lt;li&gt;学会使用工具分析内存泄漏的问题，&lt;a href=&quot;https://webkit.org/downloads/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://webkit.org/downloads/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;不要随意的使用函数递归，缩短对象方法的执行路径（传统JS领域的内存管理最佳实践也适用一部分）&lt;/li&gt;
&lt;li&gt;由于界面的渲染需要依赖createInstance(id, code, config, data)，sendTasks(id, tasks)，receiveTasks(id, tasks)发送指令的方式进行通信，你应该减少通信的次数，在更新界面时，合并不必要的通信指令的发送。&lt;/li&gt;
&lt;li&gt;如果你使用vue-router的方式，尽量减少组件之间的共享。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;转场方式-navigator&quot;&gt;&lt;a href=&quot;#转场方式-navigator&quot; class=&quot;headerlink&quot; title=&quot;转场方式-navigator&quot;&gt;&lt;/a&gt;转场方式-navigator&lt;/h3&gt;&lt;p&gt;由于weex的特殊性，它的转场方式有几种构成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;weex to weex&lt;/code&gt;，如果你需要支持钉钉&lt;code&gt;js-api&lt;/code&gt;，那么你应该使用&lt;code&gt;openLink&lt;/code&gt;。（如果是你自己实现，使用weex自带的navigator模块）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;weex to h5&lt;/code&gt; 依然使用&lt;code&gt;openLink&lt;/code&gt;，（如果是你自己实现，那么可以通过&lt;code&gt;module&lt;/code&gt;的方式来打开一个&lt;code&gt;WebViewController| UIWebView or WKWebView&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;native to weex&lt;/code&gt; 直接&lt;code&gt;alloc weex&lt;/code&gt; 容器的&lt;code&gt;Controller&lt;/code&gt;传入&lt;code&gt;Url&lt;/code&gt;即可&lt;br&gt;如果你使用&lt;code&gt;vue-router&lt;/code&gt;，那么配置好你的路由&lt;code&gt;path&lt;/code&gt;，使用&lt;code&gt;push&lt;/code&gt;，&lt;code&gt;go&lt;/code&gt;方法即可，唯一可惜的是使用&lt;code&gt;vue-router&lt;/code&gt;的方式较为生硬。   &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;页面级别的数据传输-Page-level-data-transfer&quot;&gt;&lt;a href=&quot;#页面级别的数据传输-Page-level-data-transfer&quot; class=&quot;headerlink&quot; title=&quot;页面级别的数据传输-Page level data transfer&quot;&gt;&lt;/a&gt;页面级别的数据传输-Page level data transfer&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;页面级别的数据传输基本很少会发生，钉钉的开发者推荐统一使用domainStorage方案。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;weex to weex&lt;/code&gt; 通过URL传参数（携带的数据量有限），通过&lt;code&gt;weex storage module&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;weex to h5&lt;/code&gt;，&lt;code&gt;h5 to weex&lt;/code&gt; 通过URL传参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;native to weex&lt;/code&gt; 通过&lt;code&gt;alloc weex&lt;/code&gt; 容器中的&lt;code&gt;option&lt;/code&gt;或者&lt;code&gt;data&lt;/code&gt;传入，前者可以在&lt;code&gt;weex.config&lt;/code&gt;中获取，后者可以在vm上下文中获取&lt;/li&gt;
&lt;li&gt;&lt;code&gt;weex to native&lt;/code&gt; 定义一个跳转&lt;code&gt;native&lt;/code&gt;的&lt;code&gt;module&lt;/code&gt;，使用&lt;code&gt;native&lt;/code&gt;的属性或者&lt;code&gt;init&lt;/code&gt;时传入&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;调试工具-Debug-Kit-used&quot;&gt;&lt;a href=&quot;#调试工具-Debug-Kit-used&quot; class=&quot;headerlink&quot; title=&quot;调试工具-Debug Kit used&quot;&gt;&lt;/a&gt;调试工具-Debug Kit used&lt;/h3&gt;&lt;p&gt;weex的调试工具需要额外安装weex-toolkit，weex-devtool，以及在你的Native工程中集成对应的WXDevtool（iOS）。    &lt;/p&gt;
&lt;p&gt;如果你运行weex debug遇到如下的错误：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;Error: EACCES: permission denied, open &amp;#39;/Users/xxx/.xtoolkit/node_modules/weex-devtool/frontend/weex/weex-bundle.js&amp;#39;
    at Error (native)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（非Windows用户）使用sudo即可。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不集成 &lt;code&gt;WXDevtool SDK&lt;/code&gt;&lt;br&gt;首先，你需要安装&lt;code&gt;Weex Playground&lt;/code&gt;，可自行在各大市场中下载安装。   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不需要指明文件路径，在终端输入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ weex debug
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先使用 &lt;code&gt;Weex Playground&lt;/code&gt; 扫码（启动成功后会弹出一个界面），然后将你的业务代码贴到 这里，注意：   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不允许出现&lt;code&gt;import&lt;/code&gt;等导入模块的语法&lt;/li&gt;
&lt;li&gt;安装了&lt;code&gt;Weex Playground&lt;/code&gt;的设备和你的电脑必须在同一局域网内&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后用安装了&lt;code&gt;Weex Playground&lt;/code&gt;的设备扫码（业务代码贴过去那里的右侧会出现的二维码）。   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集成 &lt;code&gt;WXDevtool SDK&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;[WXDevTool setDebug:YES];
[WXDevTool launchDevToolDebugWithUrl:@&amp;quot;ws://192.168.1.108:8088/debugProxy/native&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;ws:// xxx.xx..x&lt;/code&gt; 这个地址是在用&lt;code&gt;weex debug&lt;/code&gt; 在终端里给你输出出来的，如果&lt;code&gt;setDebug&lt;/code&gt;为&lt;code&gt;YES&lt;/code&gt;会开启&lt;code&gt;debugger&lt;/code&gt;模式，反之亦然。   &lt;/p&gt;
&lt;p&gt;注意&lt;code&gt;setDebug&lt;/code&gt;设置为&lt;code&gt;YES&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;原生开发-Native&quot;&gt;&lt;a href=&quot;#原生开发-Native&quot; class=&quot;headerlink&quot; title=&quot;原生开发-Native&quot;&gt;&lt;/a&gt;原生开发-Native&lt;/h3&gt;&lt;p&gt;请直接阅读 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/25182677&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Weex入坑之旅&lt;/a&gt; ，这是用&lt;code&gt;iOS&lt;/code&gt;视角写的一篇文章，大概在半年之前。&lt;/p&gt;
&lt;h3 id=&quot;写在最后&quot;&gt;&lt;a href=&quot;#写在最后&quot; class=&quot;headerlink&quot; title=&quot;写在最后&quot;&gt;&lt;/a&gt;写在最后&lt;/h3&gt;&lt;p&gt;希望大家可以用一个开放的心态来看待&lt;code&gt;weex&lt;/code&gt;，它的设计，实现有很多是值得学习的地方，&lt;br&gt;比如多&lt;code&gt;framework&lt;/code&gt;支持，共享&lt;code&gt;runtime&lt;/code&gt;，&lt;code&gt;module&lt;/code&gt;，&lt;code&gt;component&lt;/code&gt;，&lt;code&gt;handler&lt;/code&gt;等等，非常的自由领域，相当于它设计好了一个&lt;code&gt;render engine&lt;/code&gt;。&lt;br&gt;理论上你可以学习它的几个关键接口，知道&lt;code&gt;Native DOM&lt;/code&gt;指令后，也能开发出替代&lt;code&gt;Vue&lt;/code&gt;的上层框架，不信？你看看Rax即明白了。   &lt;/p&gt;
&lt;p&gt;&lt;code&gt;weex&lt;/code&gt;也有一些不足的地方，开发者数量少，社区活跃度不高，很多问题并不一定能被&lt;code&gt;google&lt;/code&gt;搜录到。&lt;br&gt;文档确实有一点不完善，&lt;code&gt;native&lt;/code&gt;的实现也有一定的&lt;code&gt;bug&lt;/code&gt;数量，你看&lt;code&gt;react&lt;/code&gt;这么多年了，依然有&lt;code&gt;bug&lt;/code&gt;，只要在逐步改进迭代修复，我觉得它就是非常棒的，万事没有十全十美，美中不足的一点瑕疵，说不定才是完美呢。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;技术概述&quot;&gt;&lt;a href=&quot;#技术概述&quot; class=&quot;headerlink&quot; title=&quot;技术概述&quot;&gt;&lt;/a&gt;技术概述&lt;/h3&gt;&lt;p&gt;&lt;code&gt;weex&lt;/code&gt;是阿里开源的一套构建高性能移动界面的原生跨平台技术框架，它的上层由&lt;code&gt;Vue&lt;/c
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>localhost配置mongodb主从</title>
    <link href="http://mmrxia.github.io/2017/03/01/localhost%E9%85%8D%E7%BD%AEmongodb%E4%B8%BB%E4%BB%8E/"/>
    <id>http://mmrxia.github.io/2017/03/01/localhost配置mongodb主从/</id>
    <published>2017-03-01T03:40:38.000Z</published>
    <updated>2017-03-02T03:18:10.709Z</updated>
    
    <content type="html">&lt;h4 id=&quot;一、mongodb安装配置&quot;&gt;&lt;a href=&quot;#一、mongodb安装配置&quot; class=&quot;headerlink&quot; title=&quot;一、mongodb安装配置&quot;&gt;&lt;/a&gt;一、mongodb安装配置&lt;/h4&gt;&lt;p&gt;这部分可参考博文 &lt;a href=&quot;http://blog.xiaqingsong.com/2016/12/16/windows%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmongodb/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;windows下安装配置mongodb&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;二、-主从配置&quot;&gt;&lt;a href=&quot;#二、-主从配置&quot; class=&quot;headerlink&quot; title=&quot;二、 主从配置&quot;&gt;&lt;/a&gt;二、 主从配置&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;在生产环境中单台数据库一般不能满足业务稳定性的需求，所以数据库主从复制架构在生产环境中很常见，用于主从复制也是Mongodb最常用的一种架构方式。&lt;br&gt;这种方式非常灵活，可用于备份、故障恢复、读扩展等,从而提高数据处理性能和冗余，常用架构模式是一主一从、一主多从、双主。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本着实验目的，我们今天简单实现一主一从的配置。&lt;/p&gt;
&lt;p&gt;注：主从服务器我们指定端口分别为 &lt;code&gt;27017&lt;/code&gt; 和 &lt;code&gt;27019&lt;/code&gt;。  &lt;/p&gt;
&lt;p&gt;根目录下我们分别新建&lt;code&gt;mongodb.cfg&lt;/code&gt;和&lt;code&gt;mongodb.slave.cfg&lt;/code&gt;主从启动配置文件，详细配置如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;master&lt;/strong&gt;(mongodb.cfg): &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;dbpath=D:\mongodb\data\db\master #规定数据库的位置
logpath=D:\mongodb\data\log\master\mongodb.log #规定数据库的日志文件

port=27017 #指定端口
#fork=true #后台运行

master=true #设置主

# bind_ip=127.0.0.1,192.168.0.4 #允许的地址 为了安全
nohttpinterface=true #禁止http访问
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;slave&lt;/strong&gt;(mongodb.slave.cfg): &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;dbpath=D:\mongodb\data\db\slave #规定数据库的位置
logpath=D:\mongodb\data\log\slave\mongodb.log #规定数据库的日志文件

port=27019 #指定端口
#fork=true #后台运行

slave=true #声明从
source=127.0.0.1:27017 #规定从属于哪个ip  注意：ip是主服务器的  最好用内网ip

# bind_ip=127.0.0.1,192.168.0.4 #允许的地址 为了安全
nohttpinterface=true #禁止http访问
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;三、启动&quot;&gt;&lt;a href=&quot;#三、启动&quot; class=&quot;headerlink&quot; title=&quot;三、启动&quot;&gt;&lt;/a&gt;三、启动&lt;/h4&gt;&lt;p&gt;进入&lt;code&gt;bin&lt;/code&gt;目录，执行下面步骤：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;mongod -f ../mongodb.cfg  #启动主服务器
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从服务器启动，同理如上：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;mongod -f ../mongodb.slave.cfg  #启动从服务器
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动完成后，我们分别另起一个窗口，进入数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mongo --host localhost --port 27017  #进入主数据库 
mongo --host localhost --port 27019  #进入主数据库
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后，我们在从服务器执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rs.slaveOk();
show dbs;  #如果出现主数据库的数据，说明同步成功
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;详细执行效果，可参考下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xth8v.com2.z0.glb.qiniucdn.com/image/n_mongodb%20master_and_slave_test.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、mongodb安装配置&quot;&gt;&lt;a href=&quot;#一、mongodb安装配置&quot; class=&quot;headerlink&quot; title=&quot;一、mongodb安装配置&quot;&gt;&lt;/a&gt;一、mongodb安装配置&lt;/h4&gt;&lt;p&gt;这部分可参考博文 &lt;a href=&quot;http://b
    
    </summary>
    
    
      <category term="mongodb" scheme="http://mmrxia.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>vue学习笔记</title>
    <link href="http://mmrxia.github.io/2016/12/26/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://mmrxia.github.io/2016/12/26/vue学习笔记/</id>
    <published>2016-12-26T11:57:33.000Z</published>
    <updated>2016-12-26T12:21:23.027Z</updated>
    
    <content type="html">&lt;ul&gt;
&lt;li&gt;来自vue官方示例：&lt;a href=&quot;https://github.com/vuejs/vue-loader-example&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/vuejs/vue-loader-example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;使用vuejs和webpack，以及一系列webpack加载器，如vue-loader&lt;/li&gt;
&lt;li&gt;简单记录下具体的做法，供新手参考。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;- demo/
  + package.json //npm配置文件
  + webpack.config.js //webpack配置
  + index.html //页面
  - node_modules //npm加载的模块
  - src //开发资源目录
    - assets //一些资源
      + logo.png  //图片资源
    - components //vue组件
      + a.vue 
      + b.vue
      + counter.vue
    + app.vue //布局文件
    + main.js  //入口文件
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;初始化npm&quot;&gt;&lt;a href=&quot;#初始化npm&quot; class=&quot;headerlink&quot; title=&quot;初始化npm&quot;&gt;&lt;/a&gt;初始化npm&lt;/h2&gt;&lt;p&gt;1.生成npm配置文件 package.json&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm init
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.可以粘贴如下配置内容替换到package.json中，或者根据变动进行修改&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;demo_vue-loader-example&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;0.0.1&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;demo&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;index.js&amp;quot;,
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;dev&amp;quot;: &amp;quot;webpack-dev-server --inline --hot --quiet&amp;quot;, 
    &amp;quot;build&amp;quot;: &amp;quot;export NODE_ENV=production &amp;amp;&amp;amp; webpack --progress --hide-modules&amp;quot;
  },
  &amp;quot;author&amp;quot;: &amp;quot;dingyiming&amp;quot;,
  &amp;quot;license&amp;quot;: &amp;quot;MIT&amp;quot;,
  &amp;quot;devDependencies&amp;quot;: {
    &amp;quot;babel-core&amp;quot;: &amp;quot;^6.2.1&amp;quot;,
    &amp;quot;babel-loader&amp;quot;: &amp;quot;^6.2.0&amp;quot;,
    &amp;quot;babel-plugin-transform-runtime&amp;quot;: &amp;quot;^6.1.18&amp;quot;,
    &amp;quot;babel-preset-es2015&amp;quot;: &amp;quot;^6.1.18&amp;quot;,
    &amp;quot;babel-preset-stage-0&amp;quot;: &amp;quot;^6.1.18&amp;quot;,
    &amp;quot;babel-runtime&amp;quot;: &amp;quot;^6.2.0&amp;quot;,

    &amp;quot;css-loader&amp;quot;: &amp;quot;^0.23.0&amp;quot;,
    &amp;quot;node-sass&amp;quot;: &amp;quot;^3.4.2&amp;quot;,
    &amp;quot;sass-loader&amp;quot;: &amp;quot;^3.1.2&amp;quot;,
    &amp;quot;style-loader&amp;quot;: &amp;quot;^0.13.0&amp;quot;,
    &amp;quot;stylus-loader&amp;quot;: &amp;quot;^1.4.2&amp;quot;,

    &amp;quot;file-loader&amp;quot;: &amp;quot;^0.8.5&amp;quot;,
    &amp;quot;jade&amp;quot;: &amp;quot;^1.11.0&amp;quot;,
    &amp;quot;template-html-loader&amp;quot;: &amp;quot;0.0.3&amp;quot;,

    &amp;quot;vue-hot-reload-api&amp;quot;: &amp;quot;^1.2.1&amp;quot;,
    &amp;quot;vue-html-loader&amp;quot;: &amp;quot;^1.0.0&amp;quot;,
    &amp;quot;vue-loader&amp;quot;: &amp;quot;^7.1.4&amp;quot;,

    &amp;quot;webpack&amp;quot;: &amp;quot;^1.12.9&amp;quot;,
    &amp;quot;webpack-dev-server&amp;quot;: &amp;quot;^1.14.0&amp;quot;
  },
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;vue&amp;quot;: &amp;quot;^1.0.10&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.下载node模块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;也可以手动安装某个包，并写入到&lt;code&gt;package.json&lt;/code&gt;文字的依赖中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;–save-dev 把依赖名和版本要求放在了 “devDependencies”:{}，&lt;/li&gt;
&lt;li&gt;–save 放在了 “dependencies”:{}&lt;br&gt;每敲一个下载完后可以看到 “devDependencies”:{}依赖内容的添加&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;新建index-html用于展示最终页面&quot;&gt;&lt;a href=&quot;#新建index-html用于展示最终页面&quot; class=&quot;headerlink&quot; title=&quot;新建index.html用于展示最终页面&quot;&gt;&lt;/a&gt;新建index.html用于展示最终页面&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Vue Webpack Example&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;app&amp;gt;&amp;lt;/app&amp;gt;
&amp;lt;script src=&amp;quot;dist/build.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;新建webpack-config-js用于配置webpack&quot;&gt;&lt;a href=&quot;#新建webpack-config-js用于配置webpack&quot; class=&quot;headerlink&quot; title=&quot;新建webpack.config.js用于配置webpack&quot;&gt;&lt;/a&gt;新建webpack.config.js用于配置webpack&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var webpack = require(&amp;#39;webpack&amp;#39;)

module.exports = {
  entry: &amp;#39;./src/main.js&amp;#39;,
  output: {
    path: &amp;#39;./dist&amp;#39;,
    publicPath: &amp;#39;dist/&amp;#39;,
    filename: &amp;#39;build.js&amp;#39;
  },
  module: {
    loaders: [
      {
        test: /\.vue$/,
        loader: &amp;#39;vue&amp;#39;
      },
      {
        // edit this for additional asset file types
        test: /\.(png|jpg|gif)$/,
        loader: &amp;#39;file?name=[name].[ext]?[hash]&amp;#39;
      }
    ]
  },
  // example: if you wish to apply custom babel options
  // instead of using vue-loader&amp;#39;s default:
  babel: {
    presets: [&amp;#39;es2015&amp;#39;, &amp;#39;stage-0&amp;#39;],
    plugins: [&amp;#39;transform-runtime&amp;#39;]
  }
}

if (process.env.NODE_ENV === &amp;#39;production&amp;#39;) {
  module.exports.plugins = [
    new webpack.DefinePlugin({
      &amp;#39;process.env&amp;#39;: {
        NODE_ENV: &amp;#39;&amp;quot;production&amp;quot;&amp;#39;
      }
    }),
    new webpack.optimize.UglifyJsPlugin({
      compress: {
        warnings: false
      }
    }),
    new webpack.optimize.OccurenceOrderPlugin()
  ]
} else {
  module.exports.devtool = &amp;#39;#source-map&amp;#39;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;新建src目录用于存放开发文件&quot;&gt;&lt;a href=&quot;#新建src目录用于存放开发文件&quot; class=&quot;headerlink&quot; title=&quot;新建src目录用于存放开发文件&quot;&gt;&lt;/a&gt;新建src目录用于存放开发文件&lt;/h2&gt;&lt;h4 id=&quot;新建入口文件main-js&quot;&gt;&lt;a href=&quot;#新建入口文件main-js&quot; class=&quot;headerlink&quot; title=&quot;新建入口文件main.js&quot;&gt;&lt;/a&gt;新建入口文件main.js&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var Vue = require(&amp;#39;vue&amp;#39;)
var App = require(&amp;#39;./app.vue&amp;#39;)

new Vue({
  el: &amp;#39;body&amp;#39;,
  components: {
    app: App
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;新建组件布局文件app-vue&quot;&gt;&lt;a href=&quot;#新建组件布局文件app-vue&quot; class=&quot;headerlink&quot; title=&quot;新建组件布局文件app.vue&quot;&gt;&lt;/a&gt;新建组件布局文件&lt;code&gt;app.vue&lt;/code&gt;&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;组件布局将在这里设置，.vue文件将由vue-loader进行加载，.vue内同时包含html、css、js源码，使组件的独立，组件之间可以尽可能地解耦，便于开发维护&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template lang=&amp;quot;jade&amp;quot;&amp;gt;
div
  img(class=&amp;quot;logo&amp;quot;, src=&amp;quot;./assets/logo.png&amp;quot;)
  h1 {{msg}}
  comp-a
  comp-b
  counter
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import CompA from &amp;#39;./components/a.vue&amp;#39;
import CompB from &amp;#39;./components/b.vue&amp;#39;
import Counter from &amp;#39;./components/counter.vue&amp;#39;
export default {
  data () {
    return {
      msg: &amp;#39;Hello from vue-loader!&amp;#39;
    }
  },
  components: {
    CompA,
    CompB,
    Counter
  }
}
&amp;lt;/script&amp;gt;

&amp;lt;style lang=&amp;quot;stylus&amp;quot;&amp;gt;
font-stack = Helvetica, sans-serif
primary-color = #999
body
  font 100% font-stack
  color primary-color
.logo
  width 40px
  height 40px
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;新建components文件夹&quot;&gt;&lt;a href=&quot;#新建components文件夹&quot; class=&quot;headerlink&quot; title=&quot;新建components文件夹&quot;&gt;&lt;/a&gt;新建components文件夹&lt;/h4&gt;&lt;p&gt;用于开发具体的子组件，均以.vue的后缀呈现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a.vue&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;style scoped&amp;gt;
.container {
  border: 1px solid #00f;
}
.red {
  color: #f00;
}
&amp;lt;/style&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;h2 class=&amp;quot;red&amp;quot;&amp;gt;{{msg}}&amp;lt;/h2&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
  data () {
    return {
      msg: &amp;#39;Hello from Component A!&amp;#39;
    }
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;b.vue&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;style scoped&amp;gt;
.container {
  border: 1px solid #f00;
}
h2 {
  color: #393;
}
&amp;lt;/style&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;h2&amp;gt;Hello from Component B!&amp;lt;/h2&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;counter.vue&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;h1&amp;gt;I am a Counter Component. Edit me in dev mode.&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;Current count: {{count}}&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
  data () {
    return { count: 0 }
  },
  ready () {
    this.handle = setInterval(() =&amp;gt; {
      this.count++
    }, 1000)
  },
  destroyed () {
    clearInterval(this.handle)
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;新建assets文件夹用于放一些资源&quot;&gt;&lt;a href=&quot;#新建assets文件夹用于放一些资源&quot; class=&quot;headerlink&quot; title=&quot;新建assets文件夹用于放一些资源&quot;&gt;&lt;/a&gt;新建assets文件夹用于放一些资源&lt;/h4&gt;&lt;p&gt;此项目下有一张图 logo.png&lt;/p&gt;
&lt;h4 id=&quot;打包运行查看&quot;&gt;&lt;a href=&quot;#打包运行查看&quot; class=&quot;headerlink&quot; title=&quot;打包运行查看&quot;&gt;&lt;/a&gt;打包运行查看&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;打包运行查看&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;npm run build
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;运行&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;npm run dev
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;查看&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;浏览器中访问 localhost:8080&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;来自vue官方示例：&lt;a href=&quot;https://github.com/vuejs/vue-loader-example&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/vuejs/vue-loader-
    
    </summary>
    
    
      <category term="vue" scheme="http://mmrxia.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>javascript类型判断</title>
    <link href="http://mmrxia.github.io/2016/12/22/javascript%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
    <id>http://mmrxia.github.io/2016/12/22/javascript类型判断/</id>
    <published>2016-12-22T09:50:03.000Z</published>
    <updated>2016-12-22T10:03:06.841Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;JavaScript 中所有变量都是对象，除了两个例外 null 和 undefined。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;理解Javascript的类型是学习Javascript的基础，但是作为新手很容易在判断Javascript上容易混淆。很容易被上面这句话误导，首先解释下上面这句话。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;false.toString(); // &amp;#39;false&amp;#39;
[1, 2, 3].toString(); // &amp;#39;1,2,3&amp;#39;
(2).toString(); // &amp;#39;2&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过上面的代码，可以看出布尔、数组、数字都具有&lt;code&gt;toString()&lt;/code&gt;这一方法，其实除了&lt;code&gt;null&lt;/code&gt;和&lt;code&gt;undefined&lt;/code&gt;外的数据类型都继承自&lt;code&gt;Object&lt;/code&gt;对象都具&lt;code&gt;Object&lt;/code&gt;的方法和属性，这些看似非对象的类型使用起来却很像对象，所以也可以说它们都是对象。&lt;br&gt;可是Javascript依然具有类型，大致可以分成下面几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Number&lt;/li&gt;
&lt;li&gt;String&lt;/li&gt;
&lt;li&gt;Boolean&lt;/li&gt;
&lt;li&gt;Object&lt;/li&gt;
&lt;li&gt;Null&lt;/li&gt;
&lt;li&gt;Undefined&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Number&lt;/code&gt;、&lt;code&gt;String&lt;/code&gt;、&lt;code&gt;Boolean&lt;/code&gt;、&lt;code&gt;Null&lt;/code&gt;、&lt;code&gt;Undefined&lt;/code&gt;都是是基本数据类型，只有&lt;code&gt;Object&lt;/code&gt;属于复杂数据类型。&lt;br&gt;&lt;code&gt;Null&lt;/code&gt;和&lt;code&gt;Undefined&lt;/code&gt;都表示空，它们的区别在于：&lt;code&gt;Null&lt;/code&gt;表示无值，一般是人为的将变量的值设置为&lt;code&gt;null&lt;/code&gt;；&lt;code&gt;Undefined&lt;/code&gt;表示未知值，一般在使用&lt;code&gt;var&lt;/code&gt;声明变量但未对其加以初始化时，这个变量值为&lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Object&lt;/code&gt;又分为以下几种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function&lt;/li&gt;
&lt;li&gt;Array&lt;/li&gt;
&lt;li&gt;Date&lt;/li&gt;
&lt;li&gt;RegExp&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;typeof操作符&quot;&gt;&lt;a href=&quot;#typeof操作符&quot; class=&quot;headerlink&quot; title=&quot;typeof操作符&quot;&gt;&lt;/a&gt;typeof操作符&lt;/h4&gt;&lt;p&gt;&lt;code&gt;typeof&lt;/code&gt;操作符（和&lt;code&gt;instanceof&lt;/code&gt;一起）或许是 JavaScript 中最大的设计缺陷， 因为几乎不可能从它们那里得到想要的结果。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;typeof []; // object
typeof {}; // object
typeof &amp;#39;&amp;#39;; // string
typeof new Date() // object
typeof 1; // number
typeof function () {}; // function
typeof /test/i; // object
typeof true; // boolean
typeof null; // object
typeof undefined; // undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为什么？&lt;code&gt;function&lt;/code&gt;明明是&lt;code&gt;Object&lt;/code&gt;类型，却显示&lt;code&gt;function&lt;/code&gt;；&lt;code&gt;null&lt;/code&gt;明明是&lt;code&gt;Null&lt;/code&gt;类型，却显示&lt;code&gt;object&lt;/code&gt;。所以&lt;code&gt;typeof&lt;/code&gt;操作符对类型的判断是不靠谱的，除非类型在给定的范围且&lt;code&gt;typeof&lt;/code&gt;确实能够区分这些类型。&lt;/p&gt;
&lt;h4 id=&quot;类型的区分&quot;&gt;&lt;a href=&quot;#类型的区分&quot; class=&quot;headerlink&quot; title=&quot;类型的区分&quot;&gt;&lt;/a&gt;类型的区分&lt;/h4&gt;&lt;p&gt;Javascript标准标准文档给出了区分类型的办法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;Object.prototype.toString.call();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们来看看上面的方法输出结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;Object.prototype.toString.call([]); // [object Array]
Object.prototype.toString.call({}); // [object Object]
Object.prototype.toString.call(&amp;#39;&amp;#39;); // [object String]
Object.prototype.toString.call(new Date()); // [object Date]
Object.prototype.toString.call(1); // [object Number]
Object.prototype.toString.call(function () {}); // [object Function]
Object.prototype.toString.call(/test/i); // [object RegExp]
Object.prototype.toString.call(true); // [object Boolean]
Object.prototype.toString.call(null); // [object Null]
Object.prototype.toString.call(); // [object Undefined]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用上面判断类型的方法可以写个类库，此类库来自&lt;a href=&quot;//github.com/toddmotto/axis&quot;&gt;Axis.js&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;(function (root, factory) {
  // 判断是否使用了模块
  if (typeof define === &amp;#39;function&amp;#39; &amp;amp;&amp;amp; define.amd) {
    // 使用AMD模块
    define(factory);
  } else if (typeof exports === &amp;#39;object&amp;#39;) {
    // 使用CMD模块
    module.exports = factory;
  } else {
    // 没有使用模块，放在全局下
    root.axis = factory();
  }
})(this, function () {
  // 严格模式
  &amp;#39;use strict&amp;#39;;
  var exports = {};
  // 将字符串转为数组
  var types = &amp;#39;Array Object String Date RegExp Function Boolean Number Null Undefined&amp;#39;.split(&amp;#39; &amp;#39;);
  // 判断类型
  var type = function () {
    return Object.prototype.toString.call(this).slice(8, -1);
  };
  // 遍历types，为exports对象添加isArray、isObject...等方法
  for (var i = types.length; i--;) {
    exports[&amp;#39;is&amp;#39; + types[i]] = (function (self) {
      return function (elem) {
        // type.call(elem)将type方法里的this指针指向elem
        return type.call(elem) === self;
      };
    })(types[i]);
  }
  return exports;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用方法也很简单：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;axis.isArray([]); // true
axis.isObject({}); // true
axis.isString(&amp;#39;&amp;#39;); // true
axis.isDate(new Date()); // true
axis.isRegExp(/test/i); // true
axis.isFunction(function () {}); // true
axis.isBoolean(true); // true
axis.isNumber(1); // true
axis.isNull(null); // true
axis.isUndefined(); // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://toddmotto.com/understanding-javascript-types-and-reliable-type-checking/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://toddmotto.com/understanding-javascript-types-and-reliable-type-checking/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bonsaiden.github.io/JavaScript-Garden/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://bonsaiden.github.io/JavaScript-Garden/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;JavaScript 中所有变量都是对象，除了两个例外 null 和 undefined。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;理解Javascript的类型是学习Javascript的基础，但是作为新手很容易在判断Javascript上容易
    
    </summary>
    
    
      <category term="javascript" scheme="http://mmrxia.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>只用20行写一个javascript模板引擎</title>
    <link href="http://mmrxia.github.io/2016/12/22/%E5%8F%AA%E7%94%A820%E8%A1%8C%E5%86%99%E4%B8%80%E4%B8%AAjavascript%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    <id>http://mmrxia.github.io/2016/12/22/只用20行写一个javascript模板引擎/</id>
    <published>2016-12-22T07:18:12.000Z</published>
    <updated>2016-12-22T07:41:18.728Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;译文链接：&lt;a href=&quot;原文链接：JavaScript template engine in just 20 lines&quot;&gt;JavaScript template engine in just 20 lines&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最初我的想法是这样子的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var TemplateEngine = function(tpl, data) {
    // magic here ...
}
var template = &amp;#39;&amp;lt;p&amp;gt;Hello, my name is &amp;lt;%name%&amp;gt;. I\&amp;#39;m &amp;lt;%age%&amp;gt; years old.&amp;lt;/p&amp;gt;&amp;#39;;
console.log(TemplateEngine(template, {
    name: &amp;quot;Krasimir&amp;quot;,
    age: 29
}));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个简单的函数，输入是我们的模板以及数据对象，输出么估计你也很容易想到，像下面这样子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;lt;p&amp;gt;Hello, my name is Krasimir. I&amp;#39;m 29 years old.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中第一步要做的是寻找里面的模板参数，然后替换成传给引擎的具体数据。我决定使用正则表达式来完成这一步。不过正则不是我的强项，所以大家将就一下，如果有更好的正则也欢迎向我提出。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var re = /&amp;lt;%([^%&amp;gt;]+)?%&amp;gt;/g;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这句正则表达式会捕获所有以&lt;code&gt;&amp;lt;%&lt;/code&gt;开头，以&lt;code&gt;%&amp;gt;&lt;/code&gt;结尾的片段。末尾的参数&lt;code&gt;g&lt;/code&gt;（global）表示不只匹配一个，而是匹配所有符合的片段。&lt;br&gt;Javascript里面有很多种使用正则表达式的方法，我们需要的是根据正则表达式输出一个数组，包含所有的字符串，这正是&lt;code&gt;exec&lt;/code&gt;所做的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var re = /&amp;lt;%([^%&amp;gt;]+)?%&amp;gt;/g;
var match = re.exec(tpl);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们用&lt;code&gt;console.log&lt;/code&gt;把变量&lt;code&gt;match&lt;/code&gt;打印出来，我们会看见：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;[
    &amp;quot;&amp;lt;%name%&amp;gt;&amp;quot;,
    &amp;quot; name &amp;quot;, 
    index: 21,
    input: 
    &amp;quot;&amp;lt;p&amp;gt;Hello, my name is &amp;lt;%name%&amp;gt;. I\&amp;#39;m &amp;lt;%age%&amp;gt; years old.&amp;lt;/p&amp;gt;&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不过我们可以看见，返回的数组仅仅包含第一个匹配项。我们需要用&lt;code&gt;while&lt;/code&gt;循环把上述逻辑包起来，这样才能得到所有的匹配项。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var re = /&amp;lt;%([^%&amp;gt;]+)?%&amp;gt;/g;
while(match = re.exec(tpl)) {
    console.log(match);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果把上面的代码跑一遍，你就会看见&lt;code&gt;&amp;lt;%name%&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;%age%&amp;gt;&lt;/code&gt;都被打印出来了。&lt;/p&gt;
&lt;p&gt;下面，有意思的部分来了。识别出模板中的匹配项后，我们要把他们替换成传递给函数的实际数据。最简单的办法就是使用&lt;code&gt;replace&lt;/code&gt;函数。我们可以像这样来写：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var TemplateEngine = function(tpl, data) {
    var re = /&amp;lt;%([^%&amp;gt;]+)?%&amp;gt;/g;
    while(match = re.exec(tpl)) {
        tpl = tpl.replace(match[0], data[match[1]])
    }
    return tpl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;好了，这样就能跑了，但是还不够好。这里我们以&lt;code&gt;data[&amp;quot;property&amp;quot;]&lt;/code&gt;的方式使用了一个简单对象来传递数据，但是实际情况下我们很可能需要更复杂的嵌套对象。所以我们稍微修改了一下&lt;code&gt;data&lt;/code&gt;对象：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;{
    name: &amp;quot;Krasimir Tsonev&amp;quot;,
    profile: { age: 29 }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不过直接这样子写的话还不能跑，因为在模板中使用&lt;code&gt;&amp;lt;%profile.age%&amp;gt;&lt;/code&gt;的话，代码会被替换成&lt;code&gt;data[&amp;#39;profile.age&amp;#39;]&lt;/code&gt;，结果是&lt;code&gt;undefined&lt;/code&gt;。&lt;br&gt;这样我们就不能简单地用&lt;code&gt;replace&lt;/code&gt;函数，而是要用别的方法。如果能够在&lt;code&gt;&amp;lt;%&lt;/code&gt;和&lt;code&gt;%&amp;gt;&lt;/code&gt;之间直接使用Javascript代码就最好了，这样就能对传入的数据直接求值，像下面这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var template = &amp;#39;&amp;lt;p&amp;gt;Hello, my name is &amp;lt;%this.name%&amp;gt;. I\&amp;#39;m &amp;lt;%this.profile.age%&amp;gt; years old.&amp;lt;/p&amp;gt;&amp;#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你可能会好奇，这是怎么实现的？这里&lt;a href=&quot;http://ejohn.org/blog/javascript-micro-templating/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;John&lt;/a&gt;使用了&lt;code&gt;new Function&lt;/code&gt;的语法，根据字符串创建一个函数。我们不妨来看个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var fn = new Function(&amp;quot;arg&amp;quot;, &amp;quot;console.log(arg + 1);&amp;quot;);
fn(2); // outputs 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;fn&lt;/code&gt;可是一个货真价实的函数。它接受一个参数，函数体是&lt;code&gt;console.log(arg + 1)&lt;/code&gt;;。上述代码等价于下面的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var fn = function(arg) {
    console.log(arg + 1);
}
fn(2); // outputs 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过这种方法，我们可以根据字符串构造函数，包括它的参数和函数体。这不正是我们想要的嘛！不过先别急，在构造函数之前，我们先来看看函数体是什么样子的。&lt;br&gt;按照之前的想法，这个模板引擎最终返回的应该是一个编译好的模板。还是用之前的模板字符串作为例子，那么返回的内容应该类似于：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;return 
&amp;quot;&amp;lt;p&amp;gt;Hello, my name is &amp;quot; + 
this.name + 
&amp;quot;. I\&amp;#39;m &amp;quot; + 
this.profile.age + 
&amp;quot; years old.&amp;lt;/p&amp;gt;&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然啦，实际的模板引擎中，我们会把模板切分为小段的文本和有意义的Javascript代码。前面你可能看见我使用简单的字符串拼接来达到想要的效果，不过这并不是100%符合我们要求的做法。&lt;br&gt;由于使用者很可能会传递更加复杂的Javascript代码，所以我们这儿需要再来一个循环，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var template = 
&amp;#39;My skills:&amp;#39; + 
&amp;#39;&amp;lt;%for(var index in this.skills) {%&gt;&#39; + 
&#39;&lt;a href=&quot;&quot;&gt;&lt;%this.skills[index]%&gt;&lt;/%this.skills[index]%&gt;&lt;/a&gt;&#39; +
&#39;&lt;%}%&amp;gt;&amp;#39;; &lt;=&quot;&quot; code=&quot;&quot;&gt;&lt;/%}%&amp;gt;&amp;#39;;&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果使用字符串拼接的话，代码就应该是下面的样子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;return
&amp;#39;My skills:&amp;#39; + 
for(var index in this.skills) { +
&amp;#39;&amp;lt;a href=&amp;quot;&amp;quot;&amp;gt;&amp;#39; + 
this.skills[index] +
&amp;#39;&amp;lt;/a&amp;gt;&amp;#39; +
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，这个代码不能直接跑，跑了会出错。于是我用了&lt;a href=&quot;http://ejohn.org/blog/javascript-micro-templating/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;John的文章&lt;/a&gt;里写的逻辑，把所有的字符串放在一个数组里，在程序的最后把它们拼接起来。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var r = [];
r.push(&amp;#39;My skills:&amp;#39;); 
for(var index in this.skills) {
r.push(&amp;#39;&amp;lt;a href=&amp;quot;&amp;quot;&amp;gt;&amp;#39;);
r.push(this.skills[index]);
r.push(&amp;#39;&amp;lt;/a&amp;gt;&amp;#39;);
}
return r.join(&amp;#39;&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下一步就是收集模板里面不同的代码行，用于生成函数。通过前面介绍的方法，我们可以知道模板中有哪些占位符（译者注：或者说正则表达式的匹配项）以及它们的位置。&lt;br&gt;所以，依靠一个辅助变量（cursor，游标），我们就能得到想要的结果。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var TemplateEngine = function(tpl, data) {
    var re = /&amp;lt;%([^%&amp;gt;]+)?%&amp;gt;/g,
        code = &amp;#39;var r=[];\n&amp;#39;,
        cursor = 0;
    var add = function(line) {
        code += &amp;#39;r.push(&amp;quot;&amp;#39; + line.replace(/&amp;quot;/g, &amp;#39;\\&amp;quot;&amp;#39;) + &amp;#39;&amp;quot;);\n&amp;#39;;
    }
    while(match = re.exec(tpl)) {
        add(tpl.slice(cursor, match.index));
        add(match[1]);
        cursor = match.index + match[0].length;
    }
    add(tpl.substr(cursor, tpl.length - cursor));
    code += &amp;#39;return r.join(&amp;quot;&amp;quot;);&amp;#39;; // &amp;lt;-- return the result
    console.log(code);
    return tpl;
}
var template = &amp;#39;&amp;lt;p&amp;gt;Hello, my name is &amp;lt;%this.name%&amp;gt;. I\&amp;#39;m &amp;lt;%this.profile.age%&amp;gt; years old.&amp;lt;/p&amp;gt;&amp;#39;;
console.log(TemplateEngine(template, {
    name: &amp;quot;Krasimir Tsonev&amp;quot;,
    profile: { age: 29 }
}));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码中的变量code保存了函数体。开头的部分定义了一个数组。游标&lt;code&gt;cursor&lt;/code&gt;告诉我们当前解析到了模板中的哪个位置。我们需要依靠它来遍历整个模板字符串。&lt;br&gt;此外还有个函数&lt;code&gt;add&lt;/code&gt;，它负责把解析出来的代码行添加到变量&lt;code&gt;code&lt;/code&gt;中去。有一个地方需要特别注意，那就是需要把&lt;code&gt;code&lt;/code&gt;包含的双引号字符进行转义（escape）。否则生成的函数代码会出错。&lt;br&gt;如果我们运行上面的代码，我们会在控制台里面看见如下的内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var r=[];
r.push(&amp;quot;&amp;lt;p&amp;gt;Hello, my name is &amp;quot;);
r.push(&amp;quot;this.name&amp;quot;);
r.push(&amp;quot;. I&amp;#39;m &amp;quot;);
r.push(&amp;quot;this.profile.age&amp;quot;);
return r.join(&amp;quot;&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;等等，貌似不太对啊，&lt;code&gt;this.name&lt;/code&gt;和&lt;code&gt;this.profile.age&lt;/code&gt;不应该有引号啊，再来改改。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var add = function(line, js) {
    js? code += &amp;#39;r.push(&amp;#39; + line + &amp;#39;);\n&amp;#39; :
        code += &amp;#39;r.push(&amp;quot;&amp;#39; + line.replace(/&amp;quot;/g, &amp;#39;\\&amp;quot;&amp;#39;) + &amp;#39;&amp;quot;);\n&amp;#39;;
}
while(match = re.exec(tpl)) {
    add(tpl.slice(cursor, match.index));
    add(match[1], true); // &amp;lt;-- say that this is actually valid js
    cursor = match.index + match[0].length;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;占位符的内容和一个布尔值一起作为参数传给&lt;code&gt;add&lt;/code&gt;函数，用作区分。这样就能生成我们想要的函数体了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var r=[];
r.push(&amp;quot;&amp;lt;p&amp;gt;Hello, my name is &amp;quot;);
r.push(this.name);
r.push(&amp;quot;. I&amp;#39;m &amp;quot;);
r.push(this.profile.age);
return r.join(&amp;quot;&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;剩下来要做的就是创建函数并且执行它。因此，在模板引擎的最后，把原本返回模板字符串的语句替换成如下的内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;return new Function(code.replace(/[\r\t\n]/g, &amp;#39;&amp;#39;)).apply(data);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们甚至不需要显式地传参数给这个函数。我们使用&lt;code&gt;apply&lt;/code&gt;方法来调用它。它会自动设定函数执行的上下文。这就是为什么我们能在函数里面使用&lt;code&gt;this.name&lt;/code&gt;。这里&lt;code&gt;this&lt;/code&gt;指向&lt;code&gt;data&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;模板引擎接近完成了，不过还有一点，我们需要支持更多复杂的语句，比如条件判断和循环。我们接着上面的例子继续写。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var template = 
&amp;#39;My skills:&amp;#39; + 
&amp;#39;&amp;lt;%for(var index in this.skills) {%&gt;&#39; + 
&#39;&lt;a href=&quot;#&quot;&gt;&lt;%this.skills[index]%&gt;&lt;/%this.skills[index]%&gt;&lt;/a&gt;&#39; +
&#39;&lt;%}%&amp;gt;&amp;#39;; console.log(templateengine(template,=&quot;&quot; {=&quot;&quot; skills:=&quot;&quot; [&amp;quot;js&amp;quot;,=&quot;&quot; &amp;quot;html&amp;quot;,=&quot;&quot; &amp;quot;css&amp;quot;]=&quot;&quot; }));=&quot;&quot; &lt;=&quot;&quot; code=&quot;&quot;&gt;&lt;/%}%&amp;gt;&amp;#39;;&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里会产生一个异常，&lt;code&gt;Uncaught SyntaxError: Unexpected token for&lt;/code&gt;。如果我们调试一下，把&lt;code&gt;code&lt;/code&gt;变量打印出来，我们就能发现问题所在。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var r=[];
r.push(&amp;quot;My skills:&amp;quot;);
r.push(for(var index in this.skills) {);
r.push(&amp;quot;&amp;lt;a href=\&amp;quot;\&amp;quot;&amp;gt;&amp;quot;);
r.push(this.skills[index]);
r.push(&amp;quot;&amp;lt;/a&amp;gt;&amp;quot;);
r.push(});
r.push(&amp;quot;&amp;quot;);
return r.join(&amp;quot;&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;带有&lt;code&gt;for&lt;/code&gt;循环的那一行不应该被直接放到数组里面，而是应该作为脚本的一部分直接运行。所以我们在把内容添加到&lt;code&gt;code&lt;/code&gt;变量之前还要多做一个判断。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var re = /&amp;lt;%([^%&amp;gt;]+)?%&amp;gt;/g,
    reExp = /(^( )?(if|for|else|switch|case|break|{|}))(.*)?/g,
    code = &amp;#39;var r=[];\n&amp;#39;,
    cursor = 0;
var add = function(line, js) {
    js? code += line.match(reExp) ? line + &amp;#39;\n&amp;#39; : &amp;#39;r.push(&amp;#39; + line + &amp;#39;);\n&amp;#39; :
        code += &amp;#39;r.push(&amp;quot;&amp;#39; + line.replace(/&amp;quot;/g, &amp;#39;\\&amp;quot;&amp;#39;) + &amp;#39;&amp;quot;);\n&amp;#39;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我们新增加了一个正则表达式。它会判断代码中是否包含&lt;code&gt;if&lt;/code&gt;、&lt;code&gt;for&lt;/code&gt;、&lt;code&gt;else&lt;/code&gt;等等关键字。如果有的话就直接添加到脚本代码中去，否则就添加到数组中去。运行结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var r=[];
r.push(&amp;quot;My skills:&amp;quot;);
for(var index in this.skills) {
r.push(&amp;quot;&amp;lt;a href=\&amp;quot;#\&amp;quot;&amp;gt;&amp;quot;);
r.push(this.skills[index]);
r.push(&amp;quot;&amp;lt;/a&amp;gt;&amp;quot;);
}
r.push(&amp;quot;&amp;quot;);
return r.join(&amp;quot;&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，编译出来的结果也是对的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;My skills:&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;js&amp;lt;/a&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;html&amp;lt;/a&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;css&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后一个改进可以使我们的模板引擎更为强大。我们可以直接在模板中使用复杂逻辑，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var template = 
&amp;#39;My skills:&amp;#39; + 
&amp;#39;&amp;lt;%if(this.showSkills) {%&gt;&#39; +
    &#39;&lt;%for(var index=&quot;&quot; in=&quot;&quot; this.skills)=&quot;&quot; {%=&quot;&quot;&gt;&#39; + 
    &#39;&lt;a href=&quot;#&quot;&gt;&lt;%this.skills[index]%&gt;&lt;/%this.skills[index]%&gt;&lt;/a&gt;&#39; +
    &#39;&lt;%}%&amp;gt;&amp;#39; +=&quot;&quot; &amp;#39;&amp;lt;%}=&quot;&quot; else=&quot;&quot; {%=&quot;&quot;&gt;&#39; +
    &#39;&lt;p&gt;none&lt;/p&gt;&#39; +
&#39;&lt;%}%&amp;gt;&amp;#39;; console.log(templateengine(template,=&quot;&quot; {=&quot;&quot; skills:=&quot;&quot; [&amp;quot;js&amp;quot;,=&quot;&quot; &amp;quot;html&amp;quot;,=&quot;&quot; &amp;quot;css&amp;quot;],=&quot;&quot; showskills:=&quot;&quot; true=&quot;&quot; }));=&quot;&quot; &lt;=&quot;&quot; code=&quot;&quot;&gt;&lt;/%}%&amp;gt;&amp;#39;;&gt;&lt;/%}%&amp;gt;&amp;#39;&gt;&lt;/%for(var&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了上面说的改进，我还对代码本身做了些优化，最终版本如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var TemplateEngine = function(html, options) {
    var re = /&amp;lt;%([^%&amp;gt;]+)?%&amp;gt;/g, reExp = /(^( )?(if|for|else|switch|case|break|{|}))(.*)?/g, code = &amp;#39;var r=[];\n&amp;#39;, cursor = 0;
    var add = function(line, js) {
        js? (code += line.match(reExp) ? line + &amp;#39;\n&amp;#39; : &amp;#39;r.push(&amp;#39; + line + &amp;#39;);\n&amp;#39;) :
            (code += line != &amp;#39;&amp;#39; ? &amp;#39;r.push(&amp;quot;&amp;#39; + line.replace(/&amp;quot;/g, &amp;#39;\\&amp;quot;&amp;#39;) + &amp;#39;&amp;quot;);\n&amp;#39; : &amp;#39;&amp;#39;);
        return add;
    }
    while(match = re.exec(html)) {
        add(html.slice(cursor, match.index))(match[1], true);
        cursor = match.index + match[0].length;
    }
    add(html.substr(cursor, html.length - cursor));
    code += &amp;#39;return r.join(&amp;quot;&amp;quot;);&amp;#39;;
    return new Function(code.replace(/[\r\t\n]/g, &amp;#39;&amp;#39;)).apply(options);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码比我预想的还要少，只有区区15行！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;译文链接：&lt;a href=&quot;原文链接：JavaScript template engine in just 20 lines&quot;&gt;JavaScript template engine in just 20 lines&lt;/a&gt;&lt;/p&gt;
&lt;/blockq
    
    </summary>
    
    
      <category term="javascript" scheme="http://mmrxia.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>nodejs中间件connect</title>
    <link href="http://mmrxia.github.io/2016/12/19/nodejs%E4%B8%AD%E9%97%B4%E4%BB%B6connect/"/>
    <id>http://mmrxia.github.io/2016/12/19/nodejs中间件connect/</id>
    <published>2016-12-19T03:19:21.000Z</published>
    <updated>2016-12-19T03:28:04.498Z</updated>
    
    <content type="html">&lt;h4 id=&quot;什么是connect？&quot;&gt;&lt;a href=&quot;#什么是connect？&quot; class=&quot;headerlink&quot; title=&quot;什么是connect？&quot;&gt;&lt;/a&gt;什么是connect？&lt;/h4&gt;&lt;p&gt;Connect 是Node.js中的一个模块，可以用来创建中间件的一个框架，它自身已经包装了Node的HTTP模块的Server以及Server的req和res的对象。&lt;br&gt;它干的活其实就是处理请求，然后响应客户端或是让下一个中间件继续处理，它的原型是这个样子的:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function (req, res, next) {
  // 中间件
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当next回调函数被调用，中间件就完成工作并传递到下一个中间件，如果没其他中间件则进入到应用逻辑继续执行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;logger&lt;/code&gt;: 用户请求日志中间件&lt;br&gt;&lt;code&gt;csrf&lt;/code&gt;: 跨域请求伪造保护中间件&lt;br&gt;&lt;code&gt;compress&lt;/code&gt;: gzip压缩中间件&lt;br&gt;&lt;code&gt;basicAuth&lt;/code&gt;: basic认证中间件&lt;br&gt;&lt;code&gt;bodyParser&lt;/code&gt;: 请求内容解析中间件&lt;br&gt;&lt;code&gt;json&lt;/code&gt;: JSON解析中间件&lt;br&gt;&lt;code&gt;urlencoded&lt;/code&gt;: application/x-www-form-urlencode请求解析中间件&lt;br&gt;&lt;code&gt;multipart&lt;/code&gt;: multipart/form-data请求解析中间件&lt;br&gt;&lt;code&gt;timeout&lt;/code&gt;: 请求超时中间件&lt;br&gt;&lt;code&gt;cookieParser&lt;/code&gt;: cookie解析中间件&lt;br&gt;&lt;code&gt;session&lt;/code&gt;: 会话管理中间件&lt;br&gt;&lt;code&gt;cookieSession&lt;/code&gt;: 基于cookies的会话中间件&lt;br&gt;&lt;code&gt;methodOverride&lt;/code&gt;: HTTP伪造中间件&lt;br&gt;&lt;code&gt;reponseTime&lt;/code&gt;: 计算响应时间中间件&lt;br&gt;&lt;code&gt;staticCache&lt;/code&gt;: 缓存中间件&lt;br&gt;&lt;code&gt;static&lt;/code&gt;: 静态文件处理中间件&lt;br&gt;&lt;code&gt;directory&lt;/code&gt;: 目录列表中间件&lt;br&gt;&lt;code&gt;vhost&lt;/code&gt;: 虚拟二级域名映射中间件&lt;br&gt;&lt;code&gt;favicon&lt;/code&gt;: 网页图标中间件&lt;br&gt;&lt;code&gt;limit&lt;/code&gt;: 请求内容大小限制中间件&lt;br&gt;&lt;code&gt;query&lt;/code&gt;: URL解析中间件&lt;br&gt;&lt;code&gt;errorHadnler&lt;/code&gt;: 错误处理中间件&lt;/p&gt;
&lt;p&gt;参考: &lt;a href=&quot;http://blog.fens.me/nodejs-connect/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.fens.me/nodejs-connect/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是connect？&quot;&gt;&lt;a href=&quot;#什么是connect？&quot; class=&quot;headerlink&quot; title=&quot;什么是connect？&quot;&gt;&lt;/a&gt;什么是connect？&lt;/h4&gt;&lt;p&gt;Connect 是Node.js中的一个模块，可以用来创建中间件的一
    
    </summary>
    
    
      <category term="nodejs" scheme="http://mmrxia.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>mongoose学习笔记</title>
    <link href="http://mmrxia.github.io/2016/12/16/mongoose%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://mmrxia.github.io/2016/12/16/mongoose学习笔记/</id>
    <published>2016-12-16T08:54:48.000Z</published>
    <updated>2016-12-16T09:27:04.174Z</updated>
    
    <content type="html">&lt;h2 id=&quot;一、快速通道&quot;&gt;&lt;a href=&quot;#一、快速通道&quot; class=&quot;headerlink&quot; title=&quot;一、快速通道&quot;&gt;&lt;/a&gt;一、快速通道&lt;/h2&gt;&lt;h3 id=&quot;1-名词解释&quot;&gt;&lt;a href=&quot;#1-名词解释&quot; class=&quot;headerlink&quot; title=&quot;1. 名词解释&quot;&gt;&lt;/a&gt;1. 名词解释&lt;/h3&gt;&lt;p&gt;Schema（模式）: 一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力。&lt;br&gt;Model（模型）: 源于Schema生成的模型，具有抽象属性和行为的数据库操作对。&lt;br&gt;Entity（实体）: 源于Model创建的实体，操作可影响数据库。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;br&gt;  1 . 本学习文档采用严格命名方式来区别不同对象，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  var PersonSchema;   //Person的文本属性
  var PersonModel;    //Person的数据库模型
  var PersonEntity;   //Person实体
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;  2 . Schema –&amp;gt; Model，Model –&amp;gt; Entity。Model和Entity都可对数据库操作造成影响，但Model比Entity更具操作性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;2-准备工作&quot;&gt;&lt;a href=&quot;#2-准备工作&quot; class=&quot;headerlink&quot; title=&quot;2. 准备工作&quot;&gt;&lt;/a&gt;2. 准备工作&lt;/h3&gt;&lt;p&gt;1 . 首先你必须安装MongoDB和NodeJS&lt;br&gt;  mongodb安装可参考： &lt;a href=&quot;http://blog.xiaqingsong.com/2016/12/16/windows%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmongodb/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;windows下安装配置mongodb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2 . 在项目只能够创建一个数据库连接，如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var mongoose = require(&amp;#39;mongoose&amp;#39;);    //引用mongoose模块
var db = mongoose.createConnection(&amp;#39;localhost&amp;#39;,&amp;#39;test&amp;#39;); //创建一个数据库连接
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3 . 打开本机localhost的test数据库时，我们可以监测是否有异常&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;db.on(&amp;#39;error&amp;#39;,console.error.bind(console,&amp;#39;连接错误:&amp;#39;));
db.once(&amp;#39;open&amp;#39;,function(){
  //mongodb connected!
});
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;br&gt;  成功开启数据库后，就可以执行数据库相应操作，假设以下代码都在回调中处理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;4 . 定义一个Schema&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var PersonSchema = new mongoose.Schema({
  name:String   //定义一个属性name，类型为String
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5 . 将该Schema发布为Model&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var PersonModel = db.model(&amp;#39;Person&amp;#39;,PersonSchema);
//如果该Model已经发布，则可以直接通过名字索引到，如下：
//var PersonModel = db.model(&amp;#39;Person&amp;#39;);
//如果没有发布，上一段代码将会异常
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6 . 用Model创建Entity&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var personEntity = new PersonModel({name:&amp;#39;Krouky&amp;#39;});
//打印这个实体的名字看看
console.log(personEntity.name); //Krouky
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7 . 我们甚至可以为此Schema创建方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//为Schema模型追加speak方法
PersonSchema.methos.speak = function(){
  console.log(&amp;#39;我的名字叫&amp;#39;+this.name);
}
var PersonModel = db.model(&amp;#39;Person&amp;#39;,PersonSchema);
var personEntity = new PersonModel({name:&amp;#39;Krouky&amp;#39;});
personEntity.speak();//我的名字叫Krouky
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;8 . Entity是具有具体的数据库操作CRUD的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;personEntity.save();  //执行完成后，数据库就有该数据了
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;9 . 如果要执行查询，需要依赖Model，当然Entity也是可以做到的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;PersonModel.find(function(err,persons){
  //查询到的所有person
});
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;br&gt;  1 . 具体的如何配置Schema、Model以及Model和Entity的相关操作，我们会在后面进行&lt;br&gt;  2 . Model和Entity都有能影响数据库的操作，但仍有区别，后面我们也会做解释&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、快速通道&quot;&gt;&lt;a href=&quot;#一、快速通道&quot; class=&quot;headerlink&quot; title=&quot;一、快速通道&quot;&gt;&lt;/a&gt;一、快速通道&lt;/h2&gt;&lt;h3 id=&quot;1-名词解释&quot;&gt;&lt;a href=&quot;#1-名词解释&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
    
      <category term="mongodb" scheme="http://mmrxia.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>windows下安装配置mongodb</title>
    <link href="http://mmrxia.github.io/2016/12/16/windows%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmongodb/"/>
    <id>http://mmrxia.github.io/2016/12/16/windows下安装配置mongodb/</id>
    <published>2016-12-16T06:36:29.000Z</published>
    <updated>2017-03-01T03:36:47.965Z</updated>
    
    <content type="html">&lt;p&gt;安装文件：官方网站 &lt;a href=&quot;http://www.mongodb.org/downloads&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.mongodb.org/downloads&lt;/a&gt;&lt;br&gt;选择对应系统的文件下载。&lt;/p&gt;
&lt;h3 id=&quot;一、解压缩文件。&quot;&gt;&lt;a href=&quot;#一、解压缩文件。&quot; class=&quot;headerlink&quot; title=&quot;一、解压缩文件。&quot;&gt;&lt;/a&gt;一、解压缩文件。&lt;/h3&gt;&lt;p&gt;  将压缩包解压，在D盘创建文件夹&lt;code&gt;mongodb&lt;/code&gt;,将压缩包解压到&lt;code&gt;mongodb&lt;/code&gt;文件夹中。&lt;/p&gt;
&lt;h3 id=&quot;二、建立工作目录。&quot;&gt;&lt;a href=&quot;#二、建立工作目录。&quot; class=&quot;headerlink&quot; title=&quot;二、建立工作目录。&quot;&gt;&lt;/a&gt;二、建立工作目录。&lt;/h3&gt;&lt;p&gt;  1、建立数据存放目录  &lt;code&gt;D:\mongodb\data\db&lt;/code&gt;&lt;br&gt;  2、建立日志文件  &lt;code&gt;D:\mongodb\db\log\mongodb.log&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;三、建立配置文件。&quot;&gt;&lt;a href=&quot;#三、建立配置文件。&quot; class=&quot;headerlink&quot; title=&quot;三、建立配置文件。&quot;&gt;&lt;/a&gt;三、建立配置文件。&lt;/h3&gt;&lt;p&gt;&lt;code&gt;mongodb&lt;/code&gt;文件夹下建立&lt;code&gt;mongodb.cfg&lt;/code&gt;文件，输入以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;dbpath=D:\MongoDB\data #数据库路径
logpath=D:\MongoDB\logs\mongodb.log #日志输出文件路径
logappend=true #错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件
journal=true #启用日志文件，默认启用
quiet=true #这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false
port=27017 #端口号 默认为27017
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里仅指定了几个常用项，更多详细配置请参考官方文档 &lt;a href=&quot;http://docs.mongodb.org/manual/reference/configuration-options/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://docs.mongodb.org/manual/reference/configuration-options/&lt;/a&gt;&lt;br&gt;正常情况下，我们一般配置&lt;code&gt;dbpath&lt;/code&gt;和&lt;code&gt;logpath&lt;/code&gt;就够了。&lt;/p&gt;
&lt;p&gt;至此&lt;code&gt;mongodb&lt;/code&gt;文件夹下有文件夹及文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;D:\ mongodb\bin
D:\ mongodb\data\db
D:\ mongodb\data\log
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;四、启动mongdb服务。&quot;&gt;&lt;a href=&quot;#四、启动mongdb服务。&quot; class=&quot;headerlink&quot; title=&quot;四、启动mongdb服务。&quot;&gt;&lt;/a&gt;四、启动mongdb服务。&lt;/h3&gt;&lt;p&gt;配置文件和相关目录建好后可使用以下几种方式启动mongodb。&lt;/p&gt;
&lt;p&gt;控制台进入&lt;code&gt;D:\ mongodb\bin&lt;/code&gt;目录，执行以下命令:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;普通启动&lt;/strong&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;mongod --config D:\mongodb\mongodb.cfg
mongod -f ../mongodb.cfg  #简写
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;安装为Windows服务&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;mongod --config D:\mongodb\mongodb.cfg --install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：2.6版 这种方式在win7、win8 64位版无法安装成功，其他系统未测试&lt;br&gt;BUG链接 &lt;a href=&quot;https://jira.mongodb.org/browse/SERVER-13515&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://jira.mongodb.org/browse/SERVER-13515&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用SC命令安装为Windows服务&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;sc create MongoDB binPath= &amp;quot;D:\mongodb\bin\mongod.exe --service --config=D:\mongodb\mongodb.cfg&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在浏览器输入：&lt;a href=&quot;http://localhost:27017/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost:27017/&lt;/a&gt;，可以看到如下提示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You are trying to access MongoDB on the native driver port. For http diagnostic access, add 1000 to the port number&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如此，说明MongoDB数据库服务已经成功启动了。&lt;/p&gt;
&lt;p&gt;我们可以再启一个shell窗口，执行 &lt;code&gt;mongo&lt;/code&gt; 命令，可以看到如下提示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MongoDB shell version: 2.6.4&lt;br&gt;  connecting to: test&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样的话，说明已经连接到mongodb默认 test 集合了。&lt;/p&gt;
&lt;p&gt;我们也可以使用 &lt;code&gt;mongoVUE&lt;/code&gt; 、 &lt;code&gt;Robomongo&lt;/code&gt; 等可视化工具查看库中的数据。&lt;/p&gt;
&lt;h3 id=&quot;五、系统服务启动与删除。&quot;&gt;&lt;a href=&quot;#五、系统服务启动与删除。&quot; class=&quot;headerlink&quot; title=&quot;五、系统服务启动与删除。&quot;&gt;&lt;/a&gt;五、系统服务启动与删除。&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;net start MongoDB  //启动MongoDB服务  
net stop MongoDB  //停止MongoDB服务   
mongod --remove  //移除MongoDB服务 
sc delete MongoDB   //通过该方式删除的话，服务中的 mongod仍会存在，注册表中不存在了，再重启之后服务的mongodb才会消失
&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;安装文件：官方网站 &lt;a href=&quot;http://www.mongodb.org/downloads&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.mongodb.org/downloads&lt;/a&gt;&lt;br&gt;选择对应系统的文件下载。&lt;
    
    </summary>
    
    
      <category term="mongodb" scheme="http://mmrxia.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>bigPipe方案实现及剖析</title>
    <link href="http://mmrxia.github.io/2016/11/16/bigPipe%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%89%96%E6%9E%90/"/>
    <id>http://mmrxia.github.io/2016/11/16/bigPipe方案实现及剖析/</id>
    <published>2016-11-16T09:24:43.000Z</published>
    <updated>2016-11-16T09:38:16.234Z</updated>
    
    <content type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;2010 年初的时候，Facebook 的前端性能研究小组开始了他们的优化项目，经过了六个月的努力，成功的将个人空间主页面加载耗时由原来的5 秒减少为现在的2.5 秒。&lt;br&gt;这是一个非常了不起的成就，也给用户来带来了很好的体验。在优化项目中，工程师提出了一种新的页面加载技术，称之为Bigpipe。&lt;br&gt;目前淘宝和Facebook面临的问题非常相似：海量数据和页面过大，如果可以在详情页、列表页中使用bigpipe，将会带来明显的页面加载速度提升。&lt;/p&gt;
&lt;h2 id=&quot;相关介绍&quot;&gt;&lt;a href=&quot;#相关介绍&quot; class=&quot;headerlink&quot; title=&quot;相关介绍&quot;&gt;&lt;/a&gt;相关介绍&lt;/h2&gt;&lt;p&gt;一、BigPipe与AJAX&lt;/p&gt;
&lt;p&gt;Web2.0的重要特征是网页显示大量动态内容，即web2.0注重网页与用户的交互。其核心技术是AJAX，如今所有主流网站都或多或少使用AJAX。与AJAX类似，BigPipe 实现了分块儿的概念，使页面能够分步输出，即每次输出一部分网页内容。接下来讨论BigPipe 与AJAX 的区别。&lt;/p&gt;
&lt;p&gt;简单的说，BigPipe 比AJAX 有三个好处：&lt;/p&gt;
&lt;p&gt;1 . AJAX 的核心是XMLHttpRequest，客户端需要异步的向服务器端发送请求，然后将传送过来的内容动态添加到网页上。如此实现存在一些缺陷，即发送往返请求需要耗费时间，而BigPipe 技术使浏览器并不需要发送XMLHttpRequest 请求，这样就节省时间损耗。&lt;/p&gt;
&lt;p&gt;2 . 使用AJAX时，浏览器和服务器的工作顺序执行。服务器必须等待浏览器的请求，这样就会造成服务器的空闲。浏览器工作时，服务器在等待，而服务器工作时，浏览器在等待，这也是一种性能的浪费。使用BigPipe，浏览器和服务器可以并行同时工作，服务器不需要等待浏览器的请求，而是一直处于加载页面内容的工作阶段，这就会使效率得到更大的提高。&lt;/p&gt;
&lt;p&gt;3 . 减少浏览器发送到请求。对一个5亿用户的网站来说，减少了使用AJAX额外带来的请求，会减少服务器的负载，同样会带来很大的性能提升。&lt;/p&gt;
&lt;p&gt;基于以上三点，Facebook 在进行页面优化时采用了BigPipe 技术。目前淘宝主搜索结果页中，需要加载类目，相关搜索，宝贝列表，广告等内容，前端这里使用php 的curl 的批处理来并发的访问引擎获取相应的数据，并进行分步输出。这种模式还是与bigpipe有些不同，这点后面会讲到。一般来讲，在页面比较大，而且比较复杂，样式表和脚本比较多的情况下，使用BigPipe 来优化输出页面是比较合适的。另外非常重要的一点，BigPipe 并不改变浏览器的结构与网络协议，仅使用JS就可以实现，用户不需要做任何的设置，就会看到明显的访问时间缩短。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.searchtb.com/2011/04/an-introduction-to-bigpipe.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.searchtb.com/2011/04/an-introduction-to-bigpipe.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;待续…&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;2010 年初的时候，Facebook 的前端性能研究小组开始了他们的优化项目，经过了六个月的努力，成功的将个人空间主页面加载耗时由原来的5
    
    </summary>
    
    
      <category term="nodejs" scheme="http://mmrxia.github.io/tags/nodejs/"/>
    
      <category term="bigPipe" scheme="http://mmrxia.github.io/tags/bigPipe/"/>
    
  </entry>
  
  <entry>
    <title>js encode或decode base64格式的字符串</title>
    <link href="http://mmrxia.github.io/2016/11/16/js-encode%E6%88%96decode-base64%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://mmrxia.github.io/2016/11/16/js-encode或decode-base64格式的字符串/</id>
    <published>2016-11-16T08:50:07.000Z</published>
    <updated>2017-01-10T08:10:53.271Z</updated>
    
    <content type="html">&lt;h4 id=&quot;方式一：Chrome、FireFox等现代主流浏览器或IE10及以上版本。&quot;&gt;&lt;a href=&quot;#方式一：Chrome、FireFox等现代主流浏览器或IE10及以上版本。&quot; class=&quot;headerlink&quot; title=&quot;方式一：Chrome、FireFox等现代主流浏览器或IE10及以上版本。&quot;&gt;&lt;/a&gt;方式一：Chrome、FireFox等现代主流浏览器或IE10及以上版本。&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 测试字符
var string = &amp;#39;Hello World!&amp;#39;;

// 加密
var encodedString = btoa(string);
console.log(encodedString); // 输出: &amp;quot;SGVsbG8gV29ybGQh&amp;quot;

// 解密
var decodedString = atob(encodedString);
console.log(decodedString); // 输出: &amp;quot;Hello World!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;方式二：跨浏览器的方法（压缩版本）&quot;&gt;&lt;a href=&quot;#方式二：跨浏览器的方法（压缩版本）&quot; class=&quot;headerlink&quot; title=&quot;方式二：跨浏览器的方法（压缩版本）&quot;&gt;&lt;/a&gt;方式二：跨浏览器的方法（压缩版本）&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 定义Base64对象
var Base64={_keyStr:&amp;quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&amp;quot;,encode:function(e){var t=&amp;quot;&amp;quot;;var n,r,i,s,o,u,a;var f=0;e=Base64._utf8_encode(e);while(f&amp;lt;e.length){n=e.charCodeAt(f++);r=e.charCodeAt(f++);i=e.charCodeAt(f++);s=n&amp;gt;&amp;gt;2;o=(n&amp;amp;3)&amp;lt;&amp;lt;4|r&amp;gt;&amp;gt;4;u=(r&amp;amp;15)&amp;lt;&amp;lt;2|i&amp;gt;&amp;gt;6;a=i&amp;amp;63;if(isNaN(r)){u=a=64}else if(isNaN(i)){a=64}t=t+this._keyStr.charAt(s)+this._keyStr.charAt(o)+this._keyStr.charAt(u)+this._keyStr.charAt(a)}return t},decode:function(e){var t=&amp;quot;&amp;quot;;var n,r,i;var s,o,u,a;var f=0;e=e.replace(/[^A-Za-z0-9+/=]/g,&amp;quot;&amp;quot;);while(f&amp;lt;e.length){s=this._keyStr.indexOf(e.charAt(f++));o=this._keyStr.indexOf(e.charAt(f++));u=this._keyStr.indexOf(e.charAt(f++));a=this._keyStr.indexOf(e.charAt(f++));n=s&amp;lt;&amp;lt;2|o&amp;gt;&amp;gt;4;r=(o&amp;amp;15)&amp;lt;&amp;lt;4|u&amp;gt;&amp;gt;2;i=(u&amp;amp;3)&amp;lt;&amp;lt;6|a;t=t+String.fromCharCode(n);if(u!=64){t=t+String.fromCharCode(r)}if(a!=64){t=t+String.fromCharCode(i)}}t=Base64._utf8_decode(t);return t},_utf8_encode:function(e){e=e.replace(/rn/g,&amp;quot;n&amp;quot;);var t=&amp;quot;&amp;quot;;for(var n=0;n&amp;lt;e.length;n++){var r=e.charCodeAt(n);if(r&amp;lt;128){t+=String.fromCharCode(r)}else if(r&amp;gt;127&amp;amp;&amp;amp;r&amp;lt;2048){t+=String.fromCharCode(r&amp;gt;&amp;gt;6|192);t+=String.fromCharCode(r&amp;amp;63|128)}else{t+=String.fromCharCode(r&amp;gt;&amp;gt;12|224);t+=String.fromCharCode(r&amp;gt;&amp;gt;6&amp;amp;63|128);t+=String.fromCharCode(r&amp;amp;63|128)}}return t},_utf8_decode:function(e){var t=&amp;quot;&amp;quot;;var n=0;var r=c1=c2=0;while(n&amp;lt;e.length){r=e.charCodeAt(n);if(r&amp;lt;128){t+=String.fromCharCode(r);n++}else if(r&amp;gt;191&amp;amp;&amp;amp;r&amp;lt;224){c2=e.charCodeAt(n+1);t+=String.fromCharCode((r&amp;amp;31)&amp;lt;&amp;lt;6|c2&amp;amp;63);n+=2}else{c2=e.charCodeAt(n+1);c3=e.charCodeAt(n+2);t+=String.fromCharCode((r&amp;amp;15)&amp;lt;&amp;lt;12|(c2&amp;amp;63)&amp;lt;&amp;lt;6|c3&amp;amp;63);n+=3}}return t}}

// 测试字符
var string = &amp;#39;Hello World!&amp;#39;;

// 加密
var encodedString = Base64.encode(string);
console.log(encodedString); // 输出: &amp;quot;SGVsbG8gV29ybGQh&amp;quot;

// 解密
var decodedString = Base64.decode(encodedString);
console.log(decodedString); // 输出: &amp;quot;Hello World!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;Nodejs端处理&quot;&gt;&lt;a href=&quot;#Nodejs端处理&quot; class=&quot;headerlink&quot; title=&quot;Nodejs端处理&quot;&gt;&lt;/a&gt;Nodejs端处理&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 加密
new Buffer(string).toString(&amp;quot;base64&amp;quot;)

// 解密
new Buffer(string, &amp;quot;base64&amp;quot;).toString()
&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;方式一：Chrome、FireFox等现代主流浏览器或IE10及以上版本。&quot;&gt;&lt;a href=&quot;#方式一：Chrome、FireFox等现代主流浏览器或IE10及以上版本。&quot; class=&quot;headerlink&quot; title=&quot;方式一：Chrome、FireFox
    
    </summary>
    
    
      <category term="javascript" scheme="http://mmrxia.github.io/tags/javascript/"/>
    
      <category term="base64" scheme="http://mmrxia.github.io/tags/base64/"/>
    
  </entry>
  
  <entry>
    <title>怎样使用js生成uuid</title>
    <link href="http://mmrxia.github.io/2016/09/01/%E6%80%8E%E6%A0%B7%E4%BD%BF%E7%94%A8js%E7%94%9F%E6%88%90uuid/"/>
    <id>http://mmrxia.github.io/2016/09/01/怎样使用js生成uuid/</id>
    <published>2016-09-01T06:57:55.000Z</published>
    <updated>2016-09-01T07:10:53.537Z</updated>
    
    <content type="html">&lt;p&gt;原问题：&lt;a href=&quot;http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How to create a GUID / UUID in Javascript?&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Introuction&quot;&gt;&lt;a href=&quot;#Introuction&quot; class=&quot;headerlink&quot; title=&quot;Introuction&quot;&gt;&lt;/a&gt;Introuction&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;UUID = Universally Unique IDentifier, 全球唯一标识符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本来我觉得UUID不是什么事，只是一个唯一性的ID字符串而已。在Stack Overflow上看到这个问题之后，倒开始觉得，也许UUID里也有一些值得去发掘的东西。&lt;/p&gt;
&lt;p&gt;于是我想到了这几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#UUID-and-GUID&quot;&gt;为什么有UUID和GUID这两个东西&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Specification&quot;&gt;有什么规范吗&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;好像我曾多次看到过有人讨论某种系统或变成语言下UUID的生成问题，&lt;a href=&quot;#UUID-and-implementation&quot;&gt;UUID跟系统或者编程语言有关系吗&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;带着这些问题，我查找并学习了一番。现在做个整理。&lt;/p&gt;
&lt;h2 id=&quot;UUID-and-GUID&quot;&gt;&lt;a href=&quot;#UUID-and-GUID&quot; class=&quot;headerlink&quot; title=&quot;UUID and GUID&quot;&gt;&lt;/a&gt;UUID and GUID&lt;/h2&gt;&lt;h4 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h4&gt;&lt;p&gt;UUID来自于IETF发布的一个规范：&lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;A Universally Unique IDentifier (UUID) URN Namespace&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This specification defines a Uniform Resource Name namespace for UUIDs (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDentifier).  A UUID is 128 bits long, and can guarantee uniqueness across space and time.  UUIDs were originally used in the Apollo Network Computing System and later in the Open Software Foundation’s (OSF) Distributed Computing Environment (DCE), and then in Microsoft Windows platforms.&lt;br&gt;This specification is derived from the DCE specification with the kind permission of the OSF (now known as The Open Group).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;UUID和GUID是同一个东西的两个名字。这两个名字的来源不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UUID来源于OSF的DCE规范，也就是RFC4122的前身&lt;/li&gt;
&lt;li&gt;GUID来源于微软，注意RFC4122的作者之一是微软员工&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;用途&quot;&gt;&lt;a href=&quot;#用途&quot; class=&quot;headerlink&quot; title=&quot;用途&quot;&gt;&lt;/a&gt;用途&lt;/h4&gt;&lt;p&gt;UUID的出现，是为了在一个复杂的系统中，唯一的标识每个信息实体，同时不需要有一个集中的id管理。也就是说，根据某种规则来为一个信息实体分配一个唯一的id，而且不需要一个id管理器来保证这个id的唯一性。&lt;/p&gt;
&lt;p&gt;它可以用来标识任何东西，Microsoft用它来表示Windows中的软件（GUID），Linux用它来表示系统中的文件。&lt;/p&gt;
&lt;h2 id=&quot;Specification&quot;&gt;&lt;a href=&quot;#Specification&quot; class=&quot;headerlink&quot; title=&quot;Specification&quot;&gt;&lt;/a&gt;Specification&lt;/h2&gt;&lt;h4 id=&quot;UUID格式规范&quot;&gt;&lt;a href=&quot;#UUID格式规范&quot; class=&quot;headerlink&quot; title=&quot;UUID格式规范&quot;&gt;&lt;/a&gt;UUID格式规范&lt;/h4&gt;&lt;p&gt;这128bits的结构如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          time_low                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       time_mid                |         time_hi_and_version   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |clk_seq_hi_res |  clk_seq_low  |         node (0-1)            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         node (2-5)                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      time-low               = 4hexOctet
      time-mid               = 2hexOctet
      time-high-and-version  = 2hexOctet    // MOST IMPORTANT !
      clock-seq-and-reserved = hexOctet
      clock-seq-low          = hexOctet
      node                   = 6hexOctet
      hexOctet               = hexDigit hexDigit
      hexDigit =
            &amp;quot;0&amp;quot; / &amp;quot;1&amp;quot; / &amp;quot;2&amp;quot; / &amp;quot;3&amp;quot; / &amp;quot;4&amp;quot; / &amp;quot;5&amp;quot; / &amp;quot;6&amp;quot; / &amp;quot;7&amp;quot; / &amp;quot;8&amp;quot; / &amp;quot;9&amp;quot; /
            &amp;quot;a&amp;quot; / &amp;quot;b&amp;quot; / &amp;quot;c&amp;quot; / &amp;quot;d&amp;quot; / &amp;quot;e&amp;quot; / &amp;quot;f&amp;quot; /
            &amp;quot;A&amp;quot; / &amp;quot;B&amp;quot; / &amp;quot;C&amp;quot; / &amp;quot;D&amp;quot; / &amp;quot;E&amp;quot; / &amp;quot;F&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;UUID生成算法&quot;&gt;&lt;a href=&quot;#UUID生成算法&quot; class=&quot;headerlink&quot; title=&quot;UUID生成算法&quot;&gt;&lt;/a&gt;UUID生成算法&lt;/h4&gt;&lt;p&gt;UUID本身也经过了&lt;a href=&quot;http://en.wikipedia.org/wiki/Universally_unique_identifier#Variants_and_versions&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;多个版本的演化&lt;/a&gt;。比如node字段的定义，最开始定义为来自IEEE 802 address，演化到后来的&lt;em&gt;a randomly or pseudo-randomly generated 48-bit value&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;最新的UUID生成算法是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Set the two most significant bits (bits 6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively.&lt;/li&gt;
&lt;li&gt;Set the four most significant bits (bits 12 through 15) of the time_hi_and_version field to the 4-bit version number.&lt;/li&gt;
&lt;li&gt;Set all the other bits to randomly (or pseudo-randomly) chosen values.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;UUID-and-implementation&quot;&gt;&lt;a href=&quot;#UUID-and-implementation&quot; class=&quot;headerlink&quot; title=&quot;UUID and implementation&quot;&gt;&lt;/a&gt;UUID and implementation&lt;/h2&gt;&lt;p&gt;越来越多的系统中使用着UUID，各自使用目的并不一样。而且由于限定在128bits，UUID规范本身并没有保证UUID真的是在全球唯一的。因此现在对UUID的使用，一般都是限定在一个范围内有唯一性保证，比如一个操作系统内。&lt;/p&gt;
&lt;p&gt;因此我们可以看到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微软有一个GUID生成lib：&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.guid(v=vs.110).aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://msdn.microsoft.com/en-us/library/system.guid(v=vs.110).aspx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Linux也同样有UUID生成lib：&lt;a href=&quot;http://en.wikipedia.org/wiki/Util-linux&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://en.wikipedia.org/wiki/Util-linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Android的UUID生成lib：&lt;a href=&quot;http://developer.android.com/reference/java/util/UUID.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://developer.android.com/reference/java/util/UUID.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用以上系统对应的UUID生成lib可以确保产生的UUID在系统范围内是唯一的。因此可以用来标识系统资源，比如文件、软件、设备等。&lt;/p&gt;
&lt;p&gt;而对于某种具体的编程语言，UUID的使用并没有必要。因为使用UUID的目的是给某个资源分配一个在当前环境下唯一的标识符。而一个程序只有在运行的时候才谈得上有一个&lt;strong&gt;环境&lt;/strong&gt;，进程之间又互不影响。因此，一般在编程语言规范中并没有对UUID生成方法进行规定。&lt;/p&gt;
&lt;p&gt;但&lt;em&gt;unique id&lt;/em&gt;还是很常用的，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PHP - uniqid() &lt;a href=&quot;http://php.net/manual/en/function.uniqid.php#94959&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://php.net/manual/en/function.uniqid.php#94959&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Mysql - UUID() &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/miscellaneous-functions.html#function_uuid&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://dev.mysql.com/doc/refman/5.1/en/miscellaneous-functions.html#function_uuid&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Java - UUID &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/UUID.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://docs.oracle.com/javase/7/docs/api/java/util/UUID.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但这些UUID方法只是借用了&lt;em&gt;唯一性&lt;/em&gt;的概念，并不是必须。而且uuid规定128bits，很多情况下有点浪费。&lt;/p&gt;
&lt;p&gt;你可以用任何方法来生成一个程序内唯一的字符串，比如mysql中的incremental id，它就比uuid实用。&lt;/p&gt;
&lt;p&gt;##UUID in Javascript&lt;br&gt;既然要生成UUID，那么得符合规范。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Javascript function&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function generateUUID(){
    var d = new Date().getTime();
    var uuid = &amp;#39;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&amp;#39;.replace(/[xy]/g, function(c) {
        var r = (d + Math.random()*16)%16 | 0;
        d = Math.floor(d/16);
        return (c==&amp;#39;x&amp;#39; ? r : (r&amp;amp;0x7|0x8)).toString(16);
    });
    return uuid;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Node module&lt;br&gt;&lt;a href=&quot;https://github.com/broofa/node-uuid&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/broofa/node-uuid&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;原问题：&lt;a href=&quot;http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How to cre
    
    </summary>
    
    
      <category term="javascript" scheme="http://mmrxia.github.io/tags/javascript/"/>
    
      <category term="uuid" scheme="http://mmrxia.github.io/tags/uuid/"/>
    
  </entry>
  
  <entry>
    <title>使用淘宝npm镜像cnpm</title>
    <link href="http://mmrxia.github.io/2016/08/05/%E4%BD%BF%E7%94%A8%E6%B7%98%E5%AE%9Dnpm%E9%95%9C%E5%83%8Fcnpm/"/>
    <id>http://mmrxia.github.io/2016/08/05/使用淘宝npm镜像cnpm/</id>
    <published>2016-08-05T03:24:36.000Z</published>
    <updated>2016-08-05T03:57:36.984Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;在使用 node 模块时可以使用 npm install 查找 package.json 中的声明的依赖模块并安装。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但因为国内网络原因，使用 npm 安装某些模块会非常慢，甚至无法安装所有的包。&lt;br&gt;幸运的是,国内有几个镜像站点可以供我们使用,比如 &lt;code&gt;https://registry.cnpmjs.org&lt;/code&gt;、&lt;code&gt;https://registry.npm.taobao.org&lt;/code&gt;,速度非常快,镜像站会实时更新,为我们节省了好多时间.    &lt;/p&gt;
&lt;h5 id=&quot;那么-如何给本机换源呢&quot;&gt;&lt;a href=&quot;#那么-如何给本机换源呢&quot; class=&quot;headerlink&quot; title=&quot;那么,如何给本机换源呢?&quot;&gt;&lt;/a&gt;那么,如何给本机换源呢?&lt;/h5&gt;&lt;p&gt;(1)[临时]通过 &lt;code&gt;config&lt;/code&gt; 配置指向国内镜像源&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;# 配置指向源
npm config set registry http://registry.cnpmjs.org
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(2)[临时]通过 &lt;code&gt;npm&lt;/code&gt; 命令指定下载源&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;npm --registry http://registry.cnpmjs.org
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(3)[linux]在配置文件 &lt;code&gt;~/.npmrc&lt;/code&gt; 文件写入源地址&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;//打开配置文件
nano ~/.npmrc
//写入配置文件
registry =https://registry.npm.taobao.org
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;推荐使用最后一种方法,一劳永逸,前面2钟方法都是临时改变包下载源.&lt;br&gt;如果你不想使用国内镜像站点,只需要将 写入 &lt;code&gt;~/.npmrc&lt;/code&gt; 的配置内容删除即可.  &lt;/p&gt;
&lt;p&gt;配置后可通过下面方式来验证是否成功&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;npm config get registry
// 或
npm info express
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&quot;使用cnpm&quot;&gt;&lt;a href=&quot;#使用cnpm&quot; class=&quot;headerlink&quot; title=&quot;使用cnpm&quot;&gt;&lt;/a&gt;使用cnpm&lt;/h5&gt;&lt;p&gt;或者你也可以安装&lt;code&gt;cnpm&lt;/code&gt;包，使用&lt;code&gt;cnpm&lt;/code&gt;替代&lt;code&gt;npm&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;npm install -g cnpm --registry=https://registry.npm.taobao.org
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后使用 &lt;code&gt;cnpm&lt;/code&gt; 安装模块：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;cnpm install [module-name]
&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在使用 node 模块时可以使用 npm install 查找 package.json 中的声明的依赖模块并安装。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但因为国内网络原因，使用 npm 安装某些模块会非常慢，甚至无法安装所有的包。&lt;br
    
    </summary>
    
    
      <category term="npm" scheme="http://mmrxia.github.io/tags/npm/"/>
    
      <category term="cnpm" scheme="http://mmrxia.github.io/tags/cnpm/"/>
    
  </entry>
  
  <entry>
    <title>html5在iOS设备上传图片调整方向实践</title>
    <link href="http://mmrxia.github.io/2016/07/18/html5%E5%9C%A8iOS%E8%AE%BE%E5%A4%87%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E8%B0%83%E6%95%B4%E6%96%B9%E5%90%91%E5%AE%9E%E8%B7%B5/"/>
    <id>http://mmrxia.github.io/2016/07/18/html5在iOS设备上传图片调整方向实践/</id>
    <published>2016-07-18T11:56:54.000Z</published>
    <updated>2016-07-18T11:59:19.353Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;解决在iOS设备上，用H5上传图片，有时图片方向会错乱的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用html5编写图片裁切上传，在iphone手机上可能会遇到图片方向错误问题，在此把解决方法和大家分享一下，&lt;br&gt;用到了html5的 FileReader和Canvas，如果还没有接触的同学，先了解一下其方法。   &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt; //此方法为file input元素的change事件
 function change(){
    var file = this.files[0];
    var orientation;
    //EXIF js 可以读取图片的元信息  https://github.com/exif-js/exif-js
    EXIF.getData(file,function(){
        orientation=EXIF.getTag(this,&amp;#39;Orientation&amp;#39;);
    });
    var reader = new FileReader();
    reader.onload = function(e) {   
        getImgData(this.result,orientation,function(data){
            //这里可以使用校正后的图片data了 
        }); 
    }
    reader.readAsDataURL(file);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面是具体的处理方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// @param {string} img 图片的base64
// @param {int} dir exif获取的方向信息
// @param {function} next 回调方法，返回校正方向后的base64
function getImgData(img,dir,next){
  var image=new Image();
  image.onload=function(){
    var degree=0,drawWidth,drawHeight,width,height;
    drawWidth=this.naturalWidth;
    drawHeight=this.naturalHeight;
    //以下改变一下图片大小
    var maxSide = Math.max(drawWidth, drawHeight);
    if (maxSide &amp;gt; 1024) {
        var minSide = Math.min(drawWidth, drawHeight);
        minSide = minSide / maxSide * 1024;
        maxSide = 1024;
        if (drawWidth &amp;gt; drawHeight) {
            drawWidth = maxSide;
            drawHeight = minSide;
        } else {
            drawWidth = minSide;
            drawHeight = maxSide;
        }
    }
    var canvas=document.createElement(&amp;#39;canvas&amp;#39;);
    canvas.width=width=drawWidth;
    canvas.height=height=drawHeight; 
    var context=canvas.getContext(&amp;#39;2d&amp;#39;);
    //判断图片方向，重置canvas大小，确定旋转角度，iphone默认的是home键在右方的横屏拍摄方式
    switch(dir){
       //iphone横屏拍摄，此时home键在左侧
        case 3:
            degree=180;
            drawWidth=-width;
            drawHeight=-height;
            break;
        //iphone竖屏拍摄，此时home键在下方(正常拿手机的方向)
        case 6:
            canvas.width=height;
            canvas.height=width; 
            degree=90;
            drawWidth=width;
            drawHeight=-height;
            break;
        //iphone竖屏拍摄，此时home键在上方
        case 8:
            canvas.width=height;
            canvas.height=width; 
            degree=270;
            drawWidth=-width;
            drawHeight=height;
            break;
    }
    //使用canvas旋转校正
    context.rotate(degree*Math.PI/180);
    context.drawImage(this,0,0,drawWidth,drawHeight);
    //返回校正图片
    next(canvas.toDataURL(&amp;quot;image/jpeg&amp;quot;,.8));
 }
  image.src=img;
}
&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;解决在iOS设备上，用H5上传图片，有时图片方向会错乱的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用html5编写图片裁切上传，在iphone手机上可能会遇到图片方向错误问题，在此把解决方法和大家分享一下，&lt;br&gt;用到了html5的 Fil
    
    </summary>
    
    
      <category term="移动端开发" scheme="http://mmrxia.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="js" scheme="http://mmrxia.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>centOS下配置git</title>
    <link href="http://mmrxia.github.io/2016/07/04/centOS%E4%B8%8B%E9%85%8D%E7%BD%AEgit/"/>
    <id>http://mmrxia.github.io/2016/07/04/centOS下配置git/</id>
    <published>2016-07-04T08:14:54.000Z</published>
    <updated>2016-07-17T06:26:55.420Z</updated>
    
    <content type="html">&lt;h4 id=&quot;1-安装git&quot;&gt;&lt;a href=&quot;#1-安装git&quot; class=&quot;headerlink&quot; title=&quot;1. 安装git&quot;&gt;&lt;/a&gt;1. 安装git&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost ~]# yum install git
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;2-配置git&quot;&gt;&lt;a href=&quot;#2-配置git&quot; class=&quot;headerlink&quot; title=&quot;2. 配置git&quot;&gt;&lt;/a&gt;2. 配置git&lt;/h4&gt;&lt;p&gt;1 . 进入 &lt;code&gt;.ssh&lt;/code&gt; 目录&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost ~]# cd .ssh/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2 . 生成ssh-keygen&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost .ssh]# ssh-keygen -t rsa -C &amp;#39;this.xqs@gmail.com&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会出现以下提示：&lt;/p&gt;
&lt;p&gt;Generating public/private rsa key pair.&lt;br&gt;Enter file in which to save the key (/root/.ssh/id_rsa): （可不填）&lt;br&gt;Enter passphrase (empty for no passphrase):  （可不填）&lt;br&gt;Enter same passphrase again:  （可不填）&lt;br&gt;Your identification has been saved in /root/.ssh/id_rsa.&lt;br&gt;Your public key has been saved in /root/.ssh/id_rsa.pub.&lt;br&gt;The key fingerprint is:&lt;br&gt;8f:8e:89:00:1a:3e:83:d1:95:fc:e8:9c:22:85:4c:a7 this.xqs@gmail.com        &lt;/p&gt;
&lt;p&gt;3 . 复制 &lt;code&gt;id_rsa.pub&lt;/code&gt; 文件中的内容，粘贴到github新增的ssh keys中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost .ssh]# ls
// id_rsa  id_rsa.pub

[root@localhost .ssh]# vim id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4 . 配置用户名和邮箱&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost .ssh]# git config --global user.name &amp;#39;bandwagonhost vps&amp;#39;
[root@localhost .ssh]# git config --global user.email &amp;#39;this.xqs@gmail.com&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5 . 测试连接&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost .ssh]# ssh -T git@github.com
Hi mmrxia! You&amp;#39;ve successfully authenticated, but GitHub does not provide shell access.
&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-安装git&quot;&gt;&lt;a href=&quot;#1-安装git&quot; class=&quot;headerlink&quot; title=&quot;1. 安装git&quot;&gt;&lt;/a&gt;1. 安装git&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost ~]
    
    </summary>
    
    
      <category term="Linux" scheme="http://mmrxia.github.io/tags/Linux/"/>
    
      <category term="git" scheme="http://mmrxia.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>centOS下安装nodeJS</title>
    <link href="http://mmrxia.github.io/2016/07/04/centOS%E4%B8%8B%E5%AE%89%E8%A3%85nodeJS/"/>
    <id>http://mmrxia.github.io/2016/07/04/centOS下安装nodeJS/</id>
    <published>2016-07-04T06:30:07.000Z</published>
    <updated>2016-07-07T09:35:21.099Z</updated>
    
    <content type="html">&lt;h4 id=&quot;一、源码安装&quot;&gt;&lt;a href=&quot;#一、源码安装&quot; class=&quot;headerlink&quot; title=&quot;一、源码安装&quot;&gt;&lt;/a&gt;一、源码安装&lt;/h4&gt;&lt;p&gt;1 . 安装gcc-c编译器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost ~]# sudo yum install gcc gcc-c++
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2 . 现在nodejs源码并解压  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost ~]# wget https://nodejs.org/dist/v4.4.7/node-v4.4.7-linux-x86.tar.gz
[root@localhost ~]# tar xvf node-v4.4.7-linux-x86
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3 . 编译&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[root@localhost ~]# ./configure
[root@localhost ~]# make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;二、nvm安装&quot;&gt;&lt;a href=&quot;#二、nvm安装&quot; class=&quot;headerlink&quot; title=&quot;二、nvm安装&quot;&gt;&lt;/a&gt;二、nvm安装&lt;/h4&gt;&lt;p&gt;1 . 获取nvm&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.31.2/install.sh | bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2 . 安装nodejs&lt;/p&gt;
&lt;p&gt; 可用 &lt;code&gt;nvm ls-remote&lt;/code&gt; 列出所有可安装的node版本，然后安装需要的版本。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; nvm install v4.4.7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装完成后可查看node版本。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;node -v
&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、源码安装&quot;&gt;&lt;a href=&quot;#一、源码安装&quot; class=&quot;headerlink&quot; title=&quot;一、源码安装&quot;&gt;&lt;/a&gt;一、源码安装&lt;/h4&gt;&lt;p&gt;1 . 安装gcc-c编译器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[r
    
    </summary>
    
    
      <category term="nodejs" scheme="http://mmrxia.github.io/tags/nodejs/"/>
    
      <category term="Linux" scheme="http://mmrxia.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>express学习笔记</title>
    <link href="http://mmrxia.github.io/2016/07/01/express%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://mmrxia.github.io/2016/07/01/express学习笔记/</id>
    <published>2016-07-01T07:32:01.000Z</published>
    <updated>2016-07-18T11:44:35.814Z</updated>
    
    <content type="html">&lt;h4 id=&quot;1-app-render和res-render方法的区别？&quot;&gt;&lt;a href=&quot;#1-app-render和res-render方法的区别？&quot; class=&quot;headerlink&quot; title=&quot;1 . app.render和res.render方法的区别？&quot;&gt;&lt;/a&gt;1 . app.render和res.render方法的区别？&lt;/h4&gt;&lt;p&gt;官方的api文档中是这么说的：   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Think of app.render() as a utility function for generating rendered view strings. Internally res.render() uses app.render() to render views.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的理解：&lt;/p&gt;
&lt;p&gt;把&lt;code&gt;app.render&lt;/code&gt;当成一个生成视图的工具，而且&lt;code&gt;res.render&lt;/code&gt;内部也是调用了&lt;code&gt;app.render&lt;/code&gt;。&lt;br&gt;区别是这样，&lt;code&gt;app.render&lt;/code&gt;只负责生成视图，你会发现它是没能力把视图响应给客户端（浏览器）的，只有&lt;code&gt;res.render&lt;/code&gt;手里有&lt;code&gt;response&lt;/code&gt;对象，可以把视图响应给客户端。&lt;br&gt;&lt;code&gt;res.render&lt;/code&gt;的伪代码可以看做如下: &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;res.render = function(view, locals, cb){
    app.render(view, locals, function(err, html){
        if(typeof cb !== &amp;#39;undefined&amp;#39;){
            return cb(err, html);
        }
        res.send(html);
    });
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;2-res-write和res-send区别？&quot;&gt;&lt;a href=&quot;#2-res-write和res-send区别？&quot; class=&quot;headerlink&quot; title=&quot;2 . res.write和res.send区别？&quot;&gt;&lt;/a&gt;2 . res.write和res.send区别？&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;The res object represents the HTTP response that an Express app sends when it gets an HTTP request.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;res.write&lt;/code&gt;和&lt;code&gt;res.send&lt;/code&gt;都是发送报文到浏览器response中，并渲染在浏览器窗口。&lt;br&gt;&lt;code&gt;res.write&lt;/code&gt;使用时需要配合&lt;code&gt;res.end&lt;/code&gt;方法同时使用，否则浏览器http请求会一直处于pending状态，而&lt;code&gt;res.send&lt;/code&gt;单独使用即可。    &lt;/p&gt;
&lt;p&gt;代码示例：     &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//res.send
app.get(&amp;#39;/user/:id&amp;#39;, function(req, res){
  res.send(&amp;#39;user &amp;#39; + req.params.id);
});

//res.write
app.get(&amp;#39;/user/:id&amp;#39;, function(req, res){
 res.status(200).write(&amp;#39;user &amp;#39; + req.params.id);
 res.end();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;3-获取request请求参数的方法？&quot;&gt;&lt;a href=&quot;#3-获取request请求参数的方法？&quot; class=&quot;headerlink&quot; title=&quot;3 . 获取request请求参数的方法？&quot;&gt;&lt;/a&gt;3 . 获取request请求参数的方法？&lt;/h4&gt;&lt;p&gt;express获取参数有三种方法：  &lt;/p&gt;
&lt;p&gt;官网实例：   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Checks route params (req.params), ex: /user/:id&lt;br&gt;Checks query string params (req.query), ex: ?id=12&lt;br&gt;Checks urlencoded body params (req.body), ex: id=    &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;例如：127.0.0.1:3000/index，得到index，可以通过使用&lt;code&gt;req.params&lt;/code&gt;得到；   &lt;/li&gt;
&lt;li&gt;例如：127.0.0.1:3000/index?id=12，这种情况下，这种方式是获取客户端get方式传递过来的值，通过使用&lt;code&gt;req.query.id&lt;/code&gt;可以获得；     &lt;/li&gt;
&lt;li&gt;例如：127.0.0.1：300/index，然后post了一个id=2的值，这种方式是获取客户端post过来的数据，可以通过&lt;code&gt;req.body.id&lt;/code&gt;获取； &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：post请求，第三种方式需要以下配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;   var express        =         require(&amp;quot;express&amp;quot;);  
   var bodyParser     =         require(&amp;quot;body-parser&amp;quot;);  
   var app            =         express();  

   app.use(bodyParser.urlencoded({ extended: false }));   // necessary
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;4-session使用入门&quot;&gt;&lt;a href=&quot;#4-session使用入门&quot; class=&quot;headerlink&quot; title=&quot;4 . session使用入门&quot;&gt;&lt;/a&gt;4 . session使用入门&lt;/h4&gt;&lt;p&gt;&lt;code&gt;express-session&lt;/code&gt;是express中比较常用的处理session的中间件,使用npm安装：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;$ npm install express-session save
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;session的认证机制必须依赖cookie，所以还应该同时安装一个&lt;code&gt;cookie-parser&lt;/code&gt;，安装方法同上。然后再app.js中导入这两个中间件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var cookieParser = require(&amp;#39;cookie-parser&amp;#39;);
var session = require(&amp;#39;express-session&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后定义cookie解析器，注意，该定义必须写在路由分配之前：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;app.use(cookieParser());
app.use(session({
  secret: &amp;#39;secret_string&amp;#39;,
  name: &amp;#39;name&amp;#39;,
  cookie: {maxAge: 60000},
  resave: false,
  saveUninitialized: true,
}));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;各参数意义：&lt;br&gt;&lt;code&gt;secret&lt;/code&gt;：用来对session数据进行加密的字符串.这个属性值为必须指定的属性。&lt;br&gt;&lt;code&gt;name&lt;/code&gt;：表示cookie的name，默认cookie的name是：connect.sid。&lt;br&gt;&lt;code&gt;maxAge&lt;/code&gt;：cookie过期时间，毫秒。&lt;br&gt;&lt;code&gt;resave&lt;/code&gt;：是指每次请求都重新设置session cookie，假设你的cookie是6000毫秒过期，每次请求都会再设置6000毫秒。&lt;br&gt;&lt;code&gt;saveUninitialized&lt;/code&gt;： 是指无论有没有session cookie，每次请求都设置个session cookie ，默认给个标示为 connect.sid。     &lt;/p&gt;
&lt;p&gt;之后在处理请求时直接通过以下方式对session进行读写：        &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;req.session.userinfo = userinfo;  //写入至session
res.redirect(req.session.userinfo); //从session中读取
&lt;/code&gt;&lt;/pre&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-app-render和res-render方法的区别？&quot;&gt;&lt;a href=&quot;#1-app-render和res-render方法的区别？&quot; class=&quot;headerlink&quot; title=&quot;1 . app.render和res.render方法的区别？&quot;&gt;&lt;
    
    </summary>
    
    
      <category term="nodejs" scheme="http://mmrxia.github.io/tags/nodejs/"/>
    
      <category term="express" scheme="http://mmrxia.github.io/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>16年后web开发趋势思考</title>
    <link href="http://mmrxia.github.io/2016/06/27/16%E5%B9%B4%E5%90%8Eweb%E5%BC%80%E5%8F%91%E8%B6%8B%E5%8A%BF%E6%80%9D%E8%80%83/"/>
    <id>http://mmrxia.github.io/2016/06/27/16年后web开发趋势思考/</id>
    <published>2016-06-27T07:21:44.000Z</published>
    <updated>2017-01-10T03:57:08.765Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;Rewriting your Frontend Framework every six week !!!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;近二年的进展&quot;&gt;&lt;a href=&quot;#近二年的进展&quot; class=&quot;headerlink&quot; title=&quot;近二年的进展&quot;&gt;&lt;/a&gt;近二年的进展&lt;/h3&gt;&lt;p&gt;前端发展日新月异, 甚至有一句戏言: “每六星期重写一个前端框架”, 行业是像火箭一样, 但我们前端工程师该何去何从呢?&lt;br&gt;我们来谈谈这个问题.&lt;br&gt;先来看看最流行的几项技术栈:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;AngularJS&lt;br&gt;首创的双向数据绑定, 以及内置的模块注入, 以及组件化的支持, 种种优势, 使得它迅速发展起来. 在 2014-2015 年, 有调查显示, 在使用了前端框架的项目, 有 50% 以上采用了 AngularJS. 但到底值不值我们继续学习, 我们再接下来看.&lt;br&gt;项目地址: &lt;a href=&quot;https://angularjs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;EmberJS&lt;br&gt;受 Rails 全栈框架的启发, EmberJS 逐步发展成前端领域的另一个 “Rails”, 成为另一个独特的选择, 理论上, 你选择了 EmberJS, 就选择了一个完整稳定的生态, 不用再折腾的轮子. EmberJS 不仅全面支持模块化, MVC, 也实现了类似 AngularJS 的双向绑定( 当然原理不同 ), 甚至还做到了内置的打包和发布应用功能. 总而言之, 它是一个十分全面的前端框架. 事实上, 如果说 AngularJS 是当前短暂的前端史的一个高峰, 它就是另一个高峰. 但最近, 人气有一定的下降, 原因何在, 我们再分解.&lt;br&gt;项目地址: &lt;a href=&quot;http://emberjs.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ReactJS&lt;br&gt;ReactJS 自发布之始, 就人气很高, 它是第一个采用虚拟节点( virtual dom )技术的框架, 通过这个技术点, 它独创性地整合了函数性编程的理念, 采用单向数据流来设计 dom 渲染与比对, 使得它轻量和灵活, 事实上, 它本身只专注于如何渲染 UI, 也不与 AngularJS 和 EmberJS 有冲突. 换言之, 你可以将它整合到其他框架中.&lt;br&gt;随着 ReactNative 和 Redux 方案的出现, ReactJS 重新回到前端的浪尖, 因为其简洁优雅的实现和对 Native APP 的冲击, 又一次成为新的弄潮儿.&lt;br&gt;但以后会怎么样, 谁也不知道, 但我也会再给一些解读.&lt;br&gt;项目地址: &lt;a href=&quot;https://facebook.github.io/react/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;流行不一定是发展最快, 我们再来看看近二年发展最快的几项前端技术栈:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ReactJS&lt;br&gt;上文已经提到, React 由于本身的简洁性和对组件化专注的实现, 一直没有被新的 ES6 标准和前端思潮落下, 它几乎不受 ES6 的影响, 以及前沿性的支持 native app 开发( 通过 ReactNative ), 所以一直发展趋势良好.&lt;br&gt;而 AngularJS 则不一样, 由于 ES6 的发布, 使得它的依赖注入特性成为鸡肋, 以及 AngularJS 第一版对组件化支持的蹩脚实现( 能支持是一回事, 好用是另一回事 ), 而组件化则学习成本过高, 过于复杂, 所以 AngularJS 决定推翻设计重新开发第二版, 而第二版过于激进的采用 Typescript, 完全不兼容的第一版的设计, 以及各种魔法的应用, 使得它离前端越走越远.   &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;VueJS&lt;br&gt;VueJS 是近二年的新秀, 它起步之初, 只是一个简化版的类似于 AngularJS 双向绑定的实现的研究( 当然原理并不同 ). 但其理念与 ReactJS 相近, 只是专注于实现数据绑定, 模块化与组件化, 所以足够的简单灵活.&lt;br&gt;随着生态的快速发展, VueJS 正好接了 AngularJS 第一版的班, 又改良了 AngularJS 的错误设计( 事后来看, 依赖注入与组件化两部分是比较失败的设计 ), 整体发展迅速, 逐步成为后起之秀.&lt;br&gt;项目地址: &lt;a href=&quot;http://vuejs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MeteorJS&lt;br&gt;MeteorJS 本不适合与上述几个前端框架比较, 因为它实际是一个全栈框架, 更像 Rails 这种角色, 但由于它是纯 Javascript 的方案, 所以还是放在这里.&lt;br&gt;如果说上述前端框架都是解决前端工程化的产物, 那 MeteorJS 是一个颠覆思维的 web 开发框架, 它将Javascript 同构技术应用到极端, 再整合 websocket 进行实时数据通知与热代码更新, 不同于前后端分离的理念, 它在开发者角度完全没有前后端的概念, API 既在前端又在后端, 再加它全生态的支持( 移动 app 支持, 应用发布), 也是一个全新的视角, 由于它发展速度极快, 所以列在这里.&lt;br&gt;项目地址: &lt;a href=&quot;https://www.meteor.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;各大框架都在迅速发展中, 它们有几个共性的发展方向:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ES6 支持&lt;br&gt;每一次 Javascript 的新标准发布, 都是各大框架更新的好机会, 所以 ES6 是肯定得到各大框架的良好支持, 建议大家一定要学好.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;web 组件化&lt;br&gt;毋庸置疑, 组件化是现代前端工程化中极为重要的特性, 甚至 google 还专门出了 Polymer 这个只做组件化实现的框架. 所以每一个够格的前端框架都非常重度支持它. 同时, 组件化也将作为 w3c 标准予于定义, 所以前端框架仍将不留余力地改进与标准的兼容.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Server-side Render&lt;br&gt;服务端渲染技术是 2016 年才开始火的概念, 它与传统的后端渲染不同, 为了解决前端框架第一次加载慢的问题, 以及 SEO 问题, 而提出的解决方案. 之前有 prerender, 现在各大框架都在尝试在内部集成并支持它. 但我个人觉得, 带来的问题远比解决的问题更多, 比如要求我们开发的时候有更多的限制.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;App Render&lt;br&gt;现在有一种大前端的概念, 可以理解为 web 前端对 App 开发的支持, 包括 Ionic ( 基于 AngularJS ), React Native( 基于 React 理念 ), Meteor 都是针对 App 开发的痛点而生.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分析了众多目前最流行的前端框架, 大家可能越来越胡涂了:&lt;br&gt;到底谁才是最值得我们去投入的技术呢?&lt;br&gt;接下来, 我们去掉一堆术语, 来从前端的定义本质来看它的发展. &lt;/p&gt;
&lt;h3 id=&quot;近二年本质的演进是什么&quot;&gt;&lt;a href=&quot;#近二年本质的演进是什么&quot; class=&quot;headerlink&quot; title=&quot;近二年本质的演进是什么&quot;&gt;&lt;/a&gt;近二年本质的演进是什么&lt;/h3&gt;&lt;p&gt;前端就是面向用户这一端的技术, 然而, 随着时代的发展:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户体验要求越来越高( 加载速度快, 响应快, 无闪烁 )&lt;/li&gt;
&lt;li&gt;前端需求越来越多&lt;/li&gt;
&lt;li&gt;前端代码越来越庞大&lt;/li&gt;
&lt;li&gt;移动端快速发展对 h5 前端的需求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而 jQuery, ProtoypeJS 等只解决了 Javascript 工具库的问题, 但工程化需求无好的解决方案.&lt;br&gt;前端工程化迫在眉捷. 而且有以下要求:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最好是纯 Javascript 方案&lt;/li&gt;
&lt;li&gt;支持模块化&lt;/li&gt;
&lt;li&gt;业务代码与框架代码分离&lt;/li&gt;
&lt;li&gt;可测性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是, 产生了几种不同的演进方案.&lt;br&gt;后端渲染技术:&lt;br&gt;ajax -&amp;gt; pjax -&amp;gt; sjr ( 需要服务端提供支持 )&lt;br&gt;后端渲染技术很快就发展到顶了. 但技术理解还是足够简单的. 我们还是回到前端框架上.&lt;br&gt;NodeJS, AMD(CMD), ES6 的出现, 使得组织起一个前端框架成为现实. 于是乎, 百团大战, 出现了上面众多框架混战的画面.&lt;br&gt;无论是 AngularJS, EmberJS, ReactJS, VueJS 都是围绕着这几点进行的不同的尝试.&lt;br&gt;但结果如何, 我们站在一个更高的高度重新思考 web 开发.      &lt;/p&gt;
&lt;h3 id=&quot;真正的用户市场需要什么&quot;&gt;&lt;a href=&quot;#真正的用户市场需要什么&quot; class=&quot;headerlink&quot; title=&quot;真正的用户市场需要什么&quot;&gt;&lt;/a&gt;真正的用户市场需要什么&lt;/h3&gt;&lt;p&gt;对用户   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更快的响应速度&lt;/li&gt;
&lt;li&gt;更好的体验&lt;br&gt;对开发者&lt;/li&gt;
&lt;li&gt;更快的开发速度&lt;/li&gt;
&lt;li&gt;更好的可维护性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再次思考, 我们要不要前后端分离? 哪些前端框架更满足我们以上的条件?&lt;br&gt;作为 Rails 工程师, 我也一直在思考一个问题: Rails 是否在前端上走上了绝路?&lt;br&gt;对于不熟悉 Rails 的朋友, 我还是简单回顾下 Rails 的前端是什么:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jQuery&lt;/li&gt;
&lt;li&gt;UJS&lt;/li&gt;
&lt;li&gt;Assets pipeline&lt;/li&gt;
&lt;li&gt;SJR( 服务端 JS 生成技术 )&lt;/li&gt;
&lt;li&gt;Turoblinks( 一种极小成本实现的单页效果的技术 )&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相比 php, java, python 等语言下的传统 web 框架来说, Rails 的前端技术还是非常丰富的.&lt;br&gt;关于各个框架我列了一个分数比较, 10 分为满分, 每个列会加在一起算成一个总分.&lt;br&gt; &lt;img src=&quot;http://7xth8v.com2.z0.glb.qiniucdn.com/image/n-web-score-2016.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上表可以看出:&lt;br&gt;Rails 这类的全栈框架特点有&lt;/p&gt;
&lt;p&gt;优势:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发效率极高&lt;/li&gt;
&lt;li&gt;通过 Turoblinks 技术, 体验也不错.&lt;/li&gt;
&lt;li&gt;也能支持混合应用开发&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前端代码可维护差&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ReactJS 学习成本较低, 通过 webpack 与 npm 的配合, 能够达到不错的可维护性, 但开发成本偏高, 这也是组件化的缺点之一.&lt;br&gt;而 EmberJS 学习门槛过高, 而且 EmberJS 发展也比较迅速, 不利于学习掌握, 相对而言, 总分也不会太高.&lt;br&gt;MeteorJS 也被我列在这里, 总分最低, 所以仍然不推荐学习, 除非你的应用属于实时应用.&lt;br&gt;我们再重新思考组件化, 组件化优势在于接口清晰, 可维护性高, 但开发成本是比较高的, 前端属于工程而不是科学, 所以, 我觉得组件化是对的, 但不要过于极端把所有的 dom 都组件化.&lt;br&gt;而且, 组件化也对现有的基础技术栈进行了破坏.&lt;br&gt;通过以上的分析, 我们基本上了解了现有技术栈的情况. 那我们该继续学什么? 这才是本文的重点.&lt;br&gt;所有的一切, 都是围绕着组件化, 可维护, 高效开发, 移动支持而生, 而它们的核心都是还是最基础的东西:     &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Javascript ( ES6, NodeJS )&lt;/li&gt;
&lt;li&gt;HTML&lt;/li&gt;
&lt;li&gt;CSS&lt;/li&gt;
&lt;li&gt;API&lt;br&gt;一句话, 还是应该先把基础打好.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基础技术栈&quot;&gt;&lt;a href=&quot;#基础技术栈&quot; class=&quot;headerlink&quot; title=&quot;基础技术栈&quot;&gt;&lt;/a&gt;基础技术栈&lt;/h3&gt;&lt;p&gt;应当好好掌握的内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Javascript 语言( 直接看 ES6 相关的 )&lt;/li&gt;
&lt;li&gt;NodeJS 生态( npm 与相关的包 )&lt;/li&gt;
&lt;li&gt;webpack ( 了解如何打包, 发布 )&lt;/li&gt;
&lt;li&gt;HTML ( 尤其是 form 标签, 以及 HTML5 的内容 )&lt;/li&gt;
&lt;li&gt;CSS ( 学习盒模型, 最新的 flex 布局, 以及 CSS3 )&lt;/li&gt;
&lt;li&gt;API ( 掌握如何开发 API )&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你必须是前端工程师, 同时又是后端工程师, 才能真正摸清晰当下时代的发展, 成为弄潮儿!&lt;/p&gt;
&lt;h3 id=&quot;预测未来&quot;&gt;&lt;a href=&quot;#预测未来&quot; class=&quot;headerlink&quot; title=&quot;预测未来&quot;&gt;&lt;/a&gt;预测未来&lt;/h3&gt;&lt;p&gt;首先, 我在 2014 年分析 web 开发的文中提到的 gulp, grunt 都已经成为过去式了. Bower 也已经有点不合事宜了.&lt;br&gt;目前前端构建建议使用 webpack 和 npm 足够, 不需要更多的工具链, 应该越简单, 越顺手!&lt;br&gt;列几个关心的问题尝试预测一下.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NodeJS 做后台开发怎么样 ?&lt;br&gt;NodeJS 已经是前端框架的一部分, 是极为成功的, 但对于 NodeJS 做后台开发说实在的, 它能够占一定的市场, 但将会非常少( 低于 5% ). 所以做 php 或 java 开发的朋友倒不用担心, 但如果只是搬砖写简单 API 的话, 就有危险了.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rails 还行不行 ?&lt;br&gt;Rails 已经到了一定的顶点, 不可能再突破性增长, 但仍然是目前最为顺手的 web 开发框架, 它的前端解决方案目前仍有不错的体验与开发效率, 但可维护性比较差, 如果是我的话, 我会带领团队采用混合式的开发, 但现在不会是引入 AngularJS 而会是 VueJS.&lt;br&gt;但 Rails 已经到达它的极限点了, 而众多前端框架才刚刚开始.( 虽然拿 Rails 与前端框架比较不够合适 )    &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AngularJS 还是 ReactJS ?&lt;br&gt;很简单, 建议直接上手 VueJS.&lt;br&gt;AnguarJS 第一版是个好的框架, 但 Angular2 并不是, 所以还不如直接学习 VueJS.&lt;br&gt;ReactJS 是个不错的框架, 但绝不是终点. VueJS 与 ReactJS 在实现上各有利弊. 两者可以择其一学之.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MeteorJS 值不值得学习 ?&lt;br&gt;我的建议是不值得, 因为它一开始就走在错误的道路上, 注定后面无路可走.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;前端会取代 Native APP 开发么?&lt;br&gt;一定会的, 未来 3 年后, 至少有 70% 左右的 APP 会用前端开发方案, 比如使用类似于 Ionic 或 Meteor 这样的框架.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;重新思考-web-开发&quot;&gt;&lt;a href=&quot;#重新思考-web-开发&quot; class=&quot;headerlink&quot; title=&quot;重新思考 web 开发&quot;&gt;&lt;/a&gt;重新思考 web 开发&lt;/h3&gt;&lt;p&gt;真正能长远的前端技术一定是简单的, 专注的, 比如 jQuery. 但目前几个框架都或多或少存在着问题.&lt;br&gt;ReactJS 不是表面那么简单, 而 AngularJS 更加复杂.&lt;br&gt;是否有更简单有效的解决它们的问题, 则能够成为下一代 web 前端框架.    &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Rewriting your Frontend Framework every six week !!!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;近二年的进展&quot;&gt;&lt;a href=&quot;#近二年的进展&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
    
      <category term="随笔" scheme="http://mmrxia.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>git 常用命令汇总</title>
    <link href="http://mmrxia.github.io/2016/06/03/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
    <id>http://mmrxia.github.io/2016/06/03/git-常用命令汇总/</id>
    <published>2016-06-03T06:26:42.000Z</published>
    <updated>2016-07-04T07:53:36.602Z</updated>
    
    <content type="html">&lt;h3 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h3&gt;&lt;p&gt;创建账户：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;git config -global user.name &amp;quot;Your name&amp;quot;
git config -global user.email &amp;quot;you@example.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从仓库克隆到提交文件通用流程：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt; git clone git@github.com:mmrxia/project-name.git
 git add .
 git commit -m &amp;#39;update file&amp;#39;
 git push -u origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看当前git仓库文件状态：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;git status
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;其他技巧&quot;&gt;&lt;a href=&quot;#其他技巧&quot; class=&quot;headerlink&quot; title=&quot;其他技巧&quot;&gt;&lt;/a&gt;其他技巧&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;新建.gitignore文件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;touch .gitignore
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查看文件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;vim README.md
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查看提交历史记录&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;git log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们常用 &lt;code&gt;-p&lt;/code&gt; 选项展开显示每次提交的内容差异，用 &lt;code&gt;-2&lt;/code&gt; 则仅显示最近的两次更新。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h3&gt;&lt;p&gt;创建账户：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-git&quot;&gt;git config -global u
    
    </summary>
    
    
      <category term="git" scheme="http://mmrxia.github.io/tags/git/"/>
    
      <category term="bash" scheme="http://mmrxia.github.io/tags/bash/"/>
    
  </entry>
  
</feed>
