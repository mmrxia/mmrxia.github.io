<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="前端博客 | hexo | github">
<meta property="og:type" content="website">
<meta property="og:title" content="芥子园 | xiaqingsong's blog">
<meta property="og:url" content="http://mmrxia.github.io/index.html">
<meta property="og:site_name" content="芥子园 | xiaqingsong's blog">
<meta property="og:description" content="前端博客 | hexo | github">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="芥子园 | xiaqingsong's blog">
<meta name="twitter:description" content="前端博客 | hexo | github">
    
    <title>
        芥子园 | xiaqingsong&#39;s blog
    </title>
    <link rel="alternative" href="/atom.xml" title="芥子园 | xiaqingsong&#39;s blog" type="application/atom+xml"> 
    <link rel="icon" href="http://7xth8v.com2.z0.glb.clouddn.com/icon/favicon.ico"> 
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/prism.css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xth8v.com2.z0.glb.qiniucdn.com/image/avatar_150x150.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">芥子园</a></h1>
		</hgroup>

		
		<p class="header-subtitle">须弥藏芥子，芥子纳须弥</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/随笔">随笔</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/mmrxia" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/u/1984883035" title="weibo">weibo</a>
					        
								<a class="twitter" target="_blank" href="https://twitter.com/xiaqingsong" title="twitter">twitter</a>
					        
								<a class="linkedin" target="_blank" href="http://www.linkedin.com/in/mrxia" title="linkedin">linkedin</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Linux/" style="font-size: 12.5px;">Linux</a> <a href="/tags/base64/" style="font-size: 10px;">base64</a> <a href="/tags/bash/" style="font-size: 10px;">bash</a> <a href="/tags/bigPipe/" style="font-size: 10px;">bigPipe</a> <a href="/tags/cnpm/" style="font-size: 10px;">cnpm</a> <a href="/tags/express/" style="font-size: 10px;">express</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/javascript/" style="font-size: 17.5px;">javascript</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/mongodb/" style="font-size: 12.5px;">mongodb</a> <a href="/tags/nodejs/" style="font-size: 20px;">nodejs</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/sku/" style="font-size: 10px;">sku</a> <a href="/tags/uuid/" style="font-size: 10px;">uuid</a> <a href="/tags/前端/" style="font-size: 10px;">前端</a> <a href="/tags/数组/" style="font-size: 10px;">数组</a> <a href="/tags/移动端开发/" style="font-size: 10px;">移动端开发</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/西游记/" style="font-size: 12.5px;">西游记</a> <a href="/tags/跨域/" style="font-size: 10px;">跨域</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.xiaqingsong.com">XQS</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.morg.cn">MORG</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.iamaddy.net/">Addy的网络日志</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">夏青松，2013年毕业于江西农大软件学院软件工程专业。<br/> <b>2012.10-2015.2</b> [北京] 锐捷网络<br/> <b>2015.2-至今</b> [杭州] 妈妈好网络<br/><br/> Mail：this.xqs@gmail.com </div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">芥子园</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xth8v.com2.z0.glb.qiniucdn.com/image/avatar_150x150.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">芥子园</h1>
			</hgroup>
			
			<p class="header-subtitle">须弥藏芥子，芥子纳须弥</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/mmrxia" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/1984883035" title="weibo">weibo</a>
			        
						<a class="twitter" target="_blank" href="https://twitter.com/xiaqingsong" title="twitter">twitter</a>
			        
						<a class="linkedin" target="_blank" href="http://www.linkedin.com/in/mrxia" title="linkedin">linkedin</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-javascript类型判断" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/12/22/javascript类型判断/" class="article-date">
  	<time datetime="2016-12-22T09:50:03.000Z" itemprop="datePublished">2016-12-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/22/javascript类型判断/">javascript类型判断</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>JavaScript 中所有变量都是对象，除了两个例外 null 和 undefined。</p>
</blockquote>
<p>理解Javascript的类型是学习Javascript的基础，但是作为新手很容易在判断Javascript上容易混淆。很容易被上面这句话误导，首先解释下上面这句话。</p>
<pre><code class="language-javascript">false.toString(); // &#39;false&#39;
[1, 2, 3].toString(); // &#39;1,2,3&#39;
(2).toString(); // &#39;2&#39;
</code></pre>
<p>通过上面的代码，可以看出布尔、数组、数字都具有toString()这一方法，其实除了null和undefined外的数据类型都继承自Object对象都具Object的方法和属性，这些看似非对象的类型使用起来却很像对象，所以也可以说它们都是对象。可是Javascript依然具有类型，我想大致可以分成下面几类：</p>
<ul>
<li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>Object</li>
<li>Null</li>
<li>Undefined</li>
</ul>
<p>Number、String、Boolean、Null、Undefined都是是基本数据类型，只有Object属于复杂数据类型。<br>Null和Undefined都表示空，它们的区别在于：Null表示无值，一般是人为的将变量的值设置为null；Undefined表示未知值，一般在使用var声明变量但未对其加以初始化时，这个变量值为undefined。</p>
<p>Object又分为以下几种类型：</p>
<ul>
<li>Function</li>
<li>Array</li>
<li>Date</li>
<li>RegExp</li>
</ul>
<h4 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h4><p>typeof操作符（和instanceof一起）或许是 JavaScript 中最大的设计缺陷， 因为几乎不可能从它们那里得到想要的结果。</p>
<pre><code class="language-javascript">typeof []; // object
typeof {}; // object
typeof &#39;&#39;; // string
typeof new Date() // object
typeof 1; // number
typeof function () {}; // function
typeof /test/i; // object
typeof true; // boolean
typeof null; // object
typeof undefined; // undefined
</code></pre>
<p>为什么？function明明是Object类型，却显示function；null明明是Null类型，却显示’object’。所以typeof操作符对类型的判断是不靠谱的，除非类型在给定的范围且typeof确实能够区分这些类型。</p>
<h4 id="类型的区分"><a href="#类型的区分" class="headerlink" title="类型的区分"></a>类型的区分</h4><p>Javascript标准标准文档给出了区分类型的办法：</p>
<pre><code class="language-javascript">Object.prototype.toString.call();
</code></pre>
<p>我们来看看上面的方法输出结果：</p>
<pre><code class="language-javascript">Object.prototype.toString.call([]); // [object Array]
Object.prototype.toString.call({}); // [object Object]
Object.prototype.toString.call(&#39;&#39;); // [object String]
Object.prototype.toString.call(new Date()); // [object Date]
Object.prototype.toString.call(1); // [object Number]
Object.prototype.toString.call(function () {}); // [object Function]
Object.prototype.toString.call(/test/i); // [object RegExp]
Object.prototype.toString.call(true); // [object Boolean]
Object.prototype.toString.call(null); // [object Null]
Object.prototype.toString.call(); // [object Undefined]
</code></pre>
<p>利用上面判断类型的方法可以写个类库，此类库来自(Axis.js)[//github.com/toddmotto/axis]:</p>
<pre><code class="language-javascript">(function (root, factory) {
  // 判断是否使用了模块
  if (typeof define === &#39;function&#39; &amp;&amp; define.amd) {
    // 使用AMD模块
    define(factory);
  } else if (typeof exports === &#39;object&#39;) {
    // 使用CMD模块
    module.exports = factory;
  } else {
    // 没有使用模块，放在全局下
    root.axis = factory();
  }
})(this, function () {
  // 严格模式
  &#39;use strict&#39;;
  var exports = {};
  // 将字符串转为数组
  var types = &#39;Array Object String Date RegExp Function Boolean Number Null Undefined&#39;.split(&#39; &#39;);
  // 判断类型
  var type = function () {
    return Object.prototype.toString.call(this).slice(8, -1);
  };
  // 遍历types，为exports对象添加isArray、isObject...等方法
  for (var i = types.length; i--;) {
    exports[&#39;is&#39; + types[i]] = (function (self) {
      return function (elem) {
        // type.call(elem)将type方法里的this指针指向elem
        return type.call(elem) === self;
      };
    })(types[i]);
  }
  return exports;
});
</code></pre>
<p>使用方法也很简单：</p>
<pre><code class="language-javascript">axis.isArray([]); // true
axis.isObject({}); // true
axis.isString(&#39;&#39;); // true
axis.isDate(new Date()); // true
axis.isRegExp(/test/i); // true
axis.isFunction(function () {}); // true
axis.isBoolean(true); // true
axis.isNumber(1); // true
axis.isNull(null); // true
axis.isUndefined(); // true
</code></pre>
<p>参考链接：</p>
<ul>
<li><a href="http://toddmotto.com/understanding-javascript-types-and-reliable-type-checking/" target="_blank" rel="external">http://toddmotto.com/understanding-javascript-types-and-reliable-type-checking/</a></li>
<li><a href="http://bonsaiden.github.io/JavaScript-Garden/" target="_blank" rel="external">http://bonsaiden.github.io/JavaScript-Garden/</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-只用20行写一个javascript模板引擎" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/12/22/只用20行写一个javascript模板引擎/" class="article-date">
  	<time datetime="2016-12-22T07:18:12.000Z" itemprop="datePublished">2016-12-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/22/只用20行写一个javascript模板引擎/">只用20行写一个javascript模板引擎</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>译文链接：<a href="原文链接：JavaScript template engine in just 20 lines">JavaScript template engine in just 20 lines</a></p>
</blockquote>
<p>最初我的想法是这样子的：</p>
<pre><code class="language-javascript">var TemplateEngine = function(tpl, data) {
    // magic here ...
}
var template = &#39;&lt;p&gt;Hello, my name is &lt;%name%&gt;. I\&#39;m &lt;%age%&gt; years old.&lt;/p&gt;&#39;;
console.log(TemplateEngine(template, {
    name: &quot;Krasimir&quot;,
    age: 29
}));
</code></pre>
<p>一个简单的函数，输入是我们的模板以及数据对象，输出么估计你也很容易想到，像下面这样子：</p>
<pre><code class="language-javascript">&lt;p&gt;Hello, my name is Krasimir. I&#39;m 29 years old.&lt;/p&gt;
</code></pre>
<p>其中第一步要做的是寻找里面的模板参数，然后替换成传给引擎的具体数据。我决定使用正则表达式来完成这一步。不过正则不是我的强项，所以大家将就一下，如果有更好的正则也欢迎向我提出。</p>
<pre><code class="language-javascript">var re = /&lt;%([^%&gt;]+)?%&gt;/g;
</code></pre>
<p>这句正则表达式会捕获所有以<code>&lt;%</code>开头，以<code>%&gt;</code>结尾的片段。末尾的参数<code>g</code>（global）表示不只匹配一个，而是匹配所有符合的片段。<br>Javascript里面有很多种使用正则表达式的方法，我们需要的是根据正则表达式输出一个数组，包含所有的字符串，这正是<code>exec</code>所做的。</p>
<pre><code class="language-javascript">var re = /&lt;%([^%&gt;]+)?%&gt;/g;
var match = re.exec(tpl);
</code></pre>
<p>如果我们用<code>console.log</code>把变量<code>match</code>打印出来，我们会看见：</p>
<pre><code class="language-javascript">[
    &quot;&lt;%name%&gt;&quot;,
    &quot; name &quot;, 
    index: 21,
    input: 
    &quot;&lt;p&gt;Hello, my name is &lt;%name%&gt;. I\&#39;m &lt;%age%&gt; years old.&lt;/p&gt;&quot;
]
</code></pre>
<p>不过我们可以看见，返回的数组仅仅包含第一个匹配项。我们需要用<code>while</code>循环把上述逻辑包起来，这样才能得到所有的匹配项。</p>
<pre><code class="language-javascript">var re = /&lt;%([^%&gt;]+)?%&gt;/g;
while(match = re.exec(tpl)) {
    console.log(match);
}
</code></pre>
<p>如果把上面的代码跑一遍，你就会看见<code>&lt;%name%&gt;</code> 和 <code>&lt;%age%&gt;</code>都被打印出来了。</p>
<p>下面，有意思的部分来了。识别出模板中的匹配项后，我们要把他们替换成传递给函数的实际数据。最简单的办法就是使用<code>replace</code>函数。我们可以像这样来写：</p>
<pre><code class="language-javascript">var TemplateEngine = function(tpl, data) {
    var re = /&lt;%([^%&gt;]+)?%&gt;/g;
    while(match = re.exec(tpl)) {
        tpl = tpl.replace(match[0], data[match[1]])
    }
    return tpl;
}
</code></pre>
<p>好了，这样就能跑了，但是还不够好。这里我们以<code>data[&quot;property&quot;]</code>的方式使用了一个简单对象来传递数据，但是实际情况下我们很可能需要更复杂的嵌套对象。所以我们稍微修改了一下<code>data</code>对象：</p>
<pre><code class="language-javascript">{
    name: &quot;Krasimir Tsonev&quot;,
    profile: { age: 29 }
}
</code></pre>
<p>不过直接这样子写的话还不能跑，因为在模板中使用<code>&lt;%profile.age%&gt;</code>的话，代码会被替换成<code>data[&#39;profile.age&#39;]</code>，结果是<code>undefined</code>。<br>这样我们就不能简单地用<code>replace</code>函数，而是要用别的方法。如果能够在<code>&lt;%</code>和<code>%&gt;</code>之间直接使用Javascript代码就最好了，这样就能对传入的数据直接求值，像下面这样：</p>
<pre><code class="language-javascript">var template = &#39;&lt;p&gt;Hello, my name is &lt;%this.name%&gt;. I\&#39;m &lt;%this.profile.age%&gt; years old.&lt;/p&gt;&#39;;
</code></pre>
<p>你可能会好奇，这是怎么实现的？这里<a href="http://ejohn.org/blog/javascript-micro-templating/" target="_blank" rel="external">John</a>使用了<code>new Function</code>的语法，根据字符串创建一个函数。我们不妨来看个例子：</p>
<pre><code class="language-javascript">var fn = new Function(&quot;arg&quot;, &quot;console.log(arg + 1);&quot;);
fn(2); // outputs 3
</code></pre>
<p><code>fn</code>可是一个货真价实的函数。它接受一个参数，函数体是<code>console.log(arg + 1)</code>;。上述代码等价于下面的代码：</p>
<pre><code class="language-javascript">var fn = function(arg) {
    console.log(arg + 1);
}
fn(2); // outputs 3
</code></pre>
<p>通过这种方法，我们可以根据字符串构造函数，包括它的参数和函数体。这不正是我们想要的嘛！不过先别急，在构造函数之前，我们先来看看函数体是什么样子的。<br>按照之前的想法，这个模板引擎最终返回的应该是一个编译好的模板。还是用之前的模板字符串作为例子，那么返回的内容应该类似于：</p>
<pre><code class="language-javascript">return 
&quot;&lt;p&gt;Hello, my name is &quot; + 
this.name + 
&quot;. I\&#39;m &quot; + 
this.profile.age + 
&quot; years old.&lt;/p&gt;&quot;;
</code></pre>
<p>当然啦，实际的模板引擎中，我们会把模板切分为小段的文本和有意义的Javascript代码。前面你可能看见我使用简单的字符串拼接来达到想要的效果，不过这并不是100%符合我们要求的做法。<br>由于使用者很可能会传递更加复杂的Javascript代码，所以我们这儿需要再来一个循环，如下：</p>
<pre><code class="language-javascript">var template = 
&#39;My skills:&#39; + 
&#39;&lt;%for(var index in this.skills) {%>' + 
'<a href=""><%this.skills[index]%></%this.skills[index]%></a>' +
'<%}%&gt;&#39;; <="" code=""></%}%&gt;&#39;;></code></pre>
<p>如果使用字符串拼接的话，代码就应该是下面的样子：</p>
<pre><code class="language-javascript">return
&#39;My skills:&#39; + 
for(var index in this.skills) { +
&#39;&lt;a href=&quot;&quot;&gt;&#39; + 
this.skills[index] +
&#39;&lt;/a&gt;&#39; +
}
</code></pre>
<p>当然，这个代码不能直接跑，跑了会出错。于是我用了<a href="http://ejohn.org/blog/javascript-micro-templating/" target="_blank" rel="external">John的文章</a>里写的逻辑，把所有的字符串放在一个数组里，在程序的最后把它们拼接起来。</p>
<pre><code class="language-javascript">var r = [];
r.push(&#39;My skills:&#39;); 
for(var index in this.skills) {
r.push(&#39;&lt;a href=&quot;&quot;&gt;&#39;);
r.push(this.skills[index]);
r.push(&#39;&lt;/a&gt;&#39;);
}
return r.join(&#39;&#39;);
</code></pre>
<p>下一步就是收集模板里面不同的代码行，用于生成函数。通过前面介绍的方法，我们可以知道模板中有哪些占位符（译者注：或者说正则表达式的匹配项）以及它们的位置。<br>所以，依靠一个辅助变量（cursor，游标），我们就能得到想要的结果。</p>
<pre><code class="language-javascript">var TemplateEngine = function(tpl, data) {
    var re = /&lt;%([^%&gt;]+)?%&gt;/g,
        code = &#39;var r=[];\n&#39;,
        cursor = 0;
    var add = function(line) {
        code += &#39;r.push(&quot;&#39; + line.replace(/&quot;/g, &#39;\\&quot;&#39;) + &#39;&quot;);\n&#39;;
    }
    while(match = re.exec(tpl)) {
        add(tpl.slice(cursor, match.index));
        add(match[1]);
        cursor = match.index + match[0].length;
    }
    add(tpl.substr(cursor, tpl.length - cursor));
    code += &#39;return r.join(&quot;&quot;);&#39;; // &lt;-- return the result
    console.log(code);
    return tpl;
}
var template = &#39;&lt;p&gt;Hello, my name is &lt;%this.name%&gt;. I\&#39;m &lt;%this.profile.age%&gt; years old.&lt;/p&gt;&#39;;
console.log(TemplateEngine(template, {
    name: &quot;Krasimir Tsonev&quot;,
    profile: { age: 29 }
}));
</code></pre>
<p>上述代码中的变量code保存了函数体。开头的部分定义了一个数组。游标<code>cursor</code>告诉我们当前解析到了模板中的哪个位置。我们需要依靠它来遍历整个模板字符串。<br>此外还有个函数<code>add</code>，它负责把解析出来的代码行添加到变量<code>code</code>中去。有一个地方需要特别注意，那就是需要把<code>code</code>包含的双引号字符进行转义（escape）。否则生成的函数代码会出错。<br>如果我们运行上面的代码，我们会在控制台里面看见如下的内容：</p>
<pre><code class="language-javascript">var r=[];
r.push(&quot;&lt;p&gt;Hello, my name is &quot;);
r.push(&quot;this.name&quot;);
r.push(&quot;. I&#39;m &quot;);
r.push(&quot;this.profile.age&quot;);
return r.join(&quot;&quot;);
</code></pre>
<p>等等，貌似不太对啊，<code>this.name</code>和<code>this.profile.age</code>不应该有引号啊，再来改改。</p>
<pre><code class="language-javascript">var add = function(line, js) {
    js? code += &#39;r.push(&#39; + line + &#39;);\n&#39; :
        code += &#39;r.push(&quot;&#39; + line.replace(/&quot;/g, &#39;\\&quot;&#39;) + &#39;&quot;);\n&#39;;
}
while(match = re.exec(tpl)) {
    add(tpl.slice(cursor, match.index));
    add(match[1], true); // &lt;-- say that this is actually valid js
    cursor = match.index + match[0].length;
}
</code></pre>
<p>占位符的内容和一个布尔值一起作为参数传给<code>add</code>函数，用作区分。这样就能生成我们想要的函数体了。</p>
<pre><code class="language-javascript">var r=[];
r.push(&quot;&lt;p&gt;Hello, my name is &quot;);
r.push(this.name);
r.push(&quot;. I&#39;m &quot;);
r.push(this.profile.age);
return r.join(&quot;&quot;);
</code></pre>
<p>剩下来要做的就是创建函数并且执行它。因此，在模板引擎的最后，把原本返回模板字符串的语句替换成如下的内容：</p>
<pre><code class="language-javascript">return new Function(code.replace(/[\r\t\n]/g, &#39;&#39;)).apply(data);
</code></pre>
<p>我们甚至不需要显式地传参数给这个函数。我们使用<code>apply</code>方法来调用它。它会自动设定函数执行的上下文。这就是为什么我们能在函数里面使用<code>this.name</code>。这里<code>this</code>指向<code>data</code>对象。</p>
<p>模板引擎接近完成了，不过还有一点，我们需要支持更多复杂的语句，比如条件判断和循环。我们接着上面的例子继续写。</p>
<pre><code class="language-javascript">var template = 
&#39;My skills:&#39; + 
&#39;&lt;%for(var index in this.skills) {%>' + 
'<a href="#"><%this.skills[index]%></%this.skills[index]%></a>' +
'<%}%&gt;&#39;; console.log(templateengine(template,="" {="" skills:="" [&quot;js&quot;,="" &quot;html&quot;,="" &quot;css&quot;]="" }));="" <="" code=""></%}%&gt;&#39;;></code></pre>
<p>这里会产生一个异常，<code>Uncaught SyntaxError: Unexpected token for</code>。如果我们调试一下，把<code>code</code>变量打印出来，我们就能发现问题所在。</p>
<pre><code class="language-javascript">var r=[];
r.push(&quot;My skills:&quot;);
r.push(for(var index in this.skills) {);
r.push(&quot;&lt;a href=\&quot;\&quot;&gt;&quot;);
r.push(this.skills[index]);
r.push(&quot;&lt;/a&gt;&quot;);
r.push(});
r.push(&quot;&quot;);
return r.join(&quot;&quot;);
</code></pre>
<p>带有<code>for</code>循环的那一行不应该被直接放到数组里面，而是应该作为脚本的一部分直接运行。所以我们在把内容添加到<code>code</code>变量之前还要多做一个判断。</p>
<pre><code class="language-javascript">var re = /&lt;%([^%&gt;]+)?%&gt;/g,
    reExp = /(^( )?(if|for|else|switch|case|break|{|}))(.*)?/g,
    code = &#39;var r=[];\n&#39;,
    cursor = 0;
var add = function(line, js) {
    js? code += line.match(reExp) ? line + &#39;\n&#39; : &#39;r.push(&#39; + line + &#39;);\n&#39; :
        code += &#39;r.push(&quot;&#39; + line.replace(/&quot;/g, &#39;\\&quot;&#39;) + &#39;&quot;);\n&#39;;
}
</code></pre>
<p>这里我们新增加了一个正则表达式。它会判断代码中是否包含<code>if</code>、<code>for</code>、<code>else</code>等等关键字。如果有的话就直接添加到脚本代码中去，否则就添加到数组中去。运行结果如下：</p>
<pre><code class="language-javascript">var r=[];
r.push(&quot;My skills:&quot;);
for(var index in this.skills) {
r.push(&quot;&lt;a href=\&quot;#\&quot;&gt;&quot;);
r.push(this.skills[index]);
r.push(&quot;&lt;/a&gt;&quot;);
}
r.push(&quot;&quot;);
return r.join(&quot;&quot;);
</code></pre>
<p>当然，编译出来的结果也是对的。</p>
<pre><code class="language-javascript">My skills:&lt;a href=&quot;#&quot;&gt;js&lt;/a&gt;&lt;a href=&quot;#&quot;&gt;html&lt;/a&gt;&lt;a href=&quot;#&quot;&gt;css&lt;/a&gt;
</code></pre>
<p>最后一个改进可以使我们的模板引擎更为强大。我们可以直接在模板中使用复杂逻辑，例如：</p>
<pre><code class="language-javascript">var template = 
&#39;My skills:&#39; + 
&#39;&lt;%if(this.showSkills) {%>' +
    '<%for(var index="" in="" this.skills)="" {%="">' + 
    '<a href="#"><%this.skills[index]%></%this.skills[index]%></a>' +
    '<%}%&gt;&#39; +="" &#39;&lt;%}="" else="" {%="">' +
    '<p>none</p>' +
'<%}%&gt;&#39;; console.log(templateengine(template,="" {="" skills:="" [&quot;js&quot;,="" &quot;html&quot;,="" &quot;css&quot;],="" showskills:="" true="" }));="" <="" code=""></%}%&gt;&#39;;></%}%&gt;&#39;></%for(var></code></pre>
<p>除了上面说的改进，我还对代码本身做了些优化，最终版本如下：</p>
<pre><code class="language-javascript">var TemplateEngine = function(html, options) {
    var re = /&lt;%([^%&gt;]+)?%&gt;/g, reExp = /(^( )?(if|for|else|switch|case|break|{|}))(.*)?/g, code = &#39;var r=[];\n&#39;, cursor = 0;
    var add = function(line, js) {
        js? (code += line.match(reExp) ? line + &#39;\n&#39; : &#39;r.push(&#39; + line + &#39;);\n&#39;) :
            (code += line != &#39;&#39; ? &#39;r.push(&quot;&#39; + line.replace(/&quot;/g, &#39;\\&quot;&#39;) + &#39;&quot;);\n&#39; : &#39;&#39;);
        return add;
    }
    while(match = re.exec(html)) {
        add(html.slice(cursor, match.index))(match[1], true);
        cursor = match.index + match[0].length;
    }
    add(html.substr(cursor, html.length - cursor));
    code += &#39;return r.join(&quot;&quot;);&#39;;
    return new Function(code.replace(/[\r\t\n]/g, &#39;&#39;)).apply(options);
}
</code></pre>
<p>代码比我预想的还要少，只有区区15行！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-nodejs中间件connect" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/12/19/nodejs中间件connect/" class="article-date">
  	<time datetime="2016-12-19T03:19:21.000Z" itemprop="datePublished">2016-12-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/19/nodejs中间件connect/">nodejs中间件connect</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="什么是connect？"><a href="#什么是connect？" class="headerlink" title="什么是connect？"></a>什么是connect？</h4><p>Connect 是Node.js中的一个模块，可以用来创建中间件的一个框架，它自身已经包装了Node的HTTP模块的Server以及Server的req和res的对象。<br>它干的活其实就是处理请求，然后响应客户端或是让下一个中间件继续处理，它的原型是这个样子的:</p>
<pre><code class="language-javascript">function (req, res, next) {
  // 中间件
}
</code></pre>
<p>当next回调函数被调用，中间件就完成工作并传递到下一个中间件，如果没其他中间件则进入到应用逻辑继续执行。</p>
<p><code>logger</code>: 用户请求日志中间件<br><code>csrf</code>: 跨域请求伪造保护中间件<br><code>compress</code>: gzip压缩中间件<br><code>basicAuth</code>: basic认证中间件<br><code>bodyParser</code>: 请求内容解析中间件<br><code>json</code>: JSON解析中间件<br><code>urlencoded</code>: application/x-www-form-urlencode请求解析中间件<br><code>multipart</code>: multipart/form-data请求解析中间件<br><code>timeout</code>: 请求超时中间件<br><code>cookieParser</code>: cookie解析中间件<br><code>session</code>: 会话管理中间件<br><code>cookieSession</code>: 基于cookies的会话中间件<br><code>methodOverride</code>: HTTP伪造中间件<br><code>reponseTime</code>: 计算响应时间中间件<br><code>staticCache</code>: 缓存中间件<br><code>static</code>: 静态文件处理中间件<br><code>directory</code>: 目录列表中间件<br><code>vhost</code>: 虚拟二级域名映射中间件<br><code>favicon</code>: 网页图标中间件<br><code>limit</code>: 请求内容大小限制中间件<br><code>query</code>: URL解析中间件<br><code>errorHadnler</code>: 错误处理中间件</p>
<p>参考: <a href="http://blog.fens.me/nodejs-connect/" target="_blank" rel="external">http://blog.fens.me/nodejs-connect/</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nodejs/">nodejs</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-mongoose学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/12/16/mongoose学习笔记/" class="article-date">
  	<time datetime="2016-12-16T08:54:48.000Z" itemprop="datePublished">2016-12-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/16/mongoose学习笔记/">mongoose学习笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、快速通道"><a href="#一、快速通道" class="headerlink" title="一、快速通道"></a>一、快速通道</h2><h3 id="1-名词解释"><a href="#1-名词解释" class="headerlink" title="1. 名词解释"></a>1. 名词解释</h3><p>Schema（模式）: 一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力。<br>Model（模型）: 源于Schema生成的模型，具有抽象属性和行为的数据库操作对。<br>Entity（实体）: 源于Model创建的实体，操作可影响数据库。</p>
<blockquote>
<p>注意：<br>  1 . 本学习文档采用严格命名方式来区别不同对象，例如：</p>
<pre><code class="language-javascript">  var PersonSchema;   //Person的文本属性
  var PersonModel;    //Person的数据库模型
  var PersonEntity;   //Person实体
</code></pre>
<p>  2 . Schema –&gt; Model，Model –&gt; Entity。Model和Entity都可对数据库操作造成影响，但Model比Entity更具操作性。</p>
</blockquote>
<h3 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h3><p>1 . 首先你必须安装MongoDB和NodeJS<br>  mongodb安装可参考： <a href="http://blog.xiaqingsong.com/2016/12/16/windows%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmongodb/" target="_blank" rel="external">windows下安装配置mongodb</a></p>
<p>2 . 在项目只能够创建一个数据库连接，如下:</p>
<pre><code class="language-javascript">var mongoose = require(&#39;mongoose&#39;);    //引用mongoose模块
var db = mongoose.createConnection(&#39;localhost&#39;,&#39;test&#39;); //创建一个数据库连接
</code></pre>
<p>3 . 打开本机localhost的test数据库时，我们可以监测是否有异常</p>
<pre><code class="language-javascript">db.on(&#39;error&#39;,console.error.bind(console,&#39;连接错误:&#39;));
db.once(&#39;open&#39;,function(){
  //mongodb connected!
});
</code></pre>
<blockquote>
<p>注意：<br>  成功开启数据库后，就可以执行数据库相应操作，假设以下代码都在回调中处理</p>
</blockquote>
<p>4 . 定义一个Schema</p>
<pre><code class="language-javascript">var PersonSchema = new mongoose.Schema({
  name:String   //定义一个属性name，类型为String
});
</code></pre>
<p>5 . 将该Schema发布为Model</p>
<pre><code class="language-javascript">var PersonModel = db.model(&#39;Person&#39;,PersonSchema);
//如果该Model已经发布，则可以直接通过名字索引到，如下：
//var PersonModel = db.model(&#39;Person&#39;);
//如果没有发布，上一段代码将会异常
</code></pre>
<p>6 . 用Model创建Entity</p>
<pre><code class="language-javascript">var personEntity = new PersonModel({name:&#39;Krouky&#39;});
//打印这个实体的名字看看
console.log(personEntity.name); //Krouky
</code></pre>
<p>7 . 我们甚至可以为此Schema创建方法</p>
<pre><code class="language-javascript">//为Schema模型追加speak方法
PersonSchema.methos.speak = function(){
  console.log(&#39;我的名字叫&#39;+this.name);
}
var PersonModel = db.model(&#39;Person&#39;,PersonSchema);
var personEntity = new PersonModel({name:&#39;Krouky&#39;});
personEntity.speak();//我的名字叫Krouky
</code></pre>
<p>8 . Entity是具有具体的数据库操作CRUD的</p>
<pre><code class="language-javascript">personEntity.save();  //执行完成后，数据库就有该数据了
</code></pre>
<p>9 . 如果要执行查询，需要依赖Model，当然Entity也是可以做到的</p>
<pre><code class="language-javascript">PersonModel.find(function(err,persons){
  //查询到的所有person
});
</code></pre>
<blockquote>
<p>注意：<br>  1 . 具体的如何配置Schema、Model以及Model和Entity的相关操作，我们会在后面进行<br>  2 . Model和Entity都有能影响数据库的操作，但仍有区别，后面我们也会做解释</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mongodb/">mongodb</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-windows下安装配置mongodb" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/12/16/windows下安装配置mongodb/" class="article-date">
  	<time datetime="2016-12-16T06:36:29.000Z" itemprop="datePublished">2016-12-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/16/windows下安装配置mongodb/">windows下安装配置mongodb</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>安装文件：官方网站 <a href="http://www.mongodb.org/downloads" target="_blank" rel="external">http://www.mongodb.org/downloads</a><br>选择对应系统的文件下载。</p>
<h3 id="一、解压缩文件。"><a href="#一、解压缩文件。" class="headerlink" title="一、解压缩文件。"></a>一、解压缩文件。</h3><p>  将压缩包解压，在D盘创建文件夹<code>mongodb</code>,将压缩包解压到<code>mongodb</code>文件夹中。</p>
<h3 id="二、建立工作目录。"><a href="#二、建立工作目录。" class="headerlink" title="二、建立工作目录。"></a>二、建立工作目录。</h3><p>  1、建立数据存放目录  <code>D:\mongodb\data\db</code><br>  2、建立日志文件  <code>D:\mongodb\db\log\mongodb.log</code></p>
<h3 id="三、建立配置文件。"><a href="#三、建立配置文件。" class="headerlink" title="三、建立配置文件。"></a>三、建立配置文件。</h3><p><code>mongodb</code>文件夹下建立<code>mongodb.cfg</code>文件，输入以下内容：</p>
<pre><code class="language-git">dbpath=D:\MongoDB\data #数据库路径
logpath=D:\MongoDB\logs\mongodb.log #日志输出文件路径
logappend=true #错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件
journal=true #启用日志文件，默认启用
quiet=true #这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false
port=27017 #端口号 默认为27017
</code></pre>
<p>这里仅指定了几个常用项，更多详细配置请参考官方文档 <a href="http://docs.mongodb.org/manual/reference/configuration-options/" target="_blank" rel="external">http://docs.mongodb.org/manual/reference/configuration-options/</a></p>
<h3 id="四、启动mongdb服务。"><a href="#四、启动mongdb服务。" class="headerlink" title="四、启动mongdb服务。"></a>四、启动mongdb服务。</h3><p>至此<code>mongodb</code>文件夹下有文件夹及文件：</p>
<pre><code class="language-git">D:\ mongodb\bin
D:\ mongodb\data\db
D:\ mongodb\data\log
</code></pre>
<p>配置文件和相关目录建好后使用如下方式启动mongodb：</p>
<p>控制台进入<code>D:\ mongodb\bin</code>目录，执行以下命令:</p>
<p>1 . 普通启动 </p>
<pre><code class="language-git">mongod --config D:\mongodb\mongodb.cfg
</code></pre>
<p>2 . 安装为Windows服务</p>
<pre><code class="language-git">mongod --config D:\mongodb\mongodb.cfg --install
</code></pre>
<p>注：2.6版 这种方式在win7、win8 64位版无法安装成功，其他系统未测试<br>BUG链接 <a href="https://jira.mongodb.org/browse/SERVER-13515" target="_blank" rel="external">https://jira.mongodb.org/browse/SERVER-13515</a></p>
<p>3 . 使用SC命令安装为Windows服务</p>
<pre><code class="language-git">sc create MongoDB binPath= &quot;D:\mongodb\bin\mongod.exe --service --config=D:\mongodb\mongodb.cfg&quot;
</code></pre>
<h3 id="五、系统服务启动与删除。"><a href="#五、系统服务启动与删除。" class="headerlink" title="五、系统服务启动与删除。"></a>五、系统服务启动与删除。</h3><pre><code class="language-git">net start MongoDB  //启动MongoDB服务  
net stop MongoDB  //停止MongoDB服务   
mongod --remove  //移除MongoDB服务 
sc delete MongoDB   //通过该方式删除的话，服务中的 mongod仍会存在，注册表中不存在了，再重启之后服务的mongodb才会消失
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mongodb/">mongodb</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-bigPipe方案实现及剖析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/16/bigPipe方案实现及剖析/" class="article-date">
  	<time datetime="2016-11-16T09:24:43.000Z" itemprop="datePublished">2016-11-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/16/bigPipe方案实现及剖析/">bigPipe方案实现及剖析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>2010 年初的时候，Facebook 的前端性能研究小组开始了他们的优化项目，经过了六个月的努力，成功的将个人空间主页面加载耗时由原来的5 秒减少为现在的2.5 秒。<br>这是一个非常了不起的成就，也给用户来带来了很好的体验。在优化项目中，工程师提出了一种新的页面加载技术，称之为Bigpipe。<br>目前淘宝和Facebook面临的问题非常相似：海量数据和页面过大，如果可以在详情页、列表页中使用bigpipe，将会带来明显的页面加载速度提升。</p>
<h2 id="相关介绍"><a href="#相关介绍" class="headerlink" title="相关介绍"></a>相关介绍</h2><p>一、BigPipe与AJAX</p>
<p>Web2.0的重要特征是网页显示大量动态内容，即web2.0注重网页与用户的交互。其核心技术是AJAX，如今所有主流网站都或多或少使用AJAX。与AJAX类似，BigPipe 实现了分块儿的概念，使页面能够分步输出，即每次输出一部分网页内容。接下来讨论BigPipe 与AJAX 的区别。</p>
<p>简单的说，BigPipe 比AJAX 有三个好处：</p>
<p>1 . AJAX 的核心是XMLHttpRequest，客户端需要异步的向服务器端发送请求，然后将传送过来的内容动态添加到网页上。如此实现存在一些缺陷，即发送往返请求需要耗费时间，而BigPipe 技术使浏览器并不需要发送XMLHttpRequest 请求，这样就节省时间损耗。</p>
<p>2 . 使用AJAX时，浏览器和服务器的工作顺序执行。服务器必须等待浏览器的请求，这样就会造成服务器的空闲。浏览器工作时，服务器在等待，而服务器工作时，浏览器在等待，这也是一种性能的浪费。使用BigPipe，浏览器和服务器可以并行同时工作，服务器不需要等待浏览器的请求，而是一直处于加载页面内容的工作阶段，这就会使效率得到更大的提高。</p>
<p>3 . 减少浏览器发送到请求。对一个5亿用户的网站来说，减少了使用AJAX额外带来的请求，会减少服务器的负载，同样会带来很大的性能提升。</p>
<p>基于以上三点，Facebook 在进行页面优化时采用了BigPipe 技术。目前淘宝主搜索结果页中，需要加载类目，相关搜索，宝贝列表，广告等内容，前端这里使用php 的curl 的批处理来并发的访问引擎获取相应的数据，并进行分步输出。这种模式还是与bigpipe有些不同，这点后面会讲到。一般来讲，在页面比较大，而且比较复杂，样式表和脚本比较多的情况下，使用BigPipe 来优化输出页面是比较合适的。另外非常重要的一点，BigPipe 并不改变浏览器的结构与网络协议，仅使用JS就可以实现，用户不需要做任何的设置，就会看到明显的访问时间缩短。</p>
<p><a href="http://www.searchtb.com/2011/04/an-introduction-to-bigpipe.html" target="_blank" rel="external">http://www.searchtb.com/2011/04/an-introduction-to-bigpipe.html</a></p>
<p>待续…</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/bigPipe/">bigPipe</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nodejs/">nodejs</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-js-encode或decode-base64格式的字符串" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/16/js-encode或decode-base64格式的字符串/" class="article-date">
  	<time datetime="2016-11-16T08:50:07.000Z" itemprop="datePublished">2016-11-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/16/js-encode或decode-base64格式的字符串/">js encode或decode base64格式的字符串</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="方式一：Chrome、FireFox等现代主流浏览器或IE10及以上版本。"><a href="#方式一：Chrome、FireFox等现代主流浏览器或IE10及以上版本。" class="headerlink" title="方式一：Chrome、FireFox等现代主流浏览器或IE10及以上版本。"></a>方式一：Chrome、FireFox等现代主流浏览器或IE10及以上版本。</h4><pre><code class="language-javascript">// 测试字符
var string = &#39;Hello World!&#39;;

// 加密
var encodedString = btoa(string);
console.log(encodedString); // 输出: &quot;SGVsbG8gV29ybGQh&quot;

// 解密
var decodedString = atob(encodedString);
console.log(decodedString); // 输出: &quot;Hello World!&quot;
</code></pre>
<h4 id="方式二：跨浏览器的方法（压缩版本）"><a href="#方式二：跨浏览器的方法（压缩版本）" class="headerlink" title="方式二：跨浏览器的方法（压缩版本）"></a>方式二：跨浏览器的方法（压缩版本）</h4><pre><code class="language-javascript">// 定义Base64对象
var Base64={_keyStr:&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;,encode:function(e){var t=&quot;&quot;;var n,r,i,s,o,u,a;var f=0;e=Base64._utf8_encode(e);while(f&lt;e.length){n=e.charCodeAt(f++);r=e.charCodeAt(f++);i=e.charCodeAt(f++);s=n&gt;&gt;2;o=(n&amp;3)&lt;&lt;4|r&gt;&gt;4;u=(r&amp;15)&lt;&lt;2|i&gt;&gt;6;a=i&amp;63;if(isNaN(r)){u=a=64}else if(isNaN(i)){a=64}t=t+this._keyStr.charAt(s)+this._keyStr.charAt(o)+this._keyStr.charAt(u)+this._keyStr.charAt(a)}return t},decode:function(e){var t=&quot;&quot;;var n,r,i;var s,o,u,a;var f=0;e=e.replace(/[^A-Za-z0-9+/=]/g,&quot;&quot;);while(f&lt;e.length){s=this._keyStr.indexOf(e.charAt(f++));o=this._keyStr.indexOf(e.charAt(f++));u=this._keyStr.indexOf(e.charAt(f++));a=this._keyStr.indexOf(e.charAt(f++));n=s&lt;&lt;2|o&gt;&gt;4;r=(o&amp;15)&lt;&lt;4|u&gt;&gt;2;i=(u&amp;3)&lt;&lt;6|a;t=t+String.fromCharCode(n);if(u!=64){t=t+String.fromCharCode(r)}if(a!=64){t=t+String.fromCharCode(i)}}t=Base64._utf8_decode(t);return t},_utf8_encode:function(e){e=e.replace(/rn/g,&quot;n&quot;);var t=&quot;&quot;;for(var n=0;n&lt;e.length;n++){var r=e.charCodeAt(n);if(r&lt;128){t+=String.fromCharCode(r)}else if(r&gt;127&amp;&amp;r&lt;2048){t+=String.fromCharCode(r&gt;&gt;6|192);t+=String.fromCharCode(r&amp;63|128)}else{t+=String.fromCharCode(r&gt;&gt;12|224);t+=String.fromCharCode(r&gt;&gt;6&amp;63|128);t+=String.fromCharCode(r&amp;63|128)}}return t},_utf8_decode:function(e){var t=&quot;&quot;;var n=0;var r=c1=c2=0;while(n&lt;e.length){r=e.charCodeAt(n);if(r&lt;128){t+=String.fromCharCode(r);n++}else if(r&gt;191&amp;&amp;r&lt;224){c2=e.charCodeAt(n+1);t+=String.fromCharCode((r&amp;31)&lt;&lt;6|c2&amp;63);n+=2}else{c2=e.charCodeAt(n+1);c3=e.charCodeAt(n+2);t+=String.fromCharCode((r&amp;15)&lt;&lt;12|(c2&amp;63)&lt;&lt;6|c3&amp;63);n+=3}}return t}}

// 测试字符
var string = &#39;Hello World!&#39;;

// 加密
var encodedString = Base64.encode(string);
console.log(encodedString); // 输出: &quot;SGVsbG8gV29ybGQh&quot;

// 解密
var decodedString = Base64.decode(encodedString);
console.log(decodedString); // 输出: &quot;Hello World!&quot;
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/base64/">base64</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-怎样使用js生成uuid" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/09/01/怎样使用js生成uuid/" class="article-date">
  	<time datetime="2016-09-01T06:57:55.000Z" itemprop="datePublished">2016-09-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/01/怎样使用js生成uuid/">怎样使用js生成uuid</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原问题：<a href="http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript" target="_blank" rel="external">How to create a GUID / UUID in Javascript?</a></p>
<h2 id="Introuction"><a href="#Introuction" class="headerlink" title="Introuction"></a>Introuction</h2><blockquote>
<p>UUID = Universally Unique IDentifier, 全球唯一标识符。</p>
</blockquote>
<p>本来我觉得UUID不是什么事，只是一个唯一性的ID字符串而已。在Stack Overflow上看到这个问题之后，倒开始觉得，也许UUID里也有一些值得去发掘的东西。</p>
<p>于是我想到了这几个问题：</p>
<ul>
<li><a href="#UUID-and-GUID">为什么有UUID和GUID这两个东西</a></li>
<li><a href="#Specification">有什么规范吗</a></li>
<li>好像我曾多次看到过有人讨论某种系统或变成语言下UUID的生成问题，<a href="#UUID-and-implementation">UUID跟系统或者编程语言有关系吗</a></li>
</ul>
<p>带着这些问题，我查找并学习了一番。现在做个整理。</p>
<h2 id="UUID-and-GUID"><a href="#UUID-and-GUID" class="headerlink" title="UUID and GUID"></a>UUID and GUID</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>UUID来自于IETF发布的一个规范：<a href="http://www.ietf.org/rfc/rfc4122.txt" target="_blank" rel="external">A Universally Unique IDentifier (UUID) URN Namespace</a>。</p>
<blockquote>
<p>This specification defines a Uniform Resource Name namespace for UUIDs (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDentifier).  A UUID is 128 bits long, and can guarantee uniqueness across space and time.  UUIDs were originally used in the Apollo Network Computing System and later in the Open Software Foundation’s (OSF) Distributed Computing Environment (DCE), and then in Microsoft Windows platforms.<br>This specification is derived from the DCE specification with the kind permission of the OSF (now known as The Open Group).</p>
</blockquote>
<p>UUID和GUID是同一个东西的两个名字。这两个名字的来源不同。</p>
<ul>
<li>UUID来源于OSF的DCE规范，也就是RFC4122的前身</li>
<li>GUID来源于微软，注意RFC4122的作者之一是微软员工</li>
</ul>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>UUID的出现，是为了在一个复杂的系统中，唯一的标识每个信息实体，同时不需要有一个集中的id管理。也就是说，根据某种规则来为一个信息实体分配一个唯一的id，而且不需要一个id管理器来保证这个id的唯一性。</p>
<p>它可以用来标识任何东西，Microsoft用它来表示Windows中的软件（GUID），Linux用它来表示系统中的文件。</p>
<h2 id="Specification"><a href="#Specification" class="headerlink" title="Specification"></a>Specification</h2><h4 id="UUID格式规范"><a href="#UUID格式规范" class="headerlink" title="UUID格式规范"></a>UUID格式规范</h4><p>这128bits的结构如下所示：</p>
<pre><code>   0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          time_low                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       time_mid                |         time_hi_and_version   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |clk_seq_hi_res |  clk_seq_low  |         node (0-1)            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         node (2-5)                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      time-low               = 4hexOctet
      time-mid               = 2hexOctet
      time-high-and-version  = 2hexOctet    // MOST IMPORTANT !
      clock-seq-and-reserved = hexOctet
      clock-seq-low          = hexOctet
      node                   = 6hexOctet
      hexOctet               = hexDigit hexDigit
      hexDigit =
            &quot;0&quot; / &quot;1&quot; / &quot;2&quot; / &quot;3&quot; / &quot;4&quot; / &quot;5&quot; / &quot;6&quot; / &quot;7&quot; / &quot;8&quot; / &quot;9&quot; /
            &quot;a&quot; / &quot;b&quot; / &quot;c&quot; / &quot;d&quot; / &quot;e&quot; / &quot;f&quot; /
            &quot;A&quot; / &quot;B&quot; / &quot;C&quot; / &quot;D&quot; / &quot;E&quot; / &quot;F&quot;
</code></pre><p>示例：</p>
<pre><code>uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6
</code></pre><h4 id="UUID生成算法"><a href="#UUID生成算法" class="headerlink" title="UUID生成算法"></a>UUID生成算法</h4><p>UUID本身也经过了<a href="http://en.wikipedia.org/wiki/Universally_unique_identifier#Variants_and_versions" target="_blank" rel="external">多个版本的演化</a>。比如node字段的定义，最开始定义为来自IEEE 802 address，演化到后来的<em>a randomly or pseudo-randomly generated 48-bit value</em>。</p>
<p>最新的UUID生成算法是这样的：</p>
<ul>
<li>Set the two most significant bits (bits 6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively.</li>
<li>Set the four most significant bits (bits 12 through 15) of the time_hi_and_version field to the 4-bit version number.</li>
<li>Set all the other bits to randomly (or pseudo-randomly) chosen values.</li>
</ul>
<h2 id="UUID-and-implementation"><a href="#UUID-and-implementation" class="headerlink" title="UUID and implementation"></a>UUID and implementation</h2><p>越来越多的系统中使用着UUID，各自使用目的并不一样。而且由于限定在128bits，UUID规范本身并没有保证UUID真的是在全球唯一的。因此现在对UUID的使用，一般都是限定在一个范围内有唯一性保证，比如一个操作系统内。</p>
<p>因此我们可以看到：</p>
<ul>
<li>微软有一个GUID生成lib：<a href="http://msdn.microsoft.com/en-us/library/system.guid(v=vs.110).aspx" target="_blank" rel="external">http://msdn.microsoft.com/en-us/library/system.guid(v=vs.110).aspx</a></li>
<li>Linux也同样有UUID生成lib：<a href="http://en.wikipedia.org/wiki/Util-linux" target="_blank" rel="external">http://en.wikipedia.org/wiki/Util-linux</a></li>
<li>Android的UUID生成lib：<a href="http://developer.android.com/reference/java/util/UUID.html" target="_blank" rel="external">http://developer.android.com/reference/java/util/UUID.html</a></li>
</ul>
<p>用以上系统对应的UUID生成lib可以确保产生的UUID在系统范围内是唯一的。因此可以用来标识系统资源，比如文件、软件、设备等。</p>
<p>而对于某种具体的编程语言，UUID的使用并没有必要。因为使用UUID的目的是给某个资源分配一个在当前环境下唯一的标识符。而一个程序只有在运行的时候才谈得上有一个<strong>环境</strong>，进程之间又互不影响。因此，一般在编程语言规范中并没有对UUID生成方法进行规定。</p>
<p>但<em>unique id</em>还是很常用的，比如：</p>
<ul>
<li>PHP - uniqid() <a href="http://php.net/manual/en/function.uniqid.php#94959" target="_blank" rel="external">http://php.net/manual/en/function.uniqid.php#94959</a></li>
<li>Mysql - UUID() <a href="http://dev.mysql.com/doc/refman/5.1/en/miscellaneous-functions.html#function_uuid" target="_blank" rel="external">http://dev.mysql.com/doc/refman/5.1/en/miscellaneous-functions.html#function_uuid</a></li>
<li>Java - UUID <a href="http://docs.oracle.com/javase/7/docs/api/java/util/UUID.html" target="_blank" rel="external">http://docs.oracle.com/javase/7/docs/api/java/util/UUID.html</a></li>
</ul>
<p>但这些UUID方法只是借用了<em>唯一性</em>的概念，并不是必须。而且uuid规定128bits，很多情况下有点浪费。</p>
<p>你可以用任何方法来生成一个程序内唯一的字符串，比如mysql中的incremental id，它就比uuid实用。</p>
<p>##UUID in Javascript<br>既然要生成UUID，那么得符合规范。</p>
<ul>
<li>Javascript function</li>
</ul>
<pre><code class="language-javascript">function generateUUID(){
    var d = new Date().getTime();
    var uuid = &#39;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&#39;.replace(/[xy]/g, function(c) {
        var r = (d + Math.random()*16)%16 | 0;
        d = Math.floor(d/16);
        return (c==&#39;x&#39; ? r : (r&amp;0x7|0x8)).toString(16);
    });
    return uuid;
};
</code></pre>
<ul>
<li>Node module<br><a href="https://github.com/broofa/node-uuid" target="_blank" rel="external">https://github.com/broofa/node-uuid</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/uuid/">uuid</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-使用淘宝npm镜像cnpm" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/08/05/使用淘宝npm镜像cnpm/" class="article-date">
  	<time datetime="2016-08-05T03:24:36.000Z" itemprop="datePublished">2016-08-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/05/使用淘宝npm镜像cnpm/">使用淘宝npm镜像cnpm</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>在使用 node 模块时可以使用 npm install 查找 package.json 中的声明的依赖模块并安装。  </p>
</blockquote>
<p>但因为国内网络原因，使用 npm 安装某些模块会非常慢，甚至无法安装所有的包。<br>幸运的是,国内有几个镜像站点可以供我们使用,比如 <code>https://registry.cnpmjs.org</code>、<code>https://registry.npm.taobao.org</code>,速度非常快,镜像站会实时更新,为我们节省了好多时间.    </p>
<h5 id="那么-如何给本机换源呢"><a href="#那么-如何给本机换源呢" class="headerlink" title="那么,如何给本机换源呢?"></a>那么,如何给本机换源呢?</h5><p>(1)[临时]通过 <code>config</code> 配置指向国内镜像源</p>
<pre><code class="language-git"># 配置指向源
npm config set registry http://registry.cnpmjs.org
</code></pre>
<p>(2)[临时]通过 <code>npm</code> 命令指定下载源</p>
<pre><code class="language-git">npm --registry http://registry.cnpmjs.org
</code></pre>
<p>(3)[linux]在配置文件 <code>~/.npmrc</code> 文件写入源地址</p>
<pre><code class="language-git">//打开配置文件
nano ~/.npmrc
//写入配置文件
registry =https://registry.npm.taobao.org
</code></pre>
<p>推荐使用最后一种方法,一劳永逸,前面2钟方法都是临时改变包下载源.<br>如果你不想使用国内镜像站点,只需要将 写入 <code>~/.npmrc</code> 的配置内容删除即可.  </p>
<p>配置后可通过下面方式来验证是否成功</p>
<pre><code class="language-git">npm config get registry
// 或
npm info express
</code></pre>
<h5 id="使用cnpm"><a href="#使用cnpm" class="headerlink" title="使用cnpm"></a>使用cnpm</h5><p>或者你也可以安装<code>cnpm</code>包，使用<code>cnpm</code>替代<code>npm</code>：</p>
<pre><code class="language-git">npm install -g cnpm --registry=https://registry.npm.taobao.org
</code></pre>
<p>然后使用 <code>cnpm</code> 安装模块：</p>
<pre><code class="language-git">cnpm install [module-name]
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cnpm/">cnpm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/npm/">npm</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-html5在iOS设备上传图片调整方向实践" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/18/html5在iOS设备上传图片调整方向实践/" class="article-date">
  	<time datetime="2016-07-18T11:56:54.000Z" itemprop="datePublished">2016-07-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/18/html5在iOS设备上传图片调整方向实践/">html5在iOS设备上传图片调整方向实践</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>解决在iOS设备上，用H5上传图片，有时图片方向会错乱的问题。</p>
</blockquote>
<p>用html5编写图片裁切上传，在iphone手机上可能会遇到图片方向错误问题，在此把解决方法和大家分享一下，<br>用到了html5的 FileReader和Canvas，如果还没有接触的同学，先了解一下其方法。   </p>
<pre><code class="language-javascript"> //此方法为file input元素的change事件
 function change(){
    var file = this.files[0];
    var orientation;
    //EXIF js 可以读取图片的元信息  https://github.com/exif-js/exif-js
    EXIF.getData(file,function(){
        orientation=EXIF.getTag(this,&#39;Orientation&#39;);
    });
    var reader = new FileReader();
    reader.onload = function(e) {   
        getImgData(this.result,orientation,function(data){
            //这里可以使用校正后的图片data了 
        }); 
    }
    reader.readAsDataURL(file);
}
</code></pre>
<p>下面是具体的处理方式：</p>
<pre><code class="language-javascript">// @param {string} img 图片的base64
// @param {int} dir exif获取的方向信息
// @param {function} next 回调方法，返回校正方向后的base64
function getImgData(img,dir,next){
  var image=new Image();
  image.onload=function(){
    var degree=0,drawWidth,drawHeight,width,height;
    drawWidth=this.naturalWidth;
    drawHeight=this.naturalHeight;
    //以下改变一下图片大小
    var maxSide = Math.max(drawWidth, drawHeight);
    if (maxSide &gt; 1024) {
        var minSide = Math.min(drawWidth, drawHeight);
        minSide = minSide / maxSide * 1024;
        maxSide = 1024;
        if (drawWidth &gt; drawHeight) {
            drawWidth = maxSide;
            drawHeight = minSide;
        } else {
            drawWidth = minSide;
            drawHeight = maxSide;
        }
    }
    var canvas=document.createElement(&#39;canvas&#39;);
    canvas.width=width=drawWidth;
    canvas.height=height=drawHeight; 
    var context=canvas.getContext(&#39;2d&#39;);
    //判断图片方向，重置canvas大小，确定旋转角度，iphone默认的是home键在右方的横屏拍摄方式
    switch(dir){
       //iphone横屏拍摄，此时home键在左侧
        case 3:
            degree=180;
            drawWidth=-width;
            drawHeight=-height;
            break;
        //iphone竖屏拍摄，此时home键在下方(正常拿手机的方向)
        case 6:
            canvas.width=height;
            canvas.height=width; 
            degree=90;
            drawWidth=width;
            drawHeight=-height;
            break;
        //iphone竖屏拍摄，此时home键在上方
        case 8:
            canvas.width=height;
            canvas.height=width; 
            degree=270;
            drawWidth=-width;
            drawHeight=height;
            break;
    }
    //使用canvas旋转校正
    context.rotate(degree*Math.PI/180);
    context.drawImage(this,0,0,drawWidth,drawHeight);
    //返回校正图片
    next(canvas.toDataURL(&quot;image/jpeg&quot;,.8));
 }
  image.src=img;
}
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/移动端开发/">移动端开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 芥子园
    	</div>
      	<div class="footer-right">
      		Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>



<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-76943829-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
  <script src="http://7xth8v.com2.z0.glb.qiniucdn.com/js/prism.js"></script>
</body>
</html>